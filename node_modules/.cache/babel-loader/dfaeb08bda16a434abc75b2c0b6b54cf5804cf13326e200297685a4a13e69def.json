{"ast":null,"code":"import { getRandomDirection, playerInView } from './move-monster';\nimport { move } from './normal-ai';\nimport { SPRITE_SIZE, SIGHT_RADIUS } from '../../../config/constants';\nimport attackPlayer from './attack-player';\n\n/**\n * An AI for monsters who have the capability of using ranged attacks\n *\n * @param {*} sightBox The players FOV\n * @param {*} currentMap The map the player is in\n * @param {*} monster The monster we're moving\n */\nexport default function ranged(sightBox, currentMap, monster) {\n  return (dispatch, getState) => {\n    const {\n      id,\n      position\n    } = monster;\n    const monsterPosition = position.map(pos => pos / SPRITE_SIZE);\n    let monsterVisible = false;\n    // look through each current sight box tile\n    sightBox.forEach(tile => {\n      // if the monster is in sight\n      if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n        monsterVisible = true;\n      }\n    });\n    if (monsterVisible) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n      const {\n        player\n      } = getState();\n      // check if player is in range\n      if (dispatch(playerInView(monsterPosition, SIGHT_RADIUS))) {\n        dispatch(attackPlayer(monster));\n      } else {\n        // no player in range, time to move!\n        // get the monsters actual position in pixels\n        const position = monsterPosition.map(value => value * SPRITE_SIZE);\n        // get distance from player on both axis\n        const xDiff = position[0] - player.position[0];\n        const yDiff = position[1] - player.position[1];\n        const greaterY = Math.abs(yDiff) > Math.abs(xDiff);\n        // see if y axis is greater distance from player\n        if (greaterY) {\n          // if the monster is mostly below the player on the y axis\n          if (yDiff > 0) {\n            // move the monster 'up' relatively\n            dispatch(move('up', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n          // if the monster is mostly above the player on the y axis\n          else if (yDiff < 0) {\n            // move the monster 'down' relatively\n            dispatch(move('down', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n        } // x axis is greater distance from player\n        else {\n          // if the monster is mostly to the right of the player\n          if (xDiff > 0) {\n            // move the monster 'left' relatively\n            dispatch(move('left', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n          // if the monster is mostly to the left of the player\n          else if (xDiff < 0) {\n            // move the monster 'right' relatively\n            dispatch(move('right', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n        }\n      }\n    } else {\n      // monster is too far away from the player\n      dispatch({\n        type: 'HIDE_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n      // give a 25% chance to move the monster when hidden\n      if (Math.round(Math.random() * (4 - 1) + 1) !== 4) {\n        const randomDirection = getRandomDirection();\n        // move the monster in a random direction\n        dispatch(move(randomDirection, position, currentMap, id, 0));\n      }\n    }\n  };\n}","map":{"version":3,"names":["getRandomDirection","playerInView","move","SPRITE_SIZE","SIGHT_RADIUS","attackPlayer","ranged","sightBox","currentMap","monster","dispatch","getState","id","position","monsterPosition","map","pos","monsterVisible","forEach","tile","JSON","stringify","type","payload","player","value","xDiff","yDiff","greaterY","Math","abs","round","random","randomDirection"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/monsters/actions/ranged-ai.jsx"],"sourcesContent":["import { getRandomDirection, playerInView } from './move-monster';\nimport { move } from './normal-ai';\nimport { SPRITE_SIZE, SIGHT_RADIUS } from '../../../config/constants';\nimport attackPlayer from './attack-player';\n\n/**\n * An AI for monsters who have the capability of using ranged attacks\n *\n * @param {*} sightBox The players FOV\n * @param {*} currentMap The map the player is in\n * @param {*} monster The monster we're moving\n */\nexport default function ranged(sightBox, currentMap, monster) {\n    return (dispatch, getState) => {\n        const { id, position } = monster;\n\n        const monsterPosition = position.map(pos => pos / SPRITE_SIZE);\n\n        let monsterVisible = false;\n        // look through each current sight box tile\n        sightBox.forEach(tile => {\n            // if the monster is in sight\n            if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n                monsterVisible = true;\n            }\n        });\n\n        if (monsterVisible) {\n            dispatch({\n                type: 'REVEAL_MONSTER',\n                payload: { id, map: currentMap },\n            });\n\n            const { player } = getState();\n            // check if player is in range\n            if (dispatch(playerInView(monsterPosition, SIGHT_RADIUS))) {\n                dispatch(attackPlayer(monster));\n            } else {\n                // no player in range, time to move!\n                // get the monsters actual position in pixels\n                const position = monsterPosition.map(\n                    value => value * SPRITE_SIZE\n                );\n                // get distance from player on both axis\n                const xDiff = position[0] - player.position[0];\n                const yDiff = position[1] - player.position[1];\n                const greaterY = Math.abs(yDiff) > Math.abs(xDiff);\n                // see if y axis is greater distance from player\n                if (greaterY) {\n                    // if the monster is mostly below the player on the y axis\n                    if (yDiff > 0) {\n                        // move the monster 'up' relatively\n                        dispatch(\n                            move(\n                                'up',\n                                position,\n                                currentMap,\n                                id,\n                                0,\n                                xDiff >= 0 ? 'left' : 'right'\n                            )\n                        );\n                    }\n                    // if the monster is mostly above the player on the y axis\n                    else if (yDiff < 0) {\n                        // move the monster 'down' relatively\n                        dispatch(\n                            move(\n                                'down',\n                                position,\n                                currentMap,\n                                id,\n                                0,\n                                xDiff >= 0 ? 'left' : 'right'\n                            )\n                        );\n                    }\n                } // x axis is greater distance from player\n                else {\n                    // if the monster is mostly to the right of the player\n                    if (xDiff > 0) {\n                        // move the monster 'left' relatively\n                        dispatch(\n                            move(\n                                'left',\n                                position,\n                                currentMap,\n                                id,\n                                0,\n                                yDiff >= 0 ? 'up' : 'down'\n                            )\n                        );\n                    }\n                    // if the monster is mostly to the left of the player\n                    else if (xDiff < 0) {\n                        // move the monster 'right' relatively\n                        dispatch(\n                            move(\n                                'right',\n                                position,\n                                currentMap,\n                                id,\n                                0,\n                                yDiff >= 0 ? 'up' : 'down'\n                            )\n                        );\n                    }\n                }\n            }\n        } else {\n            // monster is too far away from the player\n            dispatch({\n                type: 'HIDE_MONSTER',\n                payload: { id, map: currentMap },\n            });\n            // give a 25% chance to move the monster when hidden\n            if (Math.round(Math.random() * (4 - 1) + 1) !== 4) {\n                const randomDirection = getRandomDirection();\n                // move the monster in a random direction\n                dispatch(move(randomDirection, position, currentMap, id, 0));\n            }\n        }\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}