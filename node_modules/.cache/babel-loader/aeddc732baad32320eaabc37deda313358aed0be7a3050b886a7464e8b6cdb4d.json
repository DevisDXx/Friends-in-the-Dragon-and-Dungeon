{"ast":null,"code":"import { observeImpassable, checkForOtherMonster } from './move-monster';\nimport attackMonster from './attack-monster';\nimport { SPRITE_SIZE } from '../../../config/constants';\n\n/**\n * An AI for monsters that have been scared by the player\n *\n * @param {*} sightBox The players FOV\n * @param {*} currentMap The map the player is in\n * @param {*} monster The monster we're moving\n */\nfunction moveScared(sightBox, currentMap, monster) {\n  return (dispatch, getState) => {\n    const playerPosition = getState().player.position;\n    const {\n      id,\n      position,\n      direction\n    } = monster;\n    const possibleDirections = [];\n    if (playerPosition[1] !== position[1] - SPRITE_SIZE && dispatch(observeImpassable([position[0], position[1] - SPRITE_SIZE]))) {\n      possibleDirections.push([position[0], position[1] - SPRITE_SIZE]);\n    }\n    if (playerPosition[1] !== position[1] + SPRITE_SIZE && dispatch(observeImpassable([position[0], position[1] + SPRITE_SIZE]))) {\n      possibleDirections.push([position[0], position[1] + SPRITE_SIZE]);\n    }\n    if (playerPosition[0] !== position[0] - SPRITE_SIZE && dispatch(observeImpassable([position[0] - SPRITE_SIZE, position[1]]))) {\n      possibleDirections.push([position[0] - SPRITE_SIZE, position[1]]);\n    }\n    if (playerPosition[0] !== position[0] + SPRITE_SIZE && dispatch(observeImpassable([position[0] + SPRITE_SIZE, position[1]]))) {\n      possibleDirections.push([position[0] + SPRITE_SIZE, position[1]]);\n    }\n    if (possibleDirections.length > 0) {\n      const newPosition = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];\n\n      // From testing, this doesn't really happen... But, if the monster is scared,\n      // it may randomly attack other monsters if they're in thise ones way\n      const monsterID = dispatch(checkForOtherMonster(id, newPosition, currentMap));\n      if (monsterID) {\n        // recalculate if the monster is in sight\n        let inSight = false;\n        // look through each current sight box tile\n        sightBox.forEach(tile => {\n          // if the monster is in sight\n          const newMonsterPos = position.map(value => value / SPRITE_SIZE);\n          if (JSON.stringify(tile) === JSON.stringify(newMonsterPos)) {\n            inSight = true;\n          }\n        });\n\n        // if the monster is now in sight\n        if (inSight) {\n          dispatch({\n            type: 'REVEAL_MONSTER',\n            payload: {\n              id,\n              map: currentMap\n            }\n          });\n        } else {\n          // if the monster is now out of sight\n          dispatch({\n            type: 'HIDE_MONSTER',\n            payload: {\n              id,\n              map: currentMap\n            }\n          });\n        }\n        dispatch(attackMonster(monster, monsterID, currentMap));\n      } else {\n        let inSight = false;\n        // look through each current sight box tile\n        sightBox.forEach(tile => {\n          // if the monster is in sight\n          const newMonsterPos = newPosition.map(value => value / SPRITE_SIZE);\n          if (JSON.stringify(tile) === JSON.stringify(newMonsterPos)) {\n            inSight = true;\n          }\n        });\n        // if the monster is now in sight\n        if (inSight) {\n          dispatch({\n            type: 'REVEAL_MONSTER',\n            payload: {\n              id,\n              map: currentMap\n            }\n          });\n        } else {\n          // if the monster is now out of sight\n          dispatch({\n            type: 'HIDE_MONSTER',\n            payload: {\n              id,\n              map: currentMap\n            }\n          });\n        }\n        // move the monster\n        dispatch({\n          type: 'MOVE_MONSTER',\n          payload: {\n            map: currentMap,\n            id,\n            position: newPosition,\n            direction: newPosition[0] < position[0] ? 'WEST' : newPosition[0] > position[0] ? 'EAST' : direction\n          }\n        });\n      }\n    }\n  };\n}\nexport default function scared(sightBox, currentMap, monster) {\n  return dispatch => {\n    const {\n      id,\n      position\n    } = monster;\n    const monsterPosition = position.map(pos => pos / SPRITE_SIZE);\n    let monsterVisible = false;\n    // look through each current sight box tile\n    sightBox.forEach(tile => {\n      // if the monster is in sight\n      if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n        monsterVisible = true;\n      }\n    });\n    if (monsterVisible) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n    }\n    dispatch(moveScared(sightBox, currentMap, monster));\n    if (monster.aiTurns === 0) {\n      dispatch({\n        type: 'CHANGE_AI',\n        payload: {\n          map: currentMap,\n          ai: monster.originalAI,\n          id: monster.id,\n          from: 'scared',\n          turns: 0,\n          entity: monster.type,\n          original: monster.originalAI\n        }\n      });\n    }\n  };\n}","map":{"version":3,"names":["observeImpassable","checkForOtherMonster","attackMonster","SPRITE_SIZE","moveScared","sightBox","currentMap","monster","dispatch","getState","playerPosition","player","position","id","direction","possibleDirections","push","length","newPosition","Math","floor","random","monsterID","inSight","forEach","tile","newMonsterPos","map","value","JSON","stringify","type","payload","scared","monsterPosition","pos","monsterVisible","aiTurns","ai","originalAI","from","turns","entity","original"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/monsters/actions/scared-ai.jsx"],"sourcesContent":["import { observeImpassable, checkForOtherMonster } from './move-monster';\nimport attackMonster from './attack-monster';\nimport { SPRITE_SIZE } from '../../../config/constants';\n\n/**\n * An AI for monsters that have been scared by the player\n *\n * @param {*} sightBox The players FOV\n * @param {*} currentMap The map the player is in\n * @param {*} monster The monster we're moving\n */\nfunction moveScared(sightBox, currentMap, monster) {\n  return (dispatch, getState) => {\n    const playerPosition = getState().player.position;\n    const { id, position, direction } = monster;\n\n    const possibleDirections = [];\n    if (\n      playerPosition[1] !== position[1] - SPRITE_SIZE &&\n      dispatch(observeImpassable([position[0], position[1] - SPRITE_SIZE]))\n    ) {\n      possibleDirections.push([position[0], position[1] - SPRITE_SIZE]);\n    }\n\n    if (\n      playerPosition[1] !== position[1] + SPRITE_SIZE &&\n      dispatch(observeImpassable([position[0], position[1] + SPRITE_SIZE]))\n    ) {\n      possibleDirections.push([position[0], position[1] + SPRITE_SIZE]);\n    }\n\n    if (\n      playerPosition[0] !== position[0] - SPRITE_SIZE &&\n      dispatch(observeImpassable([position[0] - SPRITE_SIZE, position[1]]))\n    ) {\n      possibleDirections.push([position[0] - SPRITE_SIZE, position[1]]);\n    }\n\n    if (\n      playerPosition[0] !== position[0] + SPRITE_SIZE &&\n      dispatch(observeImpassable([position[0] + SPRITE_SIZE, position[1]]))\n    ) {\n      possibleDirections.push([position[0] + SPRITE_SIZE, position[1]]);\n    }\n\n    if (possibleDirections.length > 0) {\n      const newPosition = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];\n\n      // From testing, this doesn't really happen... But, if the monster is scared,\n      // it may randomly attack other monsters if they're in thise ones way\n      const monsterID = dispatch(checkForOtherMonster(id, newPosition, currentMap));\n\n      if (monsterID) {\n        // recalculate if the monster is in sight\n        let inSight = false;\n        // look through each current sight box tile\n        sightBox.forEach((tile) => {\n          // if the monster is in sight\n          const newMonsterPos = position.map((value) => value / SPRITE_SIZE);\n          if (JSON.stringify(tile) === JSON.stringify(newMonsterPos)) {\n            inSight = true;\n          }\n        });\n\n        // if the monster is now in sight\n        if (inSight) {\n          dispatch({\n            type: 'REVEAL_MONSTER',\n            payload: { id, map: currentMap },\n          });\n        } else {\n          // if the monster is now out of sight\n          dispatch({\n            type: 'HIDE_MONSTER',\n            payload: { id, map: currentMap },\n          });\n        }\n\n        dispatch(attackMonster(monster, monsterID, currentMap));\n      } else {\n        let inSight = false;\n        // look through each current sight box tile\n        sightBox.forEach((tile) => {\n          // if the monster is in sight\n          const newMonsterPos = newPosition.map((value) => value / SPRITE_SIZE);\n          if (JSON.stringify(tile) === JSON.stringify(newMonsterPos)) {\n            inSight = true;\n          }\n        });\n        // if the monster is now in sight\n        if (inSight) {\n          dispatch({\n            type: 'REVEAL_MONSTER',\n            payload: { id, map: currentMap },\n          });\n        } else {\n          // if the monster is now out of sight\n          dispatch({\n            type: 'HIDE_MONSTER',\n            payload: { id, map: currentMap },\n          });\n        }\n        // move the monster\n        dispatch({\n          type: 'MOVE_MONSTER',\n          payload: {\n            map: currentMap,\n            id,\n            position: newPosition,\n            direction:\n              newPosition[0] < position[0]\n                ? 'WEST'\n                : newPosition[0] > position[0]\n                ? 'EAST'\n                : direction,\n          },\n        });\n      }\n    }\n  };\n}\n\nexport default function scared(sightBox, currentMap, monster) {\n  return (dispatch) => {\n    const { id, position } = monster;\n\n    const monsterPosition = position.map((pos) => pos / SPRITE_SIZE);\n\n    let monsterVisible = false;\n    // look through each current sight box tile\n    sightBox.forEach((tile) => {\n      // if the monster is in sight\n      if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n        monsterVisible = true;\n      }\n    });\n\n    if (monsterVisible) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: { id, map: currentMap },\n      });\n    }\n\n    dispatch(moveScared(sightBox, currentMap, monster));\n\n    if (monster.aiTurns === 0) {\n      dispatch({\n        type: 'CHANGE_AI',\n        payload: {\n          map: currentMap,\n          ai: monster.originalAI,\n          id: monster.id,\n          from: 'scared',\n          turns: 0,\n          entity: monster.type,\n          original: monster.originalAI,\n        },\n      });\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}