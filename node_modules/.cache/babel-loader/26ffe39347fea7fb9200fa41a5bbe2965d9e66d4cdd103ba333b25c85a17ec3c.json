{"ast":null,"code":"import { playerInRange, getRandomDirection } from './move-monster';\nimport { move } from './normal-ai';\nimport { calculateDamage } from '../../../utils/dice';\nimport { SPRITE_SIZE } from '../../../config/constants';\n\n/**\n * An AI for monsters who will deal damage to the player and die when they come in\n * contact with the player\n *\n * @param {*} sightBox The players FOV\n * @param {*} currentMap The map the player is in\n * @param {*} monster The monster we're moving\n */\nexport default function suicidal(sightBox, currentMap, monster) {\n  return (dispatch, getState) => {\n    const {\n      stats\n    } = getState();\n    const {\n      id,\n      position,\n      dice,\n      type\n    } = monster;\n    const monsterPosition = position.map(pos => pos / SPRITE_SIZE);\n    let monsterVisible = false;\n    // look through each current sight box tile\n    sightBox.forEach(tile => {\n      // if the monster is in sight\n      if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n        monsterVisible = true;\n      }\n    });\n    if (monsterVisible) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n      const {\n        player\n      } = getState();\n      // check if player is in range\n      if (playerInRange(player.position, monsterPosition)) {\n        const calculatedMonsterDamage = calculateDamage(dice);\n        dispatch({\n          type: 'DAMAGE_TO_PLAYER',\n          payload: {\n            damage: calculatedMonsterDamage,\n            entity: type,\n            kind: 'suicide'\n          }\n        });\n\n        // check if player died\n        if (stats.hp - calculatedMonsterDamage <= 0) {\n          // play death sound\n          dispatch({\n            type: 'PLAYER_DIED',\n            payload: {\n              entity: type\n            }\n          });\n          // if it did, game over\n          dispatch({\n            type: 'PAUSE',\n            payload: {\n              gameOver: true,\n              pause: true\n            }\n          });\n        }\n        // deal damage to monster\n        dispatch({\n          type: 'DAMAGE_TO_MONSTER',\n          payload: {\n            damage: monster.hp,\n            id: monster.id,\n            map: currentMap,\n            entity: monster.type,\n            from: 'suicide'\n          }\n        });\n        dispatch({\n          type: 'GET_EXP',\n          payload: monster.exp\n        });\n        if (stats.exp + monster.exp >= stats.expToLevel) {\n          dispatch({\n            type: 'PAUSE',\n            payload: {\n              pause: true,\n              levelUp: true\n            }\n          });\n        }\n        // play death sound\n        dispatch({\n          type: 'MONSTER_DIED',\n          payload: monster.type\n        });\n        // replace monster will blood spill\n        // need to pass relative tile index\n        dispatch({\n          type: 'ADD_BLOOD_SPILL',\n          payload: {\n            x: position[0] / SPRITE_SIZE,\n            y: position[1] / SPRITE_SIZE\n          }\n        });\n      } else {\n        // no player in range, time to move!\n        // get the monsters actual position in pixels\n        const position = monsterPosition.map(value => value * SPRITE_SIZE);\n        // get distance from player on both axis\n        const xDiff = position[0] - player.position[0];\n        const yDiff = position[1] - player.position[1];\n        const greaterY = Math.abs(yDiff) > Math.abs(xDiff);\n        // see if y axis is greater distance from player\n        if (greaterY) {\n          // if the monster is mostly below the player on the y axis\n          if (yDiff > 0) {\n            // move the monster 'up' relatively\n            dispatch(move('up', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n          // if the monster is mostly above the player on the y axis\n          else if (yDiff < 0) {\n            // move the monster 'down' relatively\n            dispatch(move('down', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n        } // x axis is greater distance from player\n        else {\n          // if the monster is mostly to the right of the player\n          if (xDiff > 0) {\n            // move the monster 'left' relatively\n            dispatch(move('left', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n          // if the monster is mostly to the left of the player\n          else if (xDiff < 0) {\n            // move the monster 'right' relatively\n            dispatch(move('right', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n        }\n      }\n    } else {\n      // monster is too far away from the player\n      dispatch({\n        type: 'HIDE_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n      // give a 25% chance to move the monster when hidden\n      if (Math.round(Math.random() * (4 - 1) + 1) !== 4) {\n        const randomDirection = getRandomDirection();\n        // move the monster in a random direction\n        dispatch(move(randomDirection, position, currentMap, id, 0));\n      }\n    }\n  };\n}","map":{"version":3,"names":["playerInRange","getRandomDirection","move","calculateDamage","SPRITE_SIZE","suicidal","sightBox","currentMap","monster","dispatch","getState","stats","id","position","dice","type","monsterPosition","map","pos","monsterVisible","forEach","tile","JSON","stringify","payload","player","calculatedMonsterDamage","damage","entity","kind","hp","gameOver","pause","from","exp","expToLevel","levelUp","x","y","value","xDiff","yDiff","greaterY","Math","abs","round","random","randomDirection"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/monsters/actions/suicidal-ai.jsx"],"sourcesContent":["import { playerInRange, getRandomDirection } from './move-monster';\nimport { move } from './normal-ai';\nimport { calculateDamage } from '../../../utils/dice';\nimport { SPRITE_SIZE } from '../../../config/constants';\n\n/**\n * An AI for monsters who will deal damage to the player and die when they come in\n * contact with the player\n *\n * @param {*} sightBox The players FOV\n * @param {*} currentMap The map the player is in\n * @param {*} monster The monster we're moving\n */\nexport default function suicidal(sightBox, currentMap, monster) {\n  return (dispatch, getState) => {\n    const { stats } = getState();\n    const { id, position, dice, type } = monster;\n\n    const monsterPosition = position.map((pos) => pos / SPRITE_SIZE);\n\n    let monsterVisible = false;\n    // look through each current sight box tile\n    sightBox.forEach((tile) => {\n      // if the monster is in sight\n      if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n        monsterVisible = true;\n      }\n    });\n\n    if (monsterVisible) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: { id, map: currentMap },\n      });\n\n      const { player } = getState();\n      // check if player is in range\n      if (playerInRange(player.position, monsterPosition)) {\n        const calculatedMonsterDamage = calculateDamage(dice);\n        dispatch({\n          type: 'DAMAGE_TO_PLAYER',\n          payload: {\n            damage: calculatedMonsterDamage,\n            entity: type,\n            kind: 'suicide',\n          },\n        });\n\n        // check if player died\n        if (stats.hp - calculatedMonsterDamage <= 0) {\n          // play death sound\n          dispatch({\n            type: 'PLAYER_DIED',\n            payload: { entity: type },\n          });\n          // if it did, game over\n          dispatch({\n            type: 'PAUSE',\n            payload: {\n              gameOver: true,\n              pause: true,\n            },\n          });\n        }\n        // deal damage to monster\n        dispatch({\n          type: 'DAMAGE_TO_MONSTER',\n          payload: {\n            damage: monster.hp,\n            id: monster.id,\n            map: currentMap,\n            entity: monster.type,\n            from: 'suicide',\n          },\n        });\n\n        dispatch({\n          type: 'GET_EXP',\n          payload: monster.exp,\n        });\n\n        if (stats.exp + monster.exp >= stats.expToLevel) {\n          dispatch({\n            type: 'PAUSE',\n            payload: {\n              pause: true,\n              levelUp: true,\n            },\n          });\n        }\n        // play death sound\n        dispatch({\n          type: 'MONSTER_DIED',\n          payload: monster.type,\n        });\n        // replace monster will blood spill\n        // need to pass relative tile index\n        dispatch({\n          type: 'ADD_BLOOD_SPILL',\n          payload: {\n            x: position[0] / SPRITE_SIZE,\n            y: position[1] / SPRITE_SIZE,\n          },\n        });\n      } else {\n        // no player in range, time to move!\n        // get the monsters actual position in pixels\n        const position = monsterPosition.map((value) => value * SPRITE_SIZE);\n        // get distance from player on both axis\n        const xDiff = position[0] - player.position[0];\n        const yDiff = position[1] - player.position[1];\n        const greaterY = Math.abs(yDiff) > Math.abs(xDiff);\n        // see if y axis is greater distance from player\n        if (greaterY) {\n          // if the monster is mostly below the player on the y axis\n          if (yDiff > 0) {\n            // move the monster 'up' relatively\n            dispatch(move('up', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n          // if the monster is mostly above the player on the y axis\n          else if (yDiff < 0) {\n            // move the monster 'down' relatively\n            dispatch(move('down', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n        } // x axis is greater distance from player\n        else {\n          // if the monster is mostly to the right of the player\n          if (xDiff > 0) {\n            // move the monster 'left' relatively\n            dispatch(move('left', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n          // if the monster is mostly to the left of the player\n          else if (xDiff < 0) {\n            // move the monster 'right' relatively\n            dispatch(move('right', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n        }\n      }\n    } else {\n      // monster is too far away from the player\n      dispatch({\n        type: 'HIDE_MONSTER',\n        payload: { id, map: currentMap },\n      });\n      // give a 25% chance to move the monster when hidden\n      if (Math.round(Math.random() * (4 - 1) + 1) !== 4) {\n        const randomDirection = getRandomDirection();\n        // move the monster in a random direction\n        dispatch(move(randomDirection, position, currentMap, id, 0));\n      }\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}