{"ast":null,"code":"import exploreTiles from './explore-tiles';\nimport exploreChest from './explore-chest';\nimport walkStairs from './walk-stairs';\nimport getNextTile from '../../../utils/get-next-tile';\nimport { SPRITE_SIZE, MAP_WIDTH, MAP_HEIGHT, PASSIVE_MANA_RESTORE_TURNS, OUT_OF_COMBAT_RANGE } from '../../../config/constants';\nimport { calculateDamage } from '../../../utils/dice';\nexport function applyEffects() {\n  return (dispatch, getState) => {\n    const {\n      player,\n      stats\n    } = getState();\n    Object.keys(player.effects).forEach(effect => {\n      const props = player.effects[effect];\n      if (props.turns > 0) {\n        const damage = Math.floor(calculateDamage(props.damage) / 2);\n        if (damage > 0) {\n          dispatch({\n            type: 'DAMAGE_TO_PLAYER',\n            payload: {\n              damage,\n              effect: props.from\n            }\n          });\n\n          // check if player died\n          if (stats.hp - damage <= 0) {\n            // play death sound\n            dispatch({\n              type: 'PLAYER_DIED',\n              payload: {\n                from: props.from\n              }\n            });\n            // if it did, game over\n            dispatch({\n              type: 'PAUSE',\n              payload: {\n                gameOver: true,\n                pause: true\n              }\n            });\n          }\n        }\n      }\n    });\n  };\n}\nexport default function movePlayer(direction) {\n  return (dispatch, getState) => {\n    const oldPos = getState().player.position;\n    const newPos = getNewPosition(oldPos, direction);\n    const facing = getState().player.direction;\n    const nextTile = observeImpassable(newPos);\n    if (observeBoundaries(newPos) && nextTile < 5 && !dispatch(checkForMonster(newPos, direction)) && (facing === direction || !dispatch(monstersWithinRange(newPos, OUT_OF_COMBAT_RANGE)))) {\n      // explore new tiles\n      dispatch(exploreTiles(newPos));\n      // move the player\n      dispatch({\n        type: 'MOVE_PLAYER',\n        payload: {\n          position: newPos,\n          direction\n        }\n      });\n\n      // if we do anything but use stairs, count a turn\n      if (handleInteractWithTile(nextTile, newPos)) {\n        dispatch({\n          type: 'TAKE_TURN',\n          payload: null\n        });\n        dispatch(applyEffects());\n        if (getState().player.turnsOutOfCombat % PASSIVE_MANA_RESTORE_TURNS === 0 && !dispatch(monstersWithinRange(newPos, OUT_OF_COMBAT_RANGE))) {\n          dispatch({\n            type: 'RESTORE_MANA',\n            payload: {\n              kind: 'passive',\n              amount: Math.ceil(getState().stats.maxMana / 10)\n            }\n          });\n        }\n      }\n    } // dont move the player\n    else {\n      const {\n        playerMoved,\n        position\n      } = getState().player;\n      // turn the player but do not play the\n      // walk animation triggered by a change in playerMoved\n      dispatch({\n        type: 'MOVE_PLAYER',\n        payload: {\n          direction,\n          playerMoved,\n          position\n        }\n      });\n    }\n    function handleInteractWithTile(nextTile, newPos) {\n      // the player wants to use the stairs\n      if (nextTile === 2 || nextTile === 3) {\n        dispatch({\n          type: 'MAP_TRANSITION',\n          payload: null\n        });\n        dispatch(walkStairs(nextTile, newPos));\n        return false;\n      }\n      // player wants to open chest\n      if (nextTile === 4) {\n        const y = newPos[1] / SPRITE_SIZE;\n        const x = newPos[0] / SPRITE_SIZE;\n        // open the chest\n        dispatch(exploreChest(x, y));\n      }\n      return true;\n    }\n    function observeImpassable(newPos) {\n      const nextTile = getNextTile(getState().world, newPos);\n\n      // the player wants to use the shop\n      if (nextTile === 9) {\n        // show the shop dialog\n        dispatch({\n          type: 'PAUSE',\n          payload: {\n            pause: true,\n            shop: true\n          }\n        });\n      }\n\n      // the player has accessed a shrine\n      if (nextTile === 10) {\n        // check if they have won the game\n        dispatch({\n          type: 'PAUSE',\n          payload: {\n            pause: true,\n            gameWin: true\n          }\n        });\n      }\n      return nextTile;\n    }\n  };\n}\nconst monstersWithinRange = (position, within) => {\n  return dispatch => {\n    for (let i = -within * SPRITE_SIZE; i < within * SPRITE_SIZE; i += SPRITE_SIZE) {\n      for (let j = -within * SPRITE_SIZE; j < within * SPRITE_SIZE; j += SPRITE_SIZE) {\n        const pos = [position[0] + i, position[1] + j];\n        if (dispatch(checkForMonster(pos))) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n};\n\n// returns `false` or the monster's id\nexport function checkForMonster(newPos) {\n  return (_, getState) => {\n    let isMonster = false;\n    const {\n      currentMap\n    } = getState().world;\n    const monsters = getState().monsters.components;\n    // check for monsters\n    Object.keys(monsters[currentMap]).forEach(monsterId => {\n      const currMonster = monsters[currentMap][monsterId];\n      // if the new position contains a monster\n      if (JSON.stringify(currMonster.position) === JSON.stringify(newPos)) {\n        isMonster = currMonster.id;\n      }\n    });\n    return isMonster;\n  };\n}\nexport function getNewPosition(oldPos, direction) {\n  switch (direction) {\n    case 'WEST':\n      return [oldPos[0] - SPRITE_SIZE, oldPos[1]];\n    case 'EAST':\n      return [oldPos[0] + SPRITE_SIZE, oldPos[1]];\n    case 'NORTH':\n      return [oldPos[0], oldPos[1] - SPRITE_SIZE];\n    case 'SOUTH':\n      return [oldPos[0], oldPos[1] + SPRITE_SIZE];\n    default:\n  }\n}\nexport function observeBoundaries(newPos) {\n  return newPos[0] >= 0 && newPos[0] <= MAP_WIDTH - SPRITE_SIZE && newPos[1] >= 0 && newPos[1] <= MAP_HEIGHT - SPRITE_SIZE;\n}","map":{"version":3,"names":["exploreTiles","exploreChest","walkStairs","getNextTile","SPRITE_SIZE","MAP_WIDTH","MAP_HEIGHT","PASSIVE_MANA_RESTORE_TURNS","OUT_OF_COMBAT_RANGE","calculateDamage","applyEffects","dispatch","getState","player","stats","Object","keys","effects","forEach","effect","props","turns","damage","Math","floor","type","payload","from","hp","gameOver","pause","movePlayer","direction","oldPos","position","newPos","getNewPosition","facing","nextTile","observeImpassable","observeBoundaries","checkForMonster","monstersWithinRange","handleInteractWithTile","turnsOutOfCombat","kind","amount","ceil","maxMana","playerMoved","y","x","world","shop","gameWin","within","i","j","pos","_","isMonster","currentMap","monsters","components","monsterId","currMonster","JSON","stringify","id"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/player/actions/move-player.jsx"],"sourcesContent":["import exploreTiles from './explore-tiles';\nimport exploreChest from './explore-chest';\nimport walkStairs from './walk-stairs';\nimport getNextTile from '../../../utils/get-next-tile';\nimport {\n    SPRITE_SIZE,\n    MAP_WIDTH,\n    MAP_HEIGHT,\n    PASSIVE_MANA_RESTORE_TURNS,\n    OUT_OF_COMBAT_RANGE,\n} from '../../../config/constants';\nimport { calculateDamage } from '../../../utils/dice';\n\nexport function applyEffects() {\n    return (dispatch, getState) => {\n        const { player, stats } = getState();\n\n        Object.keys(player.effects).forEach(effect => {\n            const props = player.effects[effect];\n            if (props.turns > 0) {\n                const damage = Math.floor(calculateDamage(props.damage) / 2);\n                if (damage > 0) {\n                    dispatch({\n                        type: 'DAMAGE_TO_PLAYER',\n                        payload: { damage, effect: props.from },\n                    });\n\n                    // check if player died\n                    if (stats.hp - damage <= 0) {\n                        // play death sound\n                        dispatch({\n                            type: 'PLAYER_DIED',\n                            payload: { from: props.from },\n                        });\n                        // if it did, game over\n                        dispatch({\n                            type: 'PAUSE',\n                            payload: {\n                                gameOver: true,\n                                pause: true,\n                            },\n                        });\n                    }\n                }\n            }\n        });\n    };\n}\n\nexport default function movePlayer(direction) {\n    return (dispatch, getState) => {\n        const oldPos = getState().player.position;\n        const newPos = getNewPosition(oldPos, direction);\n        const facing = getState().player.direction;\n\n        const nextTile = observeImpassable(newPos);\n\n        if (\n            observeBoundaries(newPos) &&\n            nextTile < 5 &&\n            !dispatch(checkForMonster(newPos, direction)) &&\n            (facing === direction ||\n                !dispatch(monstersWithinRange(newPos, OUT_OF_COMBAT_RANGE)))\n        ) {\n            // explore new tiles\n            dispatch(exploreTiles(newPos));\n            // move the player\n            dispatch({\n                type: 'MOVE_PLAYER',\n                payload: {\n                    position: newPos,\n                    direction,\n                },\n            });\n\n            // if we do anything but use stairs, count a turn\n            if (handleInteractWithTile(nextTile, newPos)) {\n                dispatch({\n                    type: 'TAKE_TURN',\n                    payload: null,\n                });\n\n                dispatch(applyEffects());\n\n                if (\n                    getState().player.turnsOutOfCombat %\n                        PASSIVE_MANA_RESTORE_TURNS ===\n                        0 &&\n                    !dispatch(monstersWithinRange(newPos, OUT_OF_COMBAT_RANGE))\n                ) {\n                    dispatch({\n                        type: 'RESTORE_MANA',\n                        payload: {\n                            kind: 'passive',\n                            amount: Math.ceil(getState().stats.maxMana / 10),\n                        },\n                    });\n                }\n            }\n        } // dont move the player\n        else {\n            const { playerMoved, position } = getState().player;\n            // turn the player but do not play the\n            // walk animation triggered by a change in playerMoved\n            dispatch({\n                type: 'MOVE_PLAYER',\n                payload: { direction, playerMoved, position },\n            });\n        }\n\n        function handleInteractWithTile(nextTile, newPos) {\n            // the player wants to use the stairs\n            if (nextTile === 2 || nextTile === 3) {\n                dispatch({\n                    type: 'MAP_TRANSITION',\n                    payload: null,\n                });\n                dispatch(walkStairs(nextTile, newPos));\n                return false;\n            }\n            // player wants to open chest\n            if (nextTile === 4) {\n                const y = newPos[1] / SPRITE_SIZE;\n                const x = newPos[0] / SPRITE_SIZE;\n                // open the chest\n                dispatch(exploreChest(x, y));\n            }\n            return true;\n        }\n\n        function observeImpassable(newPos) {\n            const nextTile = getNextTile(getState().world, newPos);\n\n            // the player wants to use the shop\n            if (nextTile === 9) {\n                // show the shop dialog\n                dispatch({\n                    type: 'PAUSE',\n                    payload: {\n                        pause: true,\n                        shop: true,\n                    },\n                });\n            }\n\n            // the player has accessed a shrine\n            if (nextTile === 10) {\n                // check if they have won the game\n                dispatch({\n                    type: 'PAUSE',\n                    payload: {\n                        pause: true,\n                        gameWin: true,\n                    },\n                });\n            }\n\n            return nextTile;\n        }\n    };\n}\n\nconst monstersWithinRange = (position, within) => {\n    return dispatch => {\n        for (\n            let i = -within * SPRITE_SIZE;\n            i < within * SPRITE_SIZE;\n            i += SPRITE_SIZE\n        ) {\n            for (\n                let j = -within * SPRITE_SIZE;\n                j < within * SPRITE_SIZE;\n                j += SPRITE_SIZE\n            ) {\n                const pos = [position[0] + i, position[1] + j];\n                if (dispatch(checkForMonster(pos))) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    };\n};\n\n// returns `false` or the monster's id\nexport function checkForMonster(newPos) {\n    return (_, getState) => {\n        let isMonster = false;\n        const { currentMap } = getState().world;\n        const monsters = getState().monsters.components;\n        // check for monsters\n        Object.keys(monsters[currentMap]).forEach(monsterId => {\n            const currMonster = monsters[currentMap][monsterId];\n            // if the new position contains a monster\n            if (\n                JSON.stringify(currMonster.position) === JSON.stringify(newPos)\n            ) {\n                isMonster = currMonster.id;\n            }\n        });\n\n        return isMonster;\n    };\n}\n\nexport function getNewPosition(oldPos, direction) {\n    switch (direction) {\n        case 'WEST':\n            return [oldPos[0] - SPRITE_SIZE, oldPos[1]];\n        case 'EAST':\n            return [oldPos[0] + SPRITE_SIZE, oldPos[1]];\n        case 'NORTH':\n            return [oldPos[0], oldPos[1] - SPRITE_SIZE];\n        case 'SOUTH':\n            return [oldPos[0], oldPos[1] + SPRITE_SIZE];\n        default:\n    }\n}\n\nexport function observeBoundaries(newPos) {\n    return (\n        newPos[0] >= 0 &&\n        newPos[0] <= MAP_WIDTH - SPRITE_SIZE &&\n        newPos[1] >= 0 &&\n        newPos[1] <= MAP_HEIGHT - SPRITE_SIZE\n    );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}