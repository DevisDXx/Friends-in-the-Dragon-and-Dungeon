{"ast":null,"code":"import { calculateDamage } from '../../../utils/dice';\nimport { SPRITE_SIZE } from '../../../config/constants';\nexport default function attackPlayer(monster) {\n  return (dispatch, getState) => {\n    const {\n      stats,\n      player\n    } = getState();\n    const {\n      attackValue,\n      dice,\n      type,\n      projectile,\n      position\n    } = monster;\n    const attack = calculateDamage(attackValue);\n    const calculatedMonsterDamage = attack >= Math.max(stats.defence, 0) ? calculateDamage(dice) : 0;\n    if (projectile && !projectile.target.includes('self')) {\n      let direction = '';\n      const targetPosition = [position[0] - player.position[0], position[1] - player.position[1]];\n      if (player.position[0] !== position[0]) {\n        if (player.position[0] < position[0]) {\n          direction = 'WEST';\n          targetPosition[0] -= SPRITE_SIZE;\n        } else {\n          direction = 'EAST';\n          targetPosition[0] += SPRITE_SIZE;\n        }\n      } else if (player.position[1] !== position[1]) {\n        if (player.position[1] < position[1]) {\n          direction = 'NORTH';\n          targetPosition[1] -= SPRITE_SIZE;\n        } else {\n          direction = 'SOUTH';\n          targetPosition[1] += SPRITE_SIZE;\n        }\n      }\n      dispatch({\n        type: 'MONSTER_USE_PROJECTILE',\n        payload: {\n          position: targetPosition,\n          projectile,\n          direction,\n          entity: type\n        }\n      });\n    }\n    dispatch({\n      type: 'MONSTER_ABILITY_CHECK',\n      payload: {\n        attackValue: attack,\n        check: Math.max(stats.defence, 0),\n        against: 'defence',\n        entity: type,\n        defender: 'player'\n      }\n    });\n    if (calculatedMonsterDamage > 0) {\n      // show the attack animation and play sound\n      dispatch({\n        type: 'MONSTER_ATTACK',\n        payload: null\n      });\n    }\n    dispatch({\n      type: 'DAMAGE_TO_PLAYER',\n      payload: {\n        damage: calculatedMonsterDamage,\n        entity: type\n      }\n    });\n\n    // check if player died\n    if (stats.hp - calculatedMonsterDamage <= 0) {\n      // play death sound\n      dispatch({\n        type: 'PLAYER_DIED',\n        payload: {\n          entity: type\n        }\n      });\n      // if it did, game over\n      dispatch({\n        type: 'PAUSE',\n        payload: {\n          gameOver: true,\n          pause: true\n        }\n      });\n    }\n  };\n}","map":{"version":3,"names":["calculateDamage","SPRITE_SIZE","attackPlayer","monster","dispatch","getState","stats","player","attackValue","dice","type","projectile","position","attack","calculatedMonsterDamage","Math","max","defence","target","includes","direction","targetPosition","payload","entity","check","against","defender","damage","hp","gameOver","pause"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/monsters/actions/attack-player.jsx"],"sourcesContent":["import { calculateDamage } from '../../../utils/dice';\nimport { SPRITE_SIZE } from '../../../config/constants';\n\nexport default function attackPlayer(monster) {\n    return (dispatch, getState) => {\n        const { stats, player } = getState();\n        const { attackValue, dice, type, projectile, position } = monster;\n\n        const attack = calculateDamage(attackValue);\n\n        const calculatedMonsterDamage =\n            attack >= Math.max(stats.defence, 0) ? calculateDamage(dice) : 0;\n\n        if (projectile && !projectile.target.includes('self')) {\n            let direction = '';\n            const targetPosition = [\n                position[0] - player.position[0],\n                position[1] - player.position[1],\n            ];\n\n            if (player.position[0] !== position[0]) {\n                if (player.position[0] < position[0]) {\n                    direction = 'WEST';\n                    targetPosition[0] -= SPRITE_SIZE;\n                } else {\n                    direction = 'EAST';\n                    targetPosition[0] += SPRITE_SIZE;\n                }\n            } else if (player.position[1] !== position[1]) {\n                if (player.position[1] < position[1]) {\n                    direction = 'NORTH';\n                    targetPosition[1] -= SPRITE_SIZE;\n                } else {\n                    direction = 'SOUTH';\n                    targetPosition[1] += SPRITE_SIZE;\n                }\n            }\n            dispatch({\n                type: 'MONSTER_USE_PROJECTILE',\n                payload: {\n                    position: targetPosition,\n                    projectile,\n                    direction,\n                    entity: type,\n                },\n            });\n        }\n\n        dispatch({\n            type: 'MONSTER_ABILITY_CHECK',\n            payload: {\n                attackValue: attack,\n                check: Math.max(stats.defence, 0),\n                against: 'defence',\n                entity: type,\n                defender: 'player',\n            },\n        });\n\n        if (calculatedMonsterDamage > 0) {\n            // show the attack animation and play sound\n            dispatch({\n                type: 'MONSTER_ATTACK',\n                payload: null,\n            });\n        }\n\n        dispatch({\n            type: 'DAMAGE_TO_PLAYER',\n            payload: { damage: calculatedMonsterDamage, entity: type },\n        });\n\n        // check if player died\n        if (stats.hp - calculatedMonsterDamage <= 0) {\n            // play death sound\n            dispatch({\n                type: 'PLAYER_DIED',\n                payload: { entity: type },\n            });\n            // if it did, game over\n            dispatch({\n                type: 'PAUSE',\n                payload: {\n                    gameOver: true,\n                    pause: true,\n                },\n            });\n        }\n    };\n}\n"],"mappings":"AAAA,SAASA,eAAe,QAAQ,qBAAqB;AACrD,SAASC,WAAW,QAAQ,2BAA2B;AAEvD,eAAe,SAASC,YAAYA,CAACC,OAAO,EAAE;EAC1C,OAAO,CAACC,QAAQ,EAAEC,QAAQ,KAAK;IAC3B,MAAM;MAAEC,KAAK;MAAEC;IAAO,CAAC,GAAGF,QAAQ,CAAC,CAAC;IACpC,MAAM;MAAEG,WAAW;MAAEC,IAAI;MAAEC,IAAI;MAAEC,UAAU;MAAEC;IAAS,CAAC,GAAGT,OAAO;IAEjE,MAAMU,MAAM,GAAGb,eAAe,CAACQ,WAAW,CAAC;IAE3C,MAAMM,uBAAuB,GACzBD,MAAM,IAAIE,IAAI,CAACC,GAAG,CAACV,KAAK,CAACW,OAAO,EAAE,CAAC,CAAC,GAAGjB,eAAe,CAACS,IAAI,CAAC,GAAG,CAAC;IAEpE,IAAIE,UAAU,IAAI,CAACA,UAAU,CAACO,MAAM,CAACC,QAAQ,CAAC,MAAM,CAAC,EAAE;MACnD,IAAIC,SAAS,GAAG,EAAE;MAClB,MAAMC,cAAc,GAAG,CACnBT,QAAQ,CAAC,CAAC,CAAC,GAAGL,MAAM,CAACK,QAAQ,CAAC,CAAC,CAAC,EAChCA,QAAQ,CAAC,CAAC,CAAC,GAAGL,MAAM,CAACK,QAAQ,CAAC,CAAC,CAAC,CACnC;MAED,IAAIL,MAAM,CAACK,QAAQ,CAAC,CAAC,CAAC,KAAKA,QAAQ,CAAC,CAAC,CAAC,EAAE;QACpC,IAAIL,MAAM,CAACK,QAAQ,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC,EAAE;UAClCQ,SAAS,GAAG,MAAM;UAClBC,cAAc,CAAC,CAAC,CAAC,IAAIpB,WAAW;QACpC,CAAC,MAAM;UACHmB,SAAS,GAAG,MAAM;UAClBC,cAAc,CAAC,CAAC,CAAC,IAAIpB,WAAW;QACpC;MACJ,CAAC,MAAM,IAAIM,MAAM,CAACK,QAAQ,CAAC,CAAC,CAAC,KAAKA,QAAQ,CAAC,CAAC,CAAC,EAAE;QAC3C,IAAIL,MAAM,CAACK,QAAQ,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC,EAAE;UAClCQ,SAAS,GAAG,OAAO;UACnBC,cAAc,CAAC,CAAC,CAAC,IAAIpB,WAAW;QACpC,CAAC,MAAM;UACHmB,SAAS,GAAG,OAAO;UACnBC,cAAc,CAAC,CAAC,CAAC,IAAIpB,WAAW;QACpC;MACJ;MACAG,QAAQ,CAAC;QACLM,IAAI,EAAE,wBAAwB;QAC9BY,OAAO,EAAE;UACLV,QAAQ,EAAES,cAAc;UACxBV,UAAU;UACVS,SAAS;UACTG,MAAM,EAAEb;QACZ;MACJ,CAAC,CAAC;IACN;IAEAN,QAAQ,CAAC;MACLM,IAAI,EAAE,uBAAuB;MAC7BY,OAAO,EAAE;QACLd,WAAW,EAAEK,MAAM;QACnBW,KAAK,EAAET,IAAI,CAACC,GAAG,CAACV,KAAK,CAACW,OAAO,EAAE,CAAC,CAAC;QACjCQ,OAAO,EAAE,SAAS;QAClBF,MAAM,EAAEb,IAAI;QACZgB,QAAQ,EAAE;MACd;IACJ,CAAC,CAAC;IAEF,IAAIZ,uBAAuB,GAAG,CAAC,EAAE;MAC7B;MACAV,QAAQ,CAAC;QACLM,IAAI,EAAE,gBAAgB;QACtBY,OAAO,EAAE;MACb,CAAC,CAAC;IACN;IAEAlB,QAAQ,CAAC;MACLM,IAAI,EAAE,kBAAkB;MACxBY,OAAO,EAAE;QAAEK,MAAM,EAAEb,uBAAuB;QAAES,MAAM,EAAEb;MAAK;IAC7D,CAAC,CAAC;;IAEF;IACA,IAAIJ,KAAK,CAACsB,EAAE,GAAGd,uBAAuB,IAAI,CAAC,EAAE;MACzC;MACAV,QAAQ,CAAC;QACLM,IAAI,EAAE,aAAa;QACnBY,OAAO,EAAE;UAAEC,MAAM,EAAEb;QAAK;MAC5B,CAAC,CAAC;MACF;MACAN,QAAQ,CAAC;QACLM,IAAI,EAAE,OAAO;QACbY,OAAO,EAAE;UACLO,QAAQ,EAAE,IAAI;UACdC,KAAK,EAAE;QACX;MACJ,CAAC,CAAC;IACN;EACJ,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}