{"ast":null,"code":"import { observeImpassable, checkForOtherMonster } from './move-monster';\nimport { SPRITE_SIZE } from '../../../config/constants';\n\n/**\n * Move the monster in a frightened manner.\n *\n * In future it would be good to have the monster run away from the player instead of randomly moving\n *\n * @param {*} sightBox The players FOV\n * @param {*} currentMap The map the player is in\n * @param {*} monster The monster we're moving\n */\nfunction moveFrightened(sightBox, currentMap, monster) {\n  return (dispatch, getState) => {\n    const playerPosition = getState().player.position;\n    const {\n      id,\n      position\n    } = monster;\n    const possibleDirections = [];\n    const up = [position[0], position[1] - SPRITE_SIZE];\n    if (playerPosition[1] !== position[1] - SPRITE_SIZE && dispatch(observeImpassable(up)) && !dispatch(checkForOtherMonster(id, up, currentMap))) {\n      possibleDirections.push([position[0], position[1] - SPRITE_SIZE]);\n    }\n    const down = [position[0], position[1] + SPRITE_SIZE];\n    if (playerPosition[1] !== position[1] + SPRITE_SIZE && dispatch(observeImpassable(down)) && !dispatch(checkForOtherMonster(id, down, currentMap))) {\n      possibleDirections.push([position[0], position[1] + SPRITE_SIZE]);\n    }\n    const left = [position[0] - SPRITE_SIZE, position[1]];\n    if (playerPosition[0] !== position[0] - SPRITE_SIZE && dispatch(observeImpassable(left)) && !dispatch(checkForOtherMonster(id, left, currentMap))) {\n      possibleDirections.push([position[0] - SPRITE_SIZE, position[1]]);\n    }\n    const right = [position[0] + SPRITE_SIZE, position[1]];\n    if (playerPosition[0] !== position[0] + SPRITE_SIZE && dispatch(observeImpassable(right)) && !dispatch(checkForOtherMonster(id, right, currentMap))) {\n      possibleDirections.push([position[0] + SPRITE_SIZE, position[1]]);\n    }\n    if (possibleDirections.length > 0) {\n      // Choose a random position to move to\n      const newPosition = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];\n      const newMonsterPos = newPosition.map(value => value / SPRITE_SIZE);\n      let inSight = false;\n      // look through each current sight box tile\n      sightBox.forEach(tile => {\n        // if the monster is in sight\n        if (JSON.stringify(tile) === JSON.stringify(newMonsterPos)) {\n          inSight = true;\n        }\n      });\n\n      // if the monster is now in sight\n      if (inSight) {\n        dispatch({\n          type: 'REVEAL_MONSTER',\n          payload: {\n            id,\n            map: currentMap\n          }\n        });\n      } else {\n        // if the monster is now out of sight\n        dispatch({\n          type: 'HIDE_MONSTER',\n          payload: {\n            id,\n            map: currentMap\n          }\n        });\n      }\n      // move the monster\n      dispatch({\n        type: 'MOVE_MONSTER',\n        payload: {\n          map: currentMap,\n          id,\n          position: newPosition,\n          direction: newPosition[0] < position[0] ? 'WEST' : newPosition[0] > position[0] ? 'EAST' : monster.direction\n        }\n      });\n    }\n  };\n}\nexport default function frightened(sightBox, currentMap, monster) {\n  return dispatch => {\n    const {\n      id,\n      position\n    } = monster;\n    const monsterPosition = position.map(pos => pos / SPRITE_SIZE);\n    let monsterVisible = false;\n    // look through each current sight box tile\n    sightBox.forEach(tile => {\n      // if the monster is in sight\n      if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n        monsterVisible = true;\n      }\n    });\n    if (monsterVisible) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n    }\n    dispatch(moveFrightened(sightBox, currentMap, monster));\n    if (monster.aiTurns === 0) {\n      dispatch({\n        type: 'CHANGE_AI',\n        payload: {\n          map: currentMap,\n          ai: 'normal',\n          id,\n          from: 'frightened',\n          turns: 0,\n          entity: monster.type,\n          original: monster.originalAI\n        }\n      });\n    }\n  };\n}","map":{"version":3,"names":["observeImpassable","checkForOtherMonster","SPRITE_SIZE","moveFrightened","sightBox","currentMap","monster","dispatch","getState","playerPosition","player","position","id","possibleDirections","up","push","down","left","right","length","newPosition","Math","floor","random","newMonsterPos","map","value","inSight","forEach","tile","JSON","stringify","type","payload","direction","frightened","monsterPosition","pos","monsterVisible","aiTurns","ai","from","turns","entity","original","originalAI"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/monsters/actions/frightened-ai.jsx"],"sourcesContent":["import { observeImpassable, checkForOtherMonster } from './move-monster';\nimport { SPRITE_SIZE } from '../../../config/constants';\n\n/**\n * Move the monster in a frightened manner.\n *\n * In future it would be good to have the monster run away from the player instead of randomly moving\n *\n * @param {*} sightBox The players FOV\n * @param {*} currentMap The map the player is in\n * @param {*} monster The monster we're moving\n */\nfunction moveFrightened(sightBox, currentMap, monster) {\n  return (dispatch, getState) => {\n    const playerPosition = getState().player.position;\n    const { id, position } = monster;\n\n    const possibleDirections = [];\n\n    const up = [position[0], position[1] - SPRITE_SIZE];\n    if (\n      playerPosition[1] !== position[1] - SPRITE_SIZE &&\n      dispatch(observeImpassable(up)) &&\n      !dispatch(checkForOtherMonster(id, up, currentMap))\n    ) {\n      possibleDirections.push([position[0], position[1] - SPRITE_SIZE]);\n    }\n\n    const down = [position[0], position[1] + SPRITE_SIZE];\n    if (\n      playerPosition[1] !== position[1] + SPRITE_SIZE &&\n      dispatch(observeImpassable(down)) &&\n      !dispatch(checkForOtherMonster(id, down, currentMap))\n    ) {\n      possibleDirections.push([position[0], position[1] + SPRITE_SIZE]);\n    }\n\n    const left = [position[0] - SPRITE_SIZE, position[1]];\n    if (\n      playerPosition[0] !== position[0] - SPRITE_SIZE &&\n      dispatch(observeImpassable(left)) &&\n      !dispatch(checkForOtherMonster(id, left, currentMap))\n    ) {\n      possibleDirections.push([position[0] - SPRITE_SIZE, position[1]]);\n    }\n\n    const right = [position[0] + SPRITE_SIZE, position[1]];\n    if (\n      playerPosition[0] !== position[0] + SPRITE_SIZE &&\n      dispatch(observeImpassable(right)) &&\n      !dispatch(checkForOtherMonster(id, right, currentMap))\n    ) {\n      possibleDirections.push([position[0] + SPRITE_SIZE, position[1]]);\n    }\n\n    if (possibleDirections.length > 0) {\n      // Choose a random position to move to\n      const newPosition = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];\n      const newMonsterPos = newPosition.map((value) => value / SPRITE_SIZE);\n\n      let inSight = false;\n      // look through each current sight box tile\n      sightBox.forEach((tile) => {\n        // if the monster is in sight\n        if (JSON.stringify(tile) === JSON.stringify(newMonsterPos)) {\n          inSight = true;\n        }\n      });\n\n      // if the monster is now in sight\n      if (inSight) {\n        dispatch({\n          type: 'REVEAL_MONSTER',\n          payload: { id, map: currentMap },\n        });\n      } else {\n        // if the monster is now out of sight\n        dispatch({\n          type: 'HIDE_MONSTER',\n          payload: { id, map: currentMap },\n        });\n      }\n      // move the monster\n      dispatch({\n        type: 'MOVE_MONSTER',\n        payload: {\n          map: currentMap,\n          id,\n          position: newPosition,\n          direction:\n            newPosition[0] < position[0]\n              ? 'WEST'\n              : newPosition[0] > position[0]\n              ? 'EAST'\n              : monster.direction,\n        },\n      });\n    }\n  };\n}\n\nexport default function frightened(sightBox, currentMap, monster) {\n  return (dispatch) => {\n    const { id, position } = monster;\n\n    const monsterPosition = position.map((pos) => pos / SPRITE_SIZE);\n\n    let monsterVisible = false;\n    // look through each current sight box tile\n    sightBox.forEach((tile) => {\n      // if the monster is in sight\n      if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n        monsterVisible = true;\n      }\n    });\n\n    if (monsterVisible) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: { id, map: currentMap },\n      });\n    }\n\n    dispatch(moveFrightened(sightBox, currentMap, monster));\n\n    if (monster.aiTurns === 0) {\n      dispatch({\n        type: 'CHANGE_AI',\n        payload: {\n          map: currentMap,\n          ai: 'normal',\n          id,\n          from: 'frightened',\n          turns: 0,\n          entity: monster.type,\n          original: monster.originalAI,\n        },\n      });\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}