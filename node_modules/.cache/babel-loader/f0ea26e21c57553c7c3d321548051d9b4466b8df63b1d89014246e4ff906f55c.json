{"ast":null,"code":"import { calculateDamage } from '../../../utils/dice';\nimport { SPRITE_SIZE } from '../../../config/constants';\nexport default function attackMonster(attackingMonster, defendingMonsterID, currentMap) {\n  return (dispatch, getState) => {\n    const defender = getState().monsters.components[currentMap][defendingMonsterID];\n    const {\n      dice,\n      attackValue\n    } = attackingMonster;\n    const {\n      defence,\n      type,\n      hp,\n      position\n    } = defender;\n    const attack = calculateDamage(attackValue);\n    const calculatedMonsterDamage = attack >= Math.max(defence, 0) ? calculateDamage(dice) : 0;\n    dispatch({\n      type: 'MONSTER_ABILITY_CHECK',\n      payload: {\n        attackValue: attack,\n        check: Math.max(defence, 0),\n        against: 'defence',\n        entity: attackingMonster.type,\n        defender: type\n      }\n    });\n    if (calculatedMonsterDamage > 0) {\n      // show the attack animation and play sound\n      dispatch({\n        type: 'MONSTER_ATTACK',\n        payload: null\n      });\n    }\n    dispatch({\n      type: 'DAMAGE_TO_MONSTER',\n      payload: {\n        damage: calculatedMonsterDamage,\n        id: defendingMonsterID,\n        map: currentMap,\n        from: attackingMonster.type,\n        entity: type\n      }\n    });\n\n    // check if player died\n    if (hp - calculatedMonsterDamage <= 0) {\n      dispatch({\n        type: 'MONSTER_DIED',\n        payload: type\n      });\n\n      // replace monster will blood spill\n      // need to pass relative tile index\n      dispatch({\n        type: 'ADD_BLOOD_SPILL',\n        payload: {\n          x: position[0] / SPRITE_SIZE,\n          y: position[1] / SPRITE_SIZE\n        }\n      });\n    }\n  };\n}","map":{"version":3,"names":["calculateDamage","SPRITE_SIZE","attackMonster","attackingMonster","defendingMonsterID","currentMap","dispatch","getState","defender","monsters","components","dice","attackValue","defence","type","hp","position","attack","calculatedMonsterDamage","Math","max","payload","check","against","entity","damage","id","map","from","x","y"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/monsters/actions/attack-monster.jsx"],"sourcesContent":["import { calculateDamage } from '../../../utils/dice';\nimport { SPRITE_SIZE } from '../../../config/constants';\n\nexport default function attackMonster(\n    attackingMonster,\n    defendingMonsterID,\n    currentMap\n) {\n    return (dispatch, getState) => {\n        const defender = getState().monsters.components[currentMap][\n            defendingMonsterID\n        ];\n\n        const { dice, attackValue } = attackingMonster;\n        const { defence, type, hp, position } = defender;\n\n        const attack = calculateDamage(attackValue);\n        const calculatedMonsterDamage =\n            attack >= Math.max(defence, 0) ? calculateDamage(dice) : 0;\n\n        dispatch({\n            type: 'MONSTER_ABILITY_CHECK',\n            payload: {\n                attackValue: attack,\n                check: Math.max(defence, 0),\n                against: 'defence',\n                entity: attackingMonster.type,\n                defender: type,\n            },\n        });\n\n        if (calculatedMonsterDamage > 0) {\n            // show the attack animation and play sound\n            dispatch({\n                type: 'MONSTER_ATTACK',\n                payload: null,\n            });\n        }\n\n        dispatch({\n            type: 'DAMAGE_TO_MONSTER',\n            payload: {\n                damage: calculatedMonsterDamage,\n                id: defendingMonsterID,\n                map: currentMap,\n                from: attackingMonster.type,\n                entity: type,\n            },\n        });\n\n        // check if player died\n        if (hp - calculatedMonsterDamage <= 0) {\n            dispatch({\n                type: 'MONSTER_DIED',\n                payload: type,\n            });\n\n            // replace monster will blood spill\n            // need to pass relative tile index\n            dispatch({\n                type: 'ADD_BLOOD_SPILL',\n                payload: {\n                    x: position[0] / SPRITE_SIZE,\n                    y: position[1] / SPRITE_SIZE,\n                },\n            });\n        }\n    };\n}\n"],"mappings":"AAAA,SAASA,eAAe,QAAQ,qBAAqB;AACrD,SAASC,WAAW,QAAQ,2BAA2B;AAEvD,eAAe,SAASC,aAAaA,CACjCC,gBAAgB,EAChBC,kBAAkB,EAClBC,UAAU,EACZ;EACE,OAAO,CAACC,QAAQ,EAAEC,QAAQ,KAAK;IAC3B,MAAMC,QAAQ,GAAGD,QAAQ,CAAC,CAAC,CAACE,QAAQ,CAACC,UAAU,CAACL,UAAU,CAAC,CACvDD,kBAAkB,CACrB;IAED,MAAM;MAAEO,IAAI;MAAEC;IAAY,CAAC,GAAGT,gBAAgB;IAC9C,MAAM;MAAEU,OAAO;MAAEC,IAAI;MAAEC,EAAE;MAAEC;IAAS,CAAC,GAAGR,QAAQ;IAEhD,MAAMS,MAAM,GAAGjB,eAAe,CAACY,WAAW,CAAC;IAC3C,MAAMM,uBAAuB,GACzBD,MAAM,IAAIE,IAAI,CAACC,GAAG,CAACP,OAAO,EAAE,CAAC,CAAC,GAAGb,eAAe,CAACW,IAAI,CAAC,GAAG,CAAC;IAE9DL,QAAQ,CAAC;MACLQ,IAAI,EAAE,uBAAuB;MAC7BO,OAAO,EAAE;QACLT,WAAW,EAAEK,MAAM;QACnBK,KAAK,EAAEH,IAAI,CAACC,GAAG,CAACP,OAAO,EAAE,CAAC,CAAC;QAC3BU,OAAO,EAAE,SAAS;QAClBC,MAAM,EAAErB,gBAAgB,CAACW,IAAI;QAC7BN,QAAQ,EAAEM;MACd;IACJ,CAAC,CAAC;IAEF,IAAII,uBAAuB,GAAG,CAAC,EAAE;MAC7B;MACAZ,QAAQ,CAAC;QACLQ,IAAI,EAAE,gBAAgB;QACtBO,OAAO,EAAE;MACb,CAAC,CAAC;IACN;IAEAf,QAAQ,CAAC;MACLQ,IAAI,EAAE,mBAAmB;MACzBO,OAAO,EAAE;QACLI,MAAM,EAAEP,uBAAuB;QAC/BQ,EAAE,EAAEtB,kBAAkB;QACtBuB,GAAG,EAAEtB,UAAU;QACfuB,IAAI,EAAEzB,gBAAgB,CAACW,IAAI;QAC3BU,MAAM,EAAEV;MACZ;IACJ,CAAC,CAAC;;IAEF;IACA,IAAIC,EAAE,GAAGG,uBAAuB,IAAI,CAAC,EAAE;MACnCZ,QAAQ,CAAC;QACLQ,IAAI,EAAE,cAAc;QACpBO,OAAO,EAAEP;MACb,CAAC,CAAC;;MAEF;MACA;MACAR,QAAQ,CAAC;QACLQ,IAAI,EAAE,iBAAiB;QACvBO,OAAO,EAAE;UACLQ,CAAC,EAAEb,QAAQ,CAAC,CAAC,CAAC,GAAGf,WAAW;UAC5B6B,CAAC,EAAEd,QAAQ,CAAC,CAAC,CAAC,GAAGf;QACrB;MACJ,CAAC,CAAC;IACN;EACJ,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}