{"ast":null,"code":"import { checkForMonster, getNewPosition, observeBoundaries, applyEffects } from './move-player';\nimport { calculateDamage, d20 } from '../../../utils/dice';\nimport calculateModifier from '../../../utils/calculate-modifier';\nimport getNextTile from '../../../utils/get-next-tile';\nimport { SPRITE_SIZE, FISTS } from '../../../config/constants';\nexport const findTarget = (position, direction, range) => {\n  return (dispatch, getState) => {\n    let targetPosition = null;\n    switch (direction) {\n      case 'NORTH':\n        for (let y = position[1]; y > position[1] - range; y -= SPRITE_SIZE) {\n          const pos = getNewPosition([position[0], y], direction);\n          targetPosition = pos;\n          if (!observeImpassable(pos, getState().world) || dispatch(checkForMonster(pos))) {\n            break;\n          }\n        }\n        break;\n      case 'SOUTH':\n        for (let y = position[1]; y < position[1] + range; y += SPRITE_SIZE) {\n          const pos = getNewPosition([position[0], y], direction);\n          targetPosition = pos;\n          if (!observeImpassable(pos, getState().world) || dispatch(checkForMonster(pos))) {\n            break;\n          }\n        }\n        break;\n      case 'EAST':\n        for (let x = position[0]; x < position[0] + range; x += SPRITE_SIZE) {\n          const pos = getNewPosition([x, position[1]], direction);\n          targetPosition = pos;\n          if (!observeImpassable(pos, getState().world) || dispatch(checkForMonster(pos))) {\n            break;\n          }\n        }\n        break;\n      case 'WEST':\n        for (let x = position[0]; x > position[0] - range; x -= SPRITE_SIZE) {\n          const pos = getNewPosition([x, position[1]], direction);\n          targetPosition = pos;\n          if (!observeImpassable(pos, getState().world) || dispatch(checkForMonster(pos))) {\n            break;\n          }\n        }\n        break;\n      default:\n    }\n    return targetPosition;\n  };\n};\nexport default function attackMonster() {\n  return (dispatch, getState) => {\n    // get player direction and the location of position to attack\n    const {\n      position,\n      direction\n    } = getState().player;\n    let newPos = getNewPosition(position, direction);\n\n    // if the attacked tile is in bounds\n    if (observeBoundaries(newPos) && observeImpassable(newPos, getState().world)) {\n      const {\n        stats,\n        world,\n        monsters\n      } = getState();\n      const {\n        currentMap\n      } = world;\n      const {\n        components\n      } = monsters;\n      const weapon = stats.equippedItems.weapon || FISTS;\n      const targetPosition = dispatch(findTarget(position, direction, weapon.range * SPRITE_SIZE));\n      const monsterId = dispatch(checkForMonster(targetPosition));\n      if (monsterId) {\n        // If we're targetting a monster\n        const currMonster = components[currentMap][monsterId];\n        const monsterPos = currMonster.position;\n        const ability = weapon.kind === 'melee' ? 'strength' : weapon.kind === 'ranged' ? 'dexterity' : 'intelligence';\n        const modifier = calculateModifier(stats.abilities[ability]);\n        const roll = d20();\n        const attackValue = roll + modifier;\n        if (weapon.projectile) {\n          dispatch({\n            type: 'USE_PROJECTILE',\n            payload: {\n              position: targetPosition,\n              projectile: weapon.projectile\n            }\n          });\n        }\n        if (roll === 20) {\n          dispatch({\n            type: 'CRITICAL_HIT',\n            payload: {\n              notation: 'd20 + ' + modifier,\n              roll: roll,\n              ability\n            }\n          });\n        } else {\n          dispatch({\n            type: 'ABILITY_CHECK',\n            payload: {\n              notation: 'd20 + ' + modifier,\n              roll: attackValue,\n              ability,\n              check: currMonster.defence,\n              entity: currMonster.type,\n              against: 'defence'\n            }\n          });\n        }\n        const damage = roll === 20 ? calculateDamage(weapon.damage, true) : attackValue >= currMonster.defence ? calculateDamage(weapon.damage, false) : 0;\n        if (damage > 0) {\n          // Only show the attack animation if they hit the monster\n          dispatch({\n            type: 'PLAYER_ATTACK',\n            payload: null\n          });\n        }\n\n        // deal damage to monster\n        dispatch({\n          type: 'DAMAGE_TO_MONSTER',\n          payload: {\n            damage,\n            id: currMonster.id,\n            map: currentMap,\n            entity: currMonster.type,\n            from: 'player'\n          }\n        });\n\n        // check if monster died\n        if (currMonster.hp - damage <= 0) {\n          // and get some exp\n          dispatch({\n            type: 'GET_EXP',\n            payload: currMonster.exp\n          });\n          if (stats.exp + currMonster.exp >= stats.expToLevel) {\n            dispatch({\n              type: 'PAUSE',\n              payload: {\n                pause: true,\n                levelUp: true\n              }\n            });\n          }\n          // play death sound\n          dispatch({\n            type: 'MONSTER_DIED',\n            payload: currMonster.type\n          });\n          // replace monster will blood spill\n          // need to pass relative tile index\n          dispatch({\n            type: 'ADD_BLOOD_SPILL',\n            payload: {\n              x: monsterPos[0] / SPRITE_SIZE,\n              y: monsterPos[1] / SPRITE_SIZE\n            }\n          });\n        }\n\n        // take a turn if the player attacked something\n        dispatch({\n          type: 'TAKE_TURN',\n          payload: null\n        });\n        dispatch(applyEffects());\n      } else {\n        // Hit a wall or something else\n        if (weapon.kind === 'ranged') {\n          dispatch({\n            type: 'USE_PROJECTILE',\n            payload: {\n              position: targetPosition,\n              projectile: weapon.projectile\n            }\n          });\n        }\n        dispatch({\n          type: 'PLAYER_ATTACK',\n          payload: null\n        });\n      }\n    }\n  };\n}\nexport function observeImpassable(newPos, world) {\n  const nextTile = getNextTile(world, newPos);\n  return nextTile < 5;\n}","map":{"version":3,"names":["checkForMonster","getNewPosition","observeBoundaries","applyEffects","calculateDamage","d20","calculateModifier","getNextTile","SPRITE_SIZE","FISTS","findTarget","position","direction","range","dispatch","getState","targetPosition","y","pos","observeImpassable","world","x","attackMonster","player","newPos","stats","monsters","currentMap","components","weapon","equippedItems","monsterId","currMonster","monsterPos","ability","kind","modifier","abilities","roll","attackValue","projectile","type","payload","notation","check","defence","entity","against","damage","id","map","from","hp","exp","expToLevel","pause","levelUp","nextTile"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/player/actions/attack-monster.jsx"],"sourcesContent":["import { checkForMonster, getNewPosition, observeBoundaries, applyEffects } from './move-player';\nimport { calculateDamage, d20 } from '../../../utils/dice';\nimport calculateModifier from '../../../utils/calculate-modifier';\nimport getNextTile from '../../../utils/get-next-tile';\nimport { SPRITE_SIZE, FISTS } from '../../../config/constants';\n\nexport const findTarget = (position, direction, range) => {\n  return (dispatch, getState) => {\n    let targetPosition = null;\n    switch (direction) {\n      case 'NORTH':\n        for (let y = position[1]; y > position[1] - range; y -= SPRITE_SIZE) {\n          const pos = getNewPosition([position[0], y], direction);\n          targetPosition = pos;\n          if (!observeImpassable(pos, getState().world) || dispatch(checkForMonster(pos))) {\n            break;\n          }\n        }\n        break;\n      case 'SOUTH':\n        for (let y = position[1]; y < position[1] + range; y += SPRITE_SIZE) {\n          const pos = getNewPosition([position[0], y], direction);\n          targetPosition = pos;\n          if (!observeImpassable(pos, getState().world) || dispatch(checkForMonster(pos))) {\n            break;\n          }\n        }\n        break;\n      case 'EAST':\n        for (let x = position[0]; x < position[0] + range; x += SPRITE_SIZE) {\n          const pos = getNewPosition([x, position[1]], direction);\n          targetPosition = pos;\n          if (!observeImpassable(pos, getState().world) || dispatch(checkForMonster(pos))) {\n            break;\n          }\n        }\n        break;\n      case 'WEST':\n        for (let x = position[0]; x > position[0] - range; x -= SPRITE_SIZE) {\n          const pos = getNewPosition([x, position[1]], direction);\n          targetPosition = pos;\n          if (!observeImpassable(pos, getState().world) || dispatch(checkForMonster(pos))) {\n            break;\n          }\n        }\n        break;\n      default:\n    }\n\n    return targetPosition;\n  };\n};\n\nexport default function attackMonster() {\n  return (dispatch, getState) => {\n    // get player direction and the location of position to attack\n    const { position, direction } = getState().player;\n    let newPos = getNewPosition(position, direction);\n\n    // if the attacked tile is in bounds\n    if (observeBoundaries(newPos) && observeImpassable(newPos, getState().world)) {\n      const { stats, world, monsters } = getState();\n      const { currentMap } = world;\n      const { components } = monsters;\n\n      const weapon = stats.equippedItems.weapon || FISTS;\n\n      const targetPosition = dispatch(findTarget(position, direction, weapon.range * SPRITE_SIZE));\n\n      const monsterId = dispatch(checkForMonster(targetPosition));\n      if (monsterId) {\n        // If we're targetting a monster\n        const currMonster = components[currentMap][monsterId];\n        const monsterPos = currMonster.position;\n\n        const ability =\n          weapon.kind === 'melee'\n            ? 'strength'\n            : weapon.kind === 'ranged'\n            ? 'dexterity'\n            : 'intelligence';\n\n        const modifier = calculateModifier(stats.abilities[ability]);\n        const roll = d20();\n        const attackValue = roll + modifier;\n\n        if (weapon.projectile) {\n          dispatch({\n            type: 'USE_PROJECTILE',\n            payload: {\n              position: targetPosition,\n              projectile: weapon.projectile,\n            },\n          });\n        }\n\n        if (roll === 20) {\n          dispatch({\n            type: 'CRITICAL_HIT',\n            payload: {\n              notation: 'd20 + ' + modifier,\n              roll: roll,\n              ability,\n            },\n          });\n        } else {\n          dispatch({\n            type: 'ABILITY_CHECK',\n            payload: {\n              notation: 'd20 + ' + modifier,\n              roll: attackValue,\n              ability,\n              check: currMonster.defence,\n              entity: currMonster.type,\n              against: 'defence',\n            },\n          });\n        }\n\n        const damage =\n          roll === 20\n            ? calculateDamage(weapon.damage, true)\n            : attackValue >= currMonster.defence\n            ? calculateDamage(weapon.damage, false)\n            : 0;\n\n        if (damage > 0) {\n          // Only show the attack animation if they hit the monster\n          dispatch({\n            type: 'PLAYER_ATTACK',\n            payload: null,\n          });\n        }\n\n        // deal damage to monster\n        dispatch({\n          type: 'DAMAGE_TO_MONSTER',\n          payload: {\n            damage,\n            id: currMonster.id,\n            map: currentMap,\n            entity: currMonster.type,\n            from: 'player',\n          },\n        });\n\n        // check if monster died\n        if (currMonster.hp - damage <= 0) {\n          // and get some exp\n          dispatch({\n            type: 'GET_EXP',\n            payload: currMonster.exp,\n          });\n          if (stats.exp + currMonster.exp >= stats.expToLevel) {\n            dispatch({\n              type: 'PAUSE',\n              payload: {\n                pause: true,\n                levelUp: true,\n              },\n            });\n          }\n          // play death sound\n          dispatch({\n            type: 'MONSTER_DIED',\n            payload: currMonster.type,\n          });\n          // replace monster will blood spill\n          // need to pass relative tile index\n          dispatch({\n            type: 'ADD_BLOOD_SPILL',\n            payload: {\n              x: monsterPos[0] / SPRITE_SIZE,\n              y: monsterPos[1] / SPRITE_SIZE,\n            },\n          });\n        }\n\n        // take a turn if the player attacked something\n        dispatch({\n          type: 'TAKE_TURN',\n          payload: null,\n        });\n\n        dispatch(applyEffects());\n      } else {\n        // Hit a wall or something else\n        if (weapon.kind === 'ranged') {\n          dispatch({\n            type: 'USE_PROJECTILE',\n            payload: {\n              position: targetPosition,\n              projectile: weapon.projectile,\n            },\n          });\n        }\n        dispatch({\n          type: 'PLAYER_ATTACK',\n          payload: null,\n        });\n      }\n    }\n  };\n}\n\nexport function observeImpassable(newPos, world) {\n  const nextTile = getNextTile(world, newPos);\n\n  return nextTile < 5;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}