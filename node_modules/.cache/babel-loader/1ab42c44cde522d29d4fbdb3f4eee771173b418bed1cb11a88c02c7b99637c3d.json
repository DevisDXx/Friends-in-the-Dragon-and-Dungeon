{"ast":null,"code":"import { checkForMonster, applyEffects } from './move-player';\nimport { calculateDamage, d20 } from '../../../utils/dice';\nimport calculateModifier from '../../../utils/calculate-modifier';\nimport { SPRITE_SIZE } from '../../../config/constants';\nimport errorMessage from '../../dialog-manager/actions/error-message';\nimport { findTarget } from './attack-monster';\nfunction doesProcOnBoss() {\n  // Give the bosses some chance to not have their AI changed when hit\n  return Math.random() * 100 < 20;\n}\nfunction changeBossAI(spell, currMonster, criticalHit) {\n  return dispatch => {\n    if (criticalHit || doesProcOnBoss()) dispatch(changeMonsterAI(spell, currMonster));\n  };\n}\n\n/**\n * Change a monsters AI from an effect that the spell the players casting\n * causes.\n *\n * @param {*} spell The spell the player is casting\n * @param {*} currMonster The monster that's being targetted\n */\nfunction changeMonsterAI(spell, currMonster) {\n  return (dispatch, getState) => {\n    const {\n      currentMap\n    } = getState().world;\n    const {\n      to,\n      turns,\n      proc\n    } = spell.effects.changeAI;\n\n    // If they're already under the effects of something, don't apply a new effect\n    if (currMonster.ai !== currMonster.originalAI) return;\n\n    // If we have a probabilty to hit, then use that to check if we do\n    if (!proc || proc()) {\n      dispatch({\n        type: 'CHANGE_AI',\n        payload: {\n          from: currMonster.ai,\n          ai: to,\n          turns,\n          id: currMonster.id,\n          map: currentMap,\n          entity: currMonster.type,\n          original: currMonster.originalAI\n        }\n      });\n    }\n  };\n}\nexport default function castSpell() {\n  return (dispatch, getState) => {\n    const {\n      stats,\n      player,\n      monsters,\n      world\n    } = getState();\n    const {\n      position,\n      direction,\n      spell\n    } = player;\n    if (spell === null) {\n      dispatch(errorMessage('Select a spell first (\"b\")'));\n      return;\n    } else if (spell.manaCost > stats.mana) {\n      dispatch(errorMessage('Not enough mana'));\n      return;\n    }\n    const target = spell.target.split('::');\n    if (target[0] === 'self') {\n      dispatch({\n        type: 'CAST_SPELL',\n        payload: {\n          position: position,\n          projectile: spell\n        }\n      });\n      const intelligenceModifier = calculateModifier(stats.abilities.intelligence);\n      const healAmount = calculateDamage(spell.damage) + (intelligenceModifier > 0 ? intelligenceModifier : 0);\n      if (target[1] === 'heal') {\n        dispatch({\n          type: 'HEAL_HP',\n          payload: healAmount\n        });\n      }\n      dispatch({\n        type: 'TAKE_TURN',\n        payload: null\n      });\n      dispatch(applyEffects());\n    } else if (target[0] === 'enemy') {\n      const spellPosition = dispatch(findTarget(position, direction, spell.range * SPRITE_SIZE));\n      const {\n        currentMap\n      } = world;\n      const {\n        components\n      } = monsters;\n      const monsterId = dispatch(checkForMonster(spellPosition));\n      if (monsterId) {\n        // If we're targetting a monster\n        const currMonster = components[currentMap][monsterId];\n        const monsterPos = currMonster.position;\n        const modifier = calculateModifier(stats.abilities.intelligence);\n        const roll = d20();\n        const criticalHit = roll === 20;\n        const attackValue = roll + modifier;\n        dispatch({\n          type: 'CAST_SPELL',\n          payload: {\n            position: spellPosition,\n            projectile: spell\n          }\n        });\n        if (criticalHit) {\n          dispatch({\n            type: 'CRITICAL_HIT',\n            payload: {\n              notation: 'd20 + ' + modifier,\n              roll: roll,\n              ability: 'intelligence'\n            }\n          });\n        } else {\n          dispatch({\n            type: 'ABILITY_CHECK',\n            payload: {\n              notation: 'd20 + ' + modifier,\n              roll: attackValue,\n              ability: 'intelligence',\n              check: currMonster.defence,\n              entity: currMonster.type,\n              against: 'defence'\n            }\n          });\n        }\n        const damage = criticalHit ? calculateDamage(spell.damage, true) : attackValue >= currMonster.defence ? calculateDamage(spell.damage, false) : 0;\n\n        // deal damage to monster\n        dispatch({\n          type: 'DAMAGE_TO_MONSTER',\n          payload: {\n            damage,\n            id: currMonster.id,\n            map: currentMap,\n            entity: currMonster.type,\n            from: 'player'\n          }\n        });\n\n        // check if monster died\n        if (currMonster.hp - damage <= 0) {\n          // and get some exp\n          dispatch({\n            type: 'GET_EXP',\n            payload: currMonster.exp\n          });\n          if (stats.exp + currMonster.exp >= stats.expToLevel) {\n            dispatch({\n              type: 'PAUSE',\n              payload: {\n                pause: true,\n                levelUp: true\n              }\n            });\n          }\n          // play death sound\n          dispatch({\n            type: 'MONSTER_DIED',\n            payload: currMonster.type\n          });\n          // replace monster will blood spill\n          // need to pass relative tile index\n          dispatch({\n            type: 'ADD_BLOOD_SPILL',\n            payload: {\n              x: monsterPos[0] / SPRITE_SIZE,\n              y: monsterPos[1] / SPRITE_SIZE\n            }\n          });\n        } else if (damage > 0 && spell.effects && spell.effects.changeAI) {\n          if (currMonster.originalAI === 'boss') {\n            dispatch(changeBossAI(spell, currMonster, criticalHit));\n          } else {\n            dispatch(changeMonsterAI(spell, currMonster));\n          }\n        }\n\n        // take a turn if the player attacked something\n        dispatch({\n          type: 'TAKE_TURN',\n          payload: null\n        });\n        dispatch(applyEffects());\n      } else {\n        // Hit a wall or something else\n        dispatch({\n          type: 'CAST_SPELL',\n          payload: {\n            position: spellPosition,\n            projectile: spell\n          }\n        });\n      }\n    }\n  };\n}","map":{"version":3,"names":["checkForMonster","applyEffects","calculateDamage","d20","calculateModifier","SPRITE_SIZE","errorMessage","findTarget","doesProcOnBoss","Math","random","changeBossAI","spell","currMonster","criticalHit","dispatch","changeMonsterAI","getState","currentMap","world","to","turns","proc","effects","changeAI","ai","originalAI","type","payload","from","id","map","entity","original","castSpell","stats","player","monsters","position","direction","manaCost","mana","target","split","projectile","intelligenceModifier","abilities","intelligence","healAmount","damage","spellPosition","range","components","monsterId","monsterPos","modifier","roll","attackValue","notation","ability","check","defence","against","hp","exp","expToLevel","pause","levelUp","x","y"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/player/actions/cast-spell.jsx"],"sourcesContent":["import { checkForMonster, applyEffects } from './move-player';\nimport { calculateDamage, d20 } from '../../../utils/dice';\nimport calculateModifier from '../../../utils/calculate-modifier';\nimport { SPRITE_SIZE } from '../../../config/constants';\nimport errorMessage from '../../dialog-manager/actions/error-message';\nimport { findTarget } from './attack-monster';\n\nfunction doesProcOnBoss() {\n  // Give the bosses some chance to not have their AI changed when hit\n  return Math.random() * 100 < 20;\n}\n\nfunction changeBossAI(spell, currMonster, criticalHit) {\n  return (dispatch) => {\n    if (criticalHit || doesProcOnBoss()) dispatch(changeMonsterAI(spell, currMonster));\n  };\n}\n\n/**\n * Change a monsters AI from an effect that the spell the players casting\n * causes.\n *\n * @param {*} spell The spell the player is casting\n * @param {*} currMonster The monster that's being targetted\n */\nfunction changeMonsterAI(spell, currMonster) {\n  return (dispatch, getState) => {\n    const { currentMap } = getState().world;\n    const { to, turns, proc } = spell.effects.changeAI;\n\n    // If they're already under the effects of something, don't apply a new effect\n    if (currMonster.ai !== currMonster.originalAI) return;\n\n    // If we have a probabilty to hit, then use that to check if we do\n    if (!proc || proc()) {\n      dispatch({\n        type: 'CHANGE_AI',\n        payload: {\n          from: currMonster.ai,\n          ai: to,\n          turns,\n          id: currMonster.id,\n          map: currentMap,\n          entity: currMonster.type,\n          original: currMonster.originalAI,\n        },\n      });\n    }\n  };\n}\n\nexport default function castSpell() {\n  return (dispatch, getState) => {\n    const { stats, player, monsters, world } = getState();\n    const { position, direction, spell } = player;\n\n    if (spell === null) {\n      dispatch(errorMessage('Select a spell first (\"b\")'));\n      return;\n    } else if (spell.manaCost > stats.mana) {\n      dispatch(errorMessage('Not enough mana'));\n      return;\n    }\n\n    const target = spell.target.split('::');\n\n    if (target[0] === 'self') {\n      dispatch({\n        type: 'CAST_SPELL',\n        payload: { position: position, projectile: spell },\n      });\n\n      const intelligenceModifier = calculateModifier(stats.abilities.intelligence);\n      const healAmount =\n        calculateDamage(spell.damage) + (intelligenceModifier > 0 ? intelligenceModifier : 0);\n\n      if (target[1] === 'heal') {\n        dispatch({\n          type: 'HEAL_HP',\n          payload: healAmount,\n        });\n      }\n\n      dispatch({\n        type: 'TAKE_TURN',\n        payload: null,\n      });\n      dispatch(applyEffects());\n    } else if (target[0] === 'enemy') {\n      const spellPosition = dispatch(findTarget(position, direction, spell.range * SPRITE_SIZE));\n\n      const { currentMap } = world;\n      const { components } = monsters;\n\n      const monsterId = dispatch(checkForMonster(spellPosition));\n      if (monsterId) {\n        // If we're targetting a monster\n        const currMonster = components[currentMap][monsterId];\n        const monsterPos = currMonster.position;\n\n        const modifier = calculateModifier(stats.abilities.intelligence);\n\n        const roll = d20();\n        const criticalHit = roll === 20;\n        const attackValue = roll + modifier;\n\n        dispatch({\n          type: 'CAST_SPELL',\n          payload: { position: spellPosition, projectile: spell },\n        });\n\n        if (criticalHit) {\n          dispatch({\n            type: 'CRITICAL_HIT',\n            payload: {\n              notation: 'd20 + ' + modifier,\n              roll: roll,\n              ability: 'intelligence',\n            },\n          });\n        } else {\n          dispatch({\n            type: 'ABILITY_CHECK',\n            payload: {\n              notation: 'd20 + ' + modifier,\n              roll: attackValue,\n              ability: 'intelligence',\n              check: currMonster.defence,\n              entity: currMonster.type,\n              against: 'defence',\n            },\n          });\n        }\n\n        const damage = criticalHit\n          ? calculateDamage(spell.damage, true)\n          : attackValue >= currMonster.defence\n          ? calculateDamage(spell.damage, false)\n          : 0;\n\n        // deal damage to monster\n        dispatch({\n          type: 'DAMAGE_TO_MONSTER',\n          payload: {\n            damage,\n            id: currMonster.id,\n            map: currentMap,\n            entity: currMonster.type,\n            from: 'player',\n          },\n        });\n\n        // check if monster died\n        if (currMonster.hp - damage <= 0) {\n          // and get some exp\n          dispatch({\n            type: 'GET_EXP',\n            payload: currMonster.exp,\n          });\n          if (stats.exp + currMonster.exp >= stats.expToLevel) {\n            dispatch({\n              type: 'PAUSE',\n              payload: {\n                pause: true,\n                levelUp: true,\n              },\n            });\n          }\n          // play death sound\n          dispatch({\n            type: 'MONSTER_DIED',\n            payload: currMonster.type,\n          });\n          // replace monster will blood spill\n          // need to pass relative tile index\n          dispatch({\n            type: 'ADD_BLOOD_SPILL',\n            payload: {\n              x: monsterPos[0] / SPRITE_SIZE,\n              y: monsterPos[1] / SPRITE_SIZE,\n            },\n          });\n        } else if (damage > 0 && spell.effects && spell.effects.changeAI) {\n          if (currMonster.originalAI === 'boss') {\n            dispatch(changeBossAI(spell, currMonster, criticalHit));\n          } else {\n            dispatch(changeMonsterAI(spell, currMonster));\n          }\n        }\n\n        // take a turn if the player attacked something\n        dispatch({\n          type: 'TAKE_TURN',\n          payload: null,\n        });\n\n        dispatch(applyEffects());\n      } else {\n        // Hit a wall or something else\n        dispatch({\n          type: 'CAST_SPELL',\n          payload: { position: spellPosition, projectile: spell },\n        });\n      }\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}