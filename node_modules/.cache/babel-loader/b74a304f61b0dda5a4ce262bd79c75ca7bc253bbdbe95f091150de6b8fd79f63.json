{"ast":null,"code":"/**\n * An 'unbiased' dice roll\n *\n * @param {*} sides The number of sides the dice has\n */\nconst unbiased = sides => Math.floor(Math.random() * sides) + 1;\n\n//\n/**\n * Create a 'biased' dice roll, either to the maximum or the minimum value.\n * If not specified, or it's not biased to either max or min, return an unbiased roll\n *\n * @param {*} to The bias we want to represent (max or min)\n */\nconst biased = to => {\n  if (to === 'max') {\n    return sides => sides;\n  } else if (to === 'min') {\n    return _ => 1;\n  }\n  return unbiased();\n};\nconst ops = {\n  '+': {\n    precedence: 1,\n    op: (left, right) => {\n      if (Array.isArray(left)) {\n        left = left.reduce((sum, value) => sum + value);\n      }\n      if (Array.isArray(right)) {\n        right = right.reduce((sum, value) => sum + value);\n      }\n      return parseInt(left) + parseInt(right);\n    }\n  },\n  '-': {\n    precedence: 1,\n    op: (left, right) => {\n      if (Array.isArray(left)) {\n        left = left.reduce((sum, value) => sum + value);\n      }\n      if (Array.isArray(right)) {\n        right = right.reduce((sum, value) => sum + value);\n      }\n      return parseInt(left) - parseInt(right);\n    }\n  },\n  '*': {\n    precedence: 2,\n    op: (left, right) => {\n      if (Array.isArray(left)) {\n        left = left.reduce((sum, value) => sum + value);\n      }\n      if (Array.isArray(right)) {\n        right = right.reduce((sum, value) => sum + value);\n      }\n      return parseInt(left) * parseInt(right);\n    }\n  },\n  '/': {\n    precedence: 2,\n    op: (left, right) => {\n      if (Array.isArray(left)) {\n        left = left.reduce((sum, value) => sum + value);\n      }\n      if (Array.isArray(right)) {\n        right = right.reduce((sum, value) => sum + value);\n      }\n      return parseInt(left) / parseInt(right);\n    }\n  },\n  l: {\n    precedence: 3,\n    op: (left, right) => {\n      // Remove the lowest `right` number of rolls\n      return left.sort().splice(right);\n    }\n  },\n  h: {\n    precedence: 3,\n    op: (left, right) => {\n      // Select the highest `right` number of rolls\n      return left.sort((l, r) => r - l).splice(right);\n    }\n  },\n  d: {\n    precedence: 4,\n    op: (left, right, criticalHit, die) => {\n      const mul = parseInt(left) * (criticalHit ? 2 : 1);\n      const sides = parseInt(right);\n      const rolls = [];\n      for (let i = 0; i < mul; i++) {\n        rolls.push(die(sides));\n      }\n      return rolls;\n    }\n  }\n};\n\n/**\n * Take a peek at the last element of an array\n *\n * @param {*} arr The array to peek into\n */\nconst peek = arr => arr[arr.length - 1];\n\n/**\n * Reorder an array so that the precedence of operators is taken into account\n *\n * @param {*} stack The stack to reorder\n * @param {*} token The token (operator) we're trying to insert\n * @param {*} out Where to put the resulting ordered operators\n */\nconst reorder = (stack, token, out) => {\n  while (peek(stack) in ops && ops[token].precedence <= ops[peek(stack)].precedence) {\n    out.push(stack.pop());\n  }\n};\n\n/**\n * Determine if a string is a base 10 number\n *\n * @param {*} str The string to check\n */\nconst isNumber = str => {\n  for (let i = 0; i < str.length; i++) {\n    const ch = str.charAt(i);\n    if (ch < '0' || ch > '9') {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Lex an expression (dice notation) into it's components\n *\n * @param {*} expression The expression (given as dice notation) to lex\n */\nconst lex = expression => {\n  const operators = [...Object.keys(ops), '(', ')'];\n  return expression.split('').reduce((output, token) => {\n    if (operators.includes(token)) {\n      output.push(token);\n    } else if (token.trim().length > 0) {\n      if (output.length > 0 && isNumber(output[output.length - 1])) {\n        // If the last thing we parsed was also a number, then this is a part of that number\n        output.push(output.pop() + token);\n      } else {\n        // Start a new number\n        output.push(token);\n      }\n    }\n    return output;\n  }, []).join(' ');\n};\n\n/**\n * An implementation of Djikstra's shunting yard algorithm (https://en.wikipedia.org/wiki/Shunting-yard_algorithm)\n * modified to account for the peculiarities around dice notation\n *\n * @param {*} infix The expression to convert to postfix notation for evaluating\n */\nconst yard = infix => {\n  let stack = [];\n  return infix.split(' ').reduce((output, token) => {\n    if (token in ops) {\n      reorder(stack, token, output);\n      stack.push(token);\n    } else if (token === '(') {\n      stack.push(token);\n    } else if (token === ')') {\n      while (peek(stack) !== '(') output.push(stack.pop());\n      stack.pop();\n    } else if (isNumber(token)) {\n      // It's just a number, so put it to the output\n      output.push(token);\n    } else if (token.includes('d')) {\n      // We have a dice throw\n      let tokens = token.split('d');\n\n      // This is the multiplier, so push it to the output\n      output.push(tokens[0]);\n      reorder(stack, 'd', output);\n      stack.push('d');\n      const selector = tokens[1].includes('l') ? 'l' // Remove the lowest n throws\n      : tokens[1].includes('h') ? 'h' // Take the highest n throws\n      : null;\n      if (selector !== null) {\n        let selected = tokens[1].split(selector);\n        // Push the sides of the dice regardless\n        output.push(selected[0]);\n        reorder(stack, selector, output);\n        stack.push(selector);\n        output.push(selected[1]);\n      } else {\n        // No selector, just the sides left\n        output.push(tokens[1]);\n      }\n    }\n    return output;\n  }, []).concat(stack.reverse()).join(' ');\n};\n\n/**\n * Evaluate a dice notation given in postfix notation\n *\n * @param {*} postfix The notation to parse\n * @param {*} criticalHit Whether or not the roll was a critical hit\n * @param {*} die The dice function to use to 'roll' a dice\n */\nconst rpn = (postfix, criticalHit, die) => {\n  const evaluated = postfix.split(' ').reduce((stack, token) => {\n    if (token in ops) {\n      let right = stack.pop();\n      let left = stack.pop();\n      stack.push(ops[token].op(left, right, criticalHit, die));\n    } else {\n      stack.push(token);\n    }\n    return stack;\n  }, []).pop();\n\n  // We can either get a value here, or an array (indicating the last item was a dice roll)\n  return Array.isArray(evaluated) ? evaluated.reduce((sum, value) => sum + value, 0) : parseInt(evaluated || '0', 10); // In case of evaluated being an empty string\n};\n\n/**\n * Parse a dice's notation. Based on the notation given at https://en.wikipedia.org/wiki/Dice_notation\n *\n * @param {*} notation The notation to parse\n * @param {*} criticalHit Whether or not the dice was a critical hit\n * @param {*} dice The dice function to use (useful for determining range)\n */\nconst parse = (notation, criticalHit, dice) => rpn(yard(lex(notation)), criticalHit, dice);\n\n/**\n * Calculate the damage range of some given notation\n *\n * This is mostly used for testing purposes, however it previously\n * offered a damage range for weapons\n *\n * @param {*} notation The notation to determine the range for\n * @param {*} criticalHit Whether or not that roll was a critical hit\n */\nexport const calculateDamageRange = (notation, criticalHit) => {\n  const min = parse(notation, criticalHit, biased('min'));\n  const max = parse(notation, criticalHit, biased('max'));\n  return [min, max];\n};\n\n/**\n * Determine the damage done given the notation and whether or not the roll is a critical hit\n *\n * @param {*} notation The dice notation we want to calculate\n * @param {*} criticalHit Whether the roll was a critical hit\n */\nexport const calculateDamage = (notation, criticalHit) => parse(notation, criticalHit, unbiased);\n\n/**\n * A standard 20 sided dice roll\n */\nexport const d20 = () => Math.floor(Math.random() * 20) + 1;","map":{"version":3,"names":["unbiased","sides","Math","floor","random","biased","to","_","ops","precedence","op","left","right","Array","isArray","reduce","sum","value","parseInt","l","sort","splice","h","r","d","criticalHit","die","mul","rolls","i","push","peek","arr","length","reorder","stack","token","out","pop","isNumber","str","ch","charAt","lex","expression","operators","Object","keys","split","output","includes","trim","join","yard","infix","tokens","selector","selected","concat","reverse","rpn","postfix","evaluated","parse","notation","dice","calculateDamageRange","min","max","calculateDamage","d20"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/utils/dice.js"],"sourcesContent":["/**\n * An 'unbiased' dice roll\n *\n * @param {*} sides The number of sides the dice has\n */\nconst unbiased = sides => Math.floor(Math.random() * sides) + 1;\n\n//\n/**\n * Create a 'biased' dice roll, either to the maximum or the minimum value.\n * If not specified, or it's not biased to either max or min, return an unbiased roll\n *\n * @param {*} to The bias we want to represent (max or min)\n */\nconst biased = to => {\n    if (to === 'max') {\n        return sides => sides;\n    } else if (to === 'min') {\n        return _ => 1;\n    }\n    return unbiased();\n};\n\nconst ops = {\n    '+': {\n        precedence: 1,\n        op: (left, right) => {\n            if (Array.isArray(left)) {\n                left = left.reduce((sum, value) => sum + value);\n            }\n            if (Array.isArray(right)) {\n                right = right.reduce((sum, value) => sum + value);\n            }\n            return parseInt(left) + parseInt(right);\n        },\n    },\n    '-': {\n        precedence: 1,\n        op: (left, right) => {\n            if (Array.isArray(left)) {\n                left = left.reduce((sum, value) => sum + value);\n            }\n            if (Array.isArray(right)) {\n                right = right.reduce((sum, value) => sum + value);\n            }\n            return parseInt(left) - parseInt(right);\n        },\n    },\n    '*': {\n        precedence: 2,\n        op: (left, right) => {\n            if (Array.isArray(left)) {\n                left = left.reduce((sum, value) => sum + value);\n            }\n            if (Array.isArray(right)) {\n                right = right.reduce((sum, value) => sum + value);\n            }\n            return parseInt(left) * parseInt(right);\n        },\n    },\n    '/': {\n        precedence: 2,\n        op: (left, right) => {\n            if (Array.isArray(left)) {\n                left = left.reduce((sum, value) => sum + value);\n            }\n            if (Array.isArray(right)) {\n                right = right.reduce((sum, value) => sum + value);\n            }\n            return parseInt(left) / parseInt(right);\n        },\n    },\n    l: {\n        precedence: 3,\n        op: (left, right) => {\n            // Remove the lowest `right` number of rolls\n            return left.sort().splice(right);\n        },\n    },\n    h: {\n        precedence: 3,\n        op: (left, right) => {\n            // Select the highest `right` number of rolls\n            return left.sort((l, r) => r - l).splice(right);\n        },\n    },\n    d: {\n        precedence: 4,\n        op: (left, right, criticalHit, die) => {\n            const mul = parseInt(left) * (criticalHit ? 2 : 1);\n            const sides = parseInt(right);\n            const rolls = [];\n            for (let i = 0; i < mul; i++) {\n                rolls.push(die(sides));\n            }\n            return rolls;\n        },\n    },\n};\n\n/**\n * Take a peek at the last element of an array\n *\n * @param {*} arr The array to peek into\n */\nconst peek = arr => arr[arr.length - 1];\n\n/**\n * Reorder an array so that the precedence of operators is taken into account\n *\n * @param {*} stack The stack to reorder\n * @param {*} token The token (operator) we're trying to insert\n * @param {*} out Where to put the resulting ordered operators\n */\nconst reorder = (stack, token, out) => {\n    while (\n        peek(stack) in ops &&\n        ops[token].precedence <= ops[peek(stack)].precedence\n    ) {\n        out.push(stack.pop());\n    }\n};\n\n/**\n * Determine if a string is a base 10 number\n *\n * @param {*} str The string to check\n */\nconst isNumber = str => {\n    for (let i = 0; i < str.length; i++) {\n        const ch = str.charAt(i);\n        if (ch < '0' || ch > '9') {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n/**\n * Lex an expression (dice notation) into it's components\n *\n * @param {*} expression The expression (given as dice notation) to lex\n */\nconst lex = expression => {\n    const operators = [...Object.keys(ops), '(', ')'];\n\n    return expression\n        .split('')\n        .reduce((output, token) => {\n            if (operators.includes(token)) {\n                output.push(token);\n            } else if (token.trim().length > 0) {\n                if (output.length > 0 && isNumber(output[output.length - 1])) {\n                    // If the last thing we parsed was also a number, then this is a part of that number\n                    output.push(output.pop() + token);\n                } else {\n                    // Start a new number\n                    output.push(token);\n                }\n            }\n\n            return output;\n        }, [])\n        .join(' ');\n};\n\n/**\n * An implementation of Djikstra's shunting yard algorithm (https://en.wikipedia.org/wiki/Shunting-yard_algorithm)\n * modified to account for the peculiarities around dice notation\n *\n * @param {*} infix The expression to convert to postfix notation for evaluating\n */\nconst yard = infix => {\n    let stack = [];\n\n    return infix\n        .split(' ')\n        .reduce((output, token) => {\n            if (token in ops) {\n                reorder(stack, token, output);\n                stack.push(token);\n            } else if (token === '(') {\n                stack.push(token);\n            } else if (token === ')') {\n                while (peek(stack) !== '(') output.push(stack.pop());\n                stack.pop();\n            } else if (isNumber(token)) {\n                // It's just a number, so put it to the output\n                output.push(token);\n            } else if (token.includes('d')) {\n                // We have a dice throw\n                let tokens = token.split('d');\n\n                // This is the multiplier, so push it to the output\n                output.push(tokens[0]);\n                reorder(stack, 'd', output);\n                stack.push('d');\n\n                const selector = tokens[1].includes('l')\n                    ? 'l' // Remove the lowest n throws\n                    : tokens[1].includes('h')\n                    ? 'h' // Take the highest n throws\n                    : null;\n\n                if (selector !== null) {\n                    let selected = tokens[1].split(selector);\n                    // Push the sides of the dice regardless\n                    output.push(selected[0]);\n\n                    reorder(stack, selector, output);\n                    stack.push(selector);\n                    output.push(selected[1]);\n                } else {\n                    // No selector, just the sides left\n                    output.push(tokens[1]);\n                }\n            }\n\n            return output;\n        }, [])\n        .concat(stack.reverse())\n        .join(' ');\n};\n\n/**\n * Evaluate a dice notation given in postfix notation\n *\n * @param {*} postfix The notation to parse\n * @param {*} criticalHit Whether or not the roll was a critical hit\n * @param {*} die The dice function to use to 'roll' a dice\n */\nconst rpn = (postfix, criticalHit, die) => {\n    const evaluated = postfix\n        .split(' ')\n        .reduce((stack, token) => {\n            if (token in ops) {\n                let right = stack.pop();\n                let left = stack.pop();\n                stack.push(ops[token].op(left, right, criticalHit, die));\n            } else {\n                stack.push(token);\n            }\n\n            return stack;\n        }, [])\n        .pop();\n\n    // We can either get a value here, or an array (indicating the last item was a dice roll)\n    return Array.isArray(evaluated)\n        ? evaluated.reduce((sum, value) => sum + value, 0)\n        : parseInt(evaluated || '0', 10); // In case of evaluated being an empty string\n};\n\n/**\n * Parse a dice's notation. Based on the notation given at https://en.wikipedia.org/wiki/Dice_notation\n *\n * @param {*} notation The notation to parse\n * @param {*} criticalHit Whether or not the dice was a critical hit\n * @param {*} dice The dice function to use (useful for determining range)\n */\nconst parse = (notation, criticalHit, dice) =>\n    rpn(yard(lex(notation)), criticalHit, dice);\n\n/**\n * Calculate the damage range of some given notation\n *\n * This is mostly used for testing purposes, however it previously\n * offered a damage range for weapons\n *\n * @param {*} notation The notation to determine the range for\n * @param {*} criticalHit Whether or not that roll was a critical hit\n */\nexport const calculateDamageRange = (notation, criticalHit) => {\n    const min = parse(notation, criticalHit, biased('min'));\n    const max = parse(notation, criticalHit, biased('max'));\n    return [min, max];\n};\n\n/**\n * Determine the damage done given the notation and whether or not the roll is a critical hit\n *\n * @param {*} notation The dice notation we want to calculate\n * @param {*} criticalHit Whether the roll was a critical hit\n */\nexport const calculateDamage = (notation, criticalHit) =>\n    parse(notation, criticalHit, unbiased);\n\n/**\n * A standard 20 sided dice roll\n */\nexport const d20 = () => Math.floor(Math.random() * 20) + 1;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}