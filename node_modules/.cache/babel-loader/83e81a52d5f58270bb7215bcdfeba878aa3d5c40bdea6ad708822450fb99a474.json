{"ast":null,"code":"import { playerInRange, getRandomDirection } from './move-monster';\nimport { move } from './normal-ai';\nimport { calculateDamage } from '../../../utils/dice';\nimport { SPRITE_SIZE } from '../../../config/constants';\n\n/**\n * An AI for monsters who will deal damage to the player and die when they come in\n * contact with the player\n *\n * @param {*} sightBox The players FOV\n * @param {*} currentMap The map the player is in\n * @param {*} monster The monster we're moving\n */\nexport default function suicidal(sightBox, currentMap, monster) {\n  return (dispatch, getState) => {\n    const {\n      stats\n    } = getState();\n    const {\n      id,\n      position,\n      dice,\n      type\n    } = monster;\n    const monsterPosition = position.map(pos => pos / SPRITE_SIZE);\n    let monsterVisible = false;\n    // look through each current sight box tile\n    sightBox.forEach(tile => {\n      // if the monster is in sight\n      if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n        monsterVisible = true;\n      }\n    });\n    if (monsterVisible) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n      const {\n        player\n      } = getState();\n      // check if player is in range\n      if (playerInRange(player.position, monsterPosition)) {\n        const calculatedMonsterDamage = calculateDamage(dice);\n        dispatch({\n          type: 'DAMAGE_TO_PLAYER',\n          payload: {\n            damage: calculatedMonsterDamage,\n            entity: type,\n            kind: 'suicide'\n          }\n        });\n\n        // check if player died\n        if (stats.hp - calculatedMonsterDamage <= 0) {\n          // play death sound\n          dispatch({\n            type: 'PLAYER_DIED',\n            payload: {\n              entity: type\n            }\n          });\n          // if it did, game over\n          dispatch({\n            type: 'PAUSE',\n            payload: {\n              gameOver: true,\n              pause: true\n            }\n          });\n        }\n        // deal damage to monster\n        dispatch({\n          type: 'DAMAGE_TO_MONSTER',\n          payload: {\n            damage: monster.hp,\n            id: monster.id,\n            map: currentMap,\n            entity: monster.type,\n            from: 'suicide'\n          }\n        });\n        dispatch({\n          type: 'GET_EXP',\n          payload: monster.exp\n        });\n        if (stats.exp + monster.exp >= stats.expToLevel) {\n          dispatch({\n            type: 'PAUSE',\n            payload: {\n              pause: true,\n              levelUp: true\n            }\n          });\n        }\n        // play death sound\n        dispatch({\n          type: 'MONSTER_DIED',\n          payload: monster.type\n        });\n        // replace monster will blood spill\n        // need to pass relative tile index\n        dispatch({\n          type: 'ADD_BLOOD_SPILL',\n          payload: {\n            x: position[0] / SPRITE_SIZE,\n            y: position[1] / SPRITE_SIZE\n          }\n        });\n      } else {\n        // no player in range, time to move!\n        // get the monsters actual position in pixels\n        const position = monsterPosition.map(value => value * SPRITE_SIZE);\n        // get distance from player on both axis\n        const xDiff = position[0] - player.position[0];\n        const yDiff = position[1] - player.position[1];\n        const greaterY = Math.abs(yDiff) > Math.abs(xDiff);\n        // see if y axis is greater distance from player\n        if (greaterY) {\n          // if the monster is mostly below the player on the y axis\n          if (yDiff > 0) {\n            // move the monster 'up' relatively\n            dispatch(move('up', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n          // if the monster is mostly above the player on the y axis\n          else if (yDiff < 0) {\n            // move the monster 'down' relatively\n            dispatch(move('down', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n        } // x axis is greater distance from player\n        else {\n          // if the monster is mostly to the right of the player\n          if (xDiff > 0) {\n            // move the monster 'left' relatively\n            dispatch(move('left', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n          // if the monster is mostly to the left of the player\n          else if (xDiff < 0) {\n            // move the monster 'right' relatively\n            dispatch(move('right', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n        }\n      }\n    } else {\n      // monster is too far away from the player\n      dispatch({\n        type: 'HIDE_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n      // give a 25% chance to move the monster when hidden\n      if (Math.round(Math.random() * (4 - 1) + 1) !== 4) {\n        const randomDirection = getRandomDirection();\n        // move the monster in a random direction\n        dispatch(move(randomDirection, position, currentMap, id, 0));\n      }\n    }\n  };\n}","map":{"version":3,"names":["playerInRange","getRandomDirection","move","calculateDamage","SPRITE_SIZE","suicidal","sightBox","currentMap","monster","dispatch","getState","stats","id","position","dice","type","monsterPosition","map","pos","monsterVisible","forEach","tile","JSON","stringify","payload","player","calculatedMonsterDamage","damage","entity","kind","hp","gameOver","pause","from","exp","expToLevel","levelUp","x","y","value","xDiff","yDiff","greaterY","Math","abs","round","random","randomDirection"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/monsters/actions/suicidal-ai.jsx"],"sourcesContent":["import { playerInRange, getRandomDirection } from './move-monster';\nimport { move } from './normal-ai';\nimport { calculateDamage } from '../../../utils/dice';\nimport { SPRITE_SIZE } from '../../../config/constants';\n\n/**\n * An AI for monsters who will deal damage to the player and die when they come in\n * contact with the player\n *\n * @param {*} sightBox The players FOV\n * @param {*} currentMap The map the player is in\n * @param {*} monster The monster we're moving\n */\nexport default function suicidal(sightBox, currentMap, monster) {\n    return (dispatch, getState) => {\n        const { stats } = getState();\n        const { id, position, dice, type } = monster;\n\n        const monsterPosition = position.map(pos => pos / SPRITE_SIZE);\n\n        let monsterVisible = false;\n        // look through each current sight box tile\n        sightBox.forEach(tile => {\n            // if the monster is in sight\n            if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n                monsterVisible = true;\n            }\n        });\n\n        if (monsterVisible) {\n            dispatch({\n                type: 'REVEAL_MONSTER',\n                payload: { id, map: currentMap },\n            });\n\n            const { player } = getState();\n            // check if player is in range\n            if (playerInRange(player.position, monsterPosition)) {\n                const calculatedMonsterDamage = calculateDamage(dice);\n                dispatch({\n                    type: 'DAMAGE_TO_PLAYER',\n                    payload: {\n                        damage: calculatedMonsterDamage,\n                        entity: type,\n                        kind: 'suicide',\n                    },\n                });\n\n                // check if player died\n                if (stats.hp - calculatedMonsterDamage <= 0) {\n                    // play death sound\n                    dispatch({\n                        type: 'PLAYER_DIED',\n                        payload: { entity: type },\n                    });\n                    // if it did, game over\n                    dispatch({\n                        type: 'PAUSE',\n                        payload: {\n                            gameOver: true,\n                            pause: true,\n                        },\n                    });\n                }\n                // deal damage to monster\n                dispatch({\n                    type: 'DAMAGE_TO_MONSTER',\n                    payload: {\n                        damage: monster.hp,\n                        id: monster.id,\n                        map: currentMap,\n                        entity: monster.type,\n                        from: 'suicide',\n                    },\n                });\n\n                dispatch({\n                    type: 'GET_EXP',\n                    payload: monster.exp,\n                });\n\n                if (stats.exp + monster.exp >= stats.expToLevel) {\n                    dispatch({\n                        type: 'PAUSE',\n                        payload: {\n                            pause: true,\n                            levelUp: true,\n                        },\n                    });\n                }\n                // play death sound\n                dispatch({\n                    type: 'MONSTER_DIED',\n                    payload: monster.type,\n                });\n                // replace monster will blood spill\n                // need to pass relative tile index\n                dispatch({\n                    type: 'ADD_BLOOD_SPILL',\n                    payload: {\n                        x: position[0] / SPRITE_SIZE,\n                        y: position[1] / SPRITE_SIZE,\n                    },\n                });\n            } else {\n                // no player in range, time to move!\n                // get the monsters actual position in pixels\n                const position = monsterPosition.map(\n                    value => value * SPRITE_SIZE\n                );\n                // get distance from player on both axis\n                const xDiff = position[0] - player.position[0];\n                const yDiff = position[1] - player.position[1];\n                const greaterY = Math.abs(yDiff) > Math.abs(xDiff);\n                // see if y axis is greater distance from player\n                if (greaterY) {\n                    // if the monster is mostly below the player on the y axis\n                    if (yDiff > 0) {\n                        // move the monster 'up' relatively\n                        dispatch(\n                            move(\n                                'up',\n                                position,\n                                currentMap,\n                                id,\n                                0,\n                                xDiff >= 0 ? 'left' : 'right'\n                            )\n                        );\n                    }\n                    // if the monster is mostly above the player on the y axis\n                    else if (yDiff < 0) {\n                        // move the monster 'down' relatively\n                        dispatch(\n                            move(\n                                'down',\n                                position,\n                                currentMap,\n                                id,\n                                0,\n                                xDiff >= 0 ? 'left' : 'right'\n                            )\n                        );\n                    }\n                } // x axis is greater distance from player\n                else {\n                    // if the monster is mostly to the right of the player\n                    if (xDiff > 0) {\n                        // move the monster 'left' relatively\n                        dispatch(\n                            move(\n                                'left',\n                                position,\n                                currentMap,\n                                id,\n                                0,\n                                yDiff >= 0 ? 'up' : 'down'\n                            )\n                        );\n                    }\n                    // if the monster is mostly to the left of the player\n                    else if (xDiff < 0) {\n                        // move the monster 'right' relatively\n                        dispatch(\n                            move(\n                                'right',\n                                position,\n                                currentMap,\n                                id,\n                                0,\n                                yDiff >= 0 ? 'up' : 'down'\n                            )\n                        );\n                    }\n                }\n            }\n        } else {\n            // monster is too far away from the player\n            dispatch({\n                type: 'HIDE_MONSTER',\n                payload: { id, map: currentMap },\n            });\n            // give a 25% chance to move the monster when hidden\n            if (Math.round(Math.random() * (4 - 1) + 1) !== 4) {\n                const randomDirection = getRandomDirection();\n                // move the monster in a random direction\n                dispatch(move(randomDirection, position, currentMap, id, 0));\n            }\n        }\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}