{"ast":null,"code":"import { getRandomDirection, playerInView } from './move-monster';\nimport { move } from './normal-ai';\nimport { SPRITE_SIZE, SIGHT_RADIUS } from '../../../config/constants';\nimport attackPlayer from './attack-player';\n\n/**\n * An AI for monsters who have the capability of using ranged attacks\n *\n * @param {*} sightBox The players FOV\n * @param {*} currentMap The map the player is in\n * @param {*} monster The monster we're moving\n */\nexport default function ranged(sightBox, currentMap, monster) {\n  return (dispatch, getState) => {\n    const {\n      id,\n      position\n    } = monster;\n    const monsterPosition = position.map(pos => pos / SPRITE_SIZE);\n    let monsterVisible = false;\n    // look through each current sight box tile\n    sightBox.forEach(tile => {\n      // if the monster is in sight\n      if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n        monsterVisible = true;\n      }\n    });\n    if (monsterVisible) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n      const {\n        player\n      } = getState();\n      // check if player is in range\n      if (dispatch(playerInView(monsterPosition, SIGHT_RADIUS))) {\n        dispatch(attackPlayer(monster));\n      } else {\n        // no player in range, time to move!\n        // get the monsters actual position in pixels\n        const position = monsterPosition.map(value => value * SPRITE_SIZE);\n        // get distance from player on both axis\n        const xDiff = position[0] - player.position[0];\n        const yDiff = position[1] - player.position[1];\n        const greaterY = Math.abs(yDiff) > Math.abs(xDiff);\n        // see if y axis is greater distance from player\n        if (greaterY) {\n          // if the monster is mostly below the player on the y axis\n          if (yDiff > 0) {\n            // move the monster 'up' relatively\n            dispatch(move('up', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n          // if the monster is mostly above the player on the y axis\n          else if (yDiff < 0) {\n            // move the monster 'down' relatively\n            dispatch(move('down', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n        } // x axis is greater distance from player\n        else {\n          // if the monster is mostly to the right of the player\n          if (xDiff > 0) {\n            // move the monster 'left' relatively\n            dispatch(move('left', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n          // if the monster is mostly to the left of the player\n          else if (xDiff < 0) {\n            // move the monster 'right' relatively\n            dispatch(move('right', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n        }\n      }\n    } else {\n      // monster is too far away from the player\n      dispatch({\n        type: 'HIDE_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n      // give a 25% chance to move the monster when hidden\n      if (Math.round(Math.random() * (4 - 1) + 1) !== 4) {\n        const randomDirection = getRandomDirection();\n        // move the monster in a random direction\n        dispatch(move(randomDirection, position, currentMap, id, 0));\n      }\n    }\n  };\n}","map":{"version":3,"names":["getRandomDirection","playerInView","move","SPRITE_SIZE","SIGHT_RADIUS","attackPlayer","ranged","sightBox","currentMap","monster","dispatch","getState","id","position","monsterPosition","map","pos","monsterVisible","forEach","tile","JSON","stringify","type","payload","player","value","xDiff","yDiff","greaterY","Math","abs","round","random","randomDirection"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/monsters/actions/ranged-ai.jsx"],"sourcesContent":["import { getRandomDirection, playerInView } from './move-monster';\nimport { move } from './normal-ai';\nimport { SPRITE_SIZE, SIGHT_RADIUS } from '../../../config/constants';\nimport attackPlayer from './attack-player';\n\n/**\n * An AI for monsters who have the capability of using ranged attacks\n *\n * @param {*} sightBox The players FOV\n * @param {*} currentMap The map the player is in\n * @param {*} monster The monster we're moving\n */\nexport default function ranged(sightBox, currentMap, monster) {\n  return (dispatch, getState) => {\n    const { id, position } = monster;\n\n    const monsterPosition = position.map((pos) => pos / SPRITE_SIZE);\n\n    let monsterVisible = false;\n    // look through each current sight box tile\n    sightBox.forEach((tile) => {\n      // if the monster is in sight\n      if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n        monsterVisible = true;\n      }\n    });\n\n    if (monsterVisible) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: { id, map: currentMap },\n      });\n\n      const { player } = getState();\n      // check if player is in range\n      if (dispatch(playerInView(monsterPosition, SIGHT_RADIUS))) {\n        dispatch(attackPlayer(monster));\n      } else {\n        // no player in range, time to move!\n        // get the monsters actual position in pixels\n        const position = monsterPosition.map((value) => value * SPRITE_SIZE);\n        // get distance from player on both axis\n        const xDiff = position[0] - player.position[0];\n        const yDiff = position[1] - player.position[1];\n        const greaterY = Math.abs(yDiff) > Math.abs(xDiff);\n        // see if y axis is greater distance from player\n        if (greaterY) {\n          // if the monster is mostly below the player on the y axis\n          if (yDiff > 0) {\n            // move the monster 'up' relatively\n            dispatch(move('up', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n          // if the monster is mostly above the player on the y axis\n          else if (yDiff < 0) {\n            // move the monster 'down' relatively\n            dispatch(move('down', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n        } // x axis is greater distance from player\n        else {\n          // if the monster is mostly to the right of the player\n          if (xDiff > 0) {\n            // move the monster 'left' relatively\n            dispatch(move('left', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n          // if the monster is mostly to the left of the player\n          else if (xDiff < 0) {\n            // move the monster 'right' relatively\n            dispatch(move('right', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n        }\n      }\n    } else {\n      // monster is too far away from the player\n      dispatch({\n        type: 'HIDE_MONSTER',\n        payload: { id, map: currentMap },\n      });\n      // give a 25% chance to move the monster when hidden\n      if (Math.round(Math.random() * (4 - 1) + 1) !== 4) {\n        const randomDirection = getRandomDirection();\n        // move the monster in a random direction\n        dispatch(move(randomDirection, position, currentMap, id, 0));\n      }\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}