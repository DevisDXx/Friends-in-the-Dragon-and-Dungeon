{"ast":null,"code":"import generateObjects from './generate-objects';\nimport { MAP_DIMENSIONS, MAX_TUNNELS, MAX_LENGTH } from '../../../config/constants';\n\n/**\n * Generate a map for a specific floor, and having a certain start point\n *\n * @param {*} startPos The starting point for the map (where the player spawns)\n * @param {*} floorNum The floor number\n */\nexport default function generateMap(startPos, floorNum) {\n  // change the walls of the dungeon as the floors get higher\n  let wallType = 5;\n  if (floorNum >= 30) wallType = 6;\n  if (floorNum >= 60) wallType = 7;\n  if (floorNum >= 90) wallType = 8;\n  const map = createMapOfWalls(wallType),\n    // create a map of walls to carve rooms and hallways from\n    directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // array to get a random direction from (left,right,up,down)\n  let maxTunnels = MAX_TUNNELS,\n    // store the max tunnels in a local variable that can be decremented\n    currentRow = startPos ? startPos[1] : Math.floor(Math.random() * MAP_DIMENSIONS[1]),\n    // our current row - start at a random spot\n    currentColumn = startPos ? startPos[0] : Math.floor(Math.random() * MAP_DIMENSIONS[0]),\n    // our current column - start at a random spot\n    lastDirection = [],\n    // save the last direction we went\n    randomDirection; // next turn/direction - holds a value from directions\n\n  // lets create some tunnels - while maxTunnels, MAP_DIMENSIONS, and MAX_LENGTH is greater than 0.\n  while (maxTunnels && MAP_DIMENSIONS && MAX_LENGTH) {\n    // lets get a random direction - until it is a perpendicular to our lastDirection\n    // if the last direction = left or right,\n    // then our new direction has to be up or down,\n    // and vice versa\n    do {\n      randomDirection = directions[Math.floor(Math.random() * directions.length)];\n    } while (randomDirection[0] === -lastDirection[0] && randomDirection[1] === -lastDirection[1] || randomDirection[0] === lastDirection[0] && randomDirection[1] === lastDirection[1]);\n    const randomLength = Math.ceil(Math.random() * MAX_LENGTH); // length the next tunnel will be (max of maxLength)\n    let tunnelLength = 0; // current length of tunnel being created\n\n    // lets loop until our tunnel is long enough or until we hit an edge\n    while (tunnelLength < randomLength) {\n      //break the loop if it is going out of the map\n      if (currentRow === 0 && randomDirection[0] === -1 || currentColumn === 0 && randomDirection[1] === -1 || currentRow === MAP_DIMENSIONS[1] - 1 && randomDirection[0] === 1 || currentColumn === MAP_DIMENSIONS[0] - 1 && randomDirection[1] === 1) {\n        break;\n      } else {\n        map[currentRow][currentColumn] = 0; //set the value of the index in map to 0 (a tunnel, making it one longer)\n        currentRow += randomDirection[0]; //add the value from randomDirection to row and col (-1, 0, or 1) to update our location\n        currentColumn += randomDirection[1];\n        tunnelLength++; //the tunnel is now one longer, so lets increment that variable\n      }\n    }\n    if (tunnelLength) {\n      // update our variables unless our last loop broke before we made any part of a tunnel\n      lastDirection = randomDirection; //set lastDirection, so we can remember what way we went\n      maxTunnels--; // we created a whole tunnel so lets decrement how many we have left to create\n    }\n  }\n\n  // all our tunnels have been created and now we run placeObjects(),\n  // which will complete our map, so lets return it to our render()\n  return generateObjects(map, floorNum, startPos, wallType);\n}\n\n// generate a map filled with wall tiles\nfunction createMapOfWalls(wallType) {\n  const array = [];\n  for (let i = 0; i < MAP_DIMENSIONS[1]; i++) {\n    array.push([]);\n    for (let j = 0; j < MAP_DIMENSIONS[0]; j++) {\n      array[i].push(wallType);\n    }\n  }\n  return array;\n}","map":{"version":3,"names":["generateObjects","MAP_DIMENSIONS","MAX_TUNNELS","MAX_LENGTH","generateMap","startPos","floorNum","wallType","map","createMapOfWalls","directions","maxTunnels","currentRow","Math","floor","random","currentColumn","lastDirection","randomDirection","length","randomLength","ceil","tunnelLength","array","i","push","j"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/map/random-map-gen/generate-map.jsx"],"sourcesContent":["import generateObjects from './generate-objects';\nimport {\n    MAP_DIMENSIONS,\n    MAX_TUNNELS,\n    MAX_LENGTH,\n} from '../../../config/constants';\n\n/**\n * Generate a map for a specific floor, and having a certain start point\n *\n * @param {*} startPos The starting point for the map (where the player spawns)\n * @param {*} floorNum The floor number\n */\nexport default function generateMap(startPos, floorNum) {\n    // change the walls of the dungeon as the floors get higher\n    let wallType = 5;\n    if (floorNum >= 30) wallType = 6;\n    if (floorNum >= 60) wallType = 7;\n    if (floorNum >= 90) wallType = 8;\n\n    const map = createMapOfWalls(wallType), // create a map of walls to carve rooms and hallways from\n        directions = [\n            [-1, 0],\n            [1, 0],\n            [0, -1],\n            [0, 1],\n        ]; // array to get a random direction from (left,right,up,down)\n    let maxTunnels = MAX_TUNNELS, // store the max tunnels in a local variable that can be decremented\n        currentRow = startPos\n            ? startPos[1]\n            : Math.floor(Math.random() * MAP_DIMENSIONS[1]), // our current row - start at a random spot\n        currentColumn = startPos\n            ? startPos[0]\n            : Math.floor(Math.random() * MAP_DIMENSIONS[0]), // our current column - start at a random spot\n        lastDirection = [], // save the last direction we went\n        randomDirection; // next turn/direction - holds a value from directions\n\n    // lets create some tunnels - while maxTunnels, MAP_DIMENSIONS, and MAX_LENGTH is greater than 0.\n    while (maxTunnels && MAP_DIMENSIONS && MAX_LENGTH) {\n        // lets get a random direction - until it is a perpendicular to our lastDirection\n        // if the last direction = left or right,\n        // then our new direction has to be up or down,\n        // and vice versa\n        do {\n            randomDirection =\n                directions[Math.floor(Math.random() * directions.length)];\n        } while (\n            (randomDirection[0] === -lastDirection[0] &&\n                randomDirection[1] === -lastDirection[1]) ||\n            (randomDirection[0] === lastDirection[0] &&\n                randomDirection[1] === lastDirection[1])\n        );\n\n        const randomLength = Math.ceil(Math.random() * MAX_LENGTH); // length the next tunnel will be (max of maxLength)\n        let tunnelLength = 0; // current length of tunnel being created\n\n        // lets loop until our tunnel is long enough or until we hit an edge\n        while (tunnelLength < randomLength) {\n            //break the loop if it is going out of the map\n            if (\n                (currentRow === 0 && randomDirection[0] === -1) ||\n                (currentColumn === 0 && randomDirection[1] === -1) ||\n                (currentRow === MAP_DIMENSIONS[1] - 1 &&\n                    randomDirection[0] === 1) ||\n                (currentColumn === MAP_DIMENSIONS[0] - 1 &&\n                    randomDirection[1] === 1)\n            ) {\n                break;\n            } else {\n                map[currentRow][currentColumn] = 0; //set the value of the index in map to 0 (a tunnel, making it one longer)\n                currentRow += randomDirection[0]; //add the value from randomDirection to row and col (-1, 0, or 1) to update our location\n                currentColumn += randomDirection[1];\n                tunnelLength++; //the tunnel is now one longer, so lets increment that variable\n            }\n        }\n\n        if (tunnelLength) {\n            // update our variables unless our last loop broke before we made any part of a tunnel\n            lastDirection = randomDirection; //set lastDirection, so we can remember what way we went\n            maxTunnels--; // we created a whole tunnel so lets decrement how many we have left to create\n        }\n    }\n\n    // all our tunnels have been created and now we run placeObjects(),\n    // which will complete our map, so lets return it to our render()\n    return generateObjects(map, floorNum, startPos, wallType);\n}\n\n// generate a map filled with wall tiles\nfunction createMapOfWalls(wallType) {\n    const array = [];\n    for (let i = 0; i < MAP_DIMENSIONS[1]; i++) {\n        array.push([]);\n        for (let j = 0; j < MAP_DIMENSIONS[0]; j++) {\n            array[i].push(wallType);\n        }\n    }\n    return array;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}