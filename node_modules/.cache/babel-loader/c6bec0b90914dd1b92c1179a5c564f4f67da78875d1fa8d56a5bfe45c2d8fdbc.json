{"ast":null,"code":"import _cloneDeep from 'lodash.clonedeep';\nimport calculateModifier from '../../utils/calculate-modifier';\nimport calculateMaxManaPool from '../../utils/calculate-max-mana-pool';\nimport calculateMaxHpPool from '../../utils/calculate-max-hp-pool';\nimport calculateDefenceBonus from '../../utils/calculate-defence-bonus';\nconst initialState = {\n  abilities: {\n    constitution: 0,\n    dexterity: 0,\n    strength: 0,\n    wisdom: 0,\n    intelligence: 0,\n    charisma: 0,\n    points: 0\n  },\n  character: {\n    characterName: '',\n    characterRace: '',\n    characterClass: ''\n  },\n  hp: 0,\n  abilityModifierHp: 0,\n  maxHp: 0,\n  mana: 0,\n  abilityModifierMana: 0,\n  maxMana: 0,\n  defence: 0,\n  level: 1,\n  exp: 0,\n  expToLevel: 20,\n  gold: 0,\n  equippedItems: {},\n  levelUp: {\n    level: 0,\n    hp: 0,\n    mana: 0\n  }\n};\nconst statsReducer = function () {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let {\n    type,\n    payload\n  } = arguments.length > 1 ? arguments[1] : undefined;\n  let newState;\n  switch (type) {\n    case 'CREATE_CHARACTER':\n      return {\n        ...state,\n        character: {\n          characterName: payload.characterName,\n          characterRace: payload.characterRace,\n          characterClass: payload.characterClass\n        }\n      };\n    case 'GET_GOLD':\n      // add gold to current gold\n      return {\n        ...state,\n        gold: state.gold + payload\n      };\n    case 'LOSE_GOLD':\n      // add gold to current gold\n      return {\n        ...state,\n        gold: state.gold - payload\n      };\n    case 'SET_ABILITY_SCORES':\n      // calculate new mana\n      const newAbilityModifierMana = calculateMaxManaPool(state.level, calculateModifier(payload.abilities.intelligence));\n      const manaDifference = newAbilityModifierMana - state.abilityModifierMana;\n      state.mana += manaDifference;\n      state.maxMana += manaDifference;\n      state.abilityModifierMana = newAbilityModifierMana;\n\n      // calculate new hp\n      const newAbilityModifierHp = calculateMaxHpPool(state.level, calculateModifier(payload.abilities.constitution));\n      const hpDifference = newAbilityModifierHp - state.abilityModifierHp;\n      state.hp += hpDifference;\n      state.maxHp += hpDifference;\n      state.abilityModifierHp = newAbilityModifierHp;\n      const previousDex = calculateModifier(state.abilities.dexterity);\n      const currentDex = calculateModifier(payload.abilities.dexterity);\n      const prevDefenceBonus = calculateDefenceBonus(previousDex);\n      const currDefenceBonus = calculateDefenceBonus(currentDex);\n      state.defence = state.defence - prevDefenceBonus + currDefenceBonus;\n      return {\n        ...state,\n        abilities: payload.abilities\n      };\n    case 'UNEQUIP_ITEM':\n      newState = _cloneDeep(state);\n\n      // iterate over each effect\n      Object.keys(payload.effect).forEach(effectName => {\n        switch (effectName) {\n          case 'defence':\n            newState.defence -= payload.effect[effectName];\n            break;\n          case 'hp':\n            newState.hp -= payload.effect[effectName];\n            if (newState.hp < 1) newState.hp = 1;\n            newState.maxHp -= payload.effect[effectName];\n            break;\n          case 'mana':\n            newState.mana -= payload.effect[effectName];\n            if (newState.mana < 1) newState.mana = 1;\n            newState.maxMana -= payload.effect[effectName];\n            break;\n          default:\n        }\n      });\n\n      // check the type\n      switch (payload.type) {\n        case 'weapon':\n          delete newState.equippedItems.weapon;\n          break;\n        case 'armor::body':\n          delete newState.equippedItems.armor.body;\n          break;\n        case 'armor::helmet':\n          delete newState.equippedItems.armor.helmet;\n          break;\n        case 'armor::pants':\n          delete newState.equippedItems.armor.pants;\n          break;\n        case 'armor::boots':\n          delete newState.equippedItems.armor.boots;\n          break;\n        case 'armor::gloves':\n          delete newState.equippedItems.armor.gloves;\n          break;\n        case 'ring':\n          delete newState.equippedItems.ring;\n          break;\n        default:\n      }\n      return newState;\n    case 'EQUIP_ITEM':\n      newState = _cloneDeep(state);\n      const item = payload;\n      // see what type of item it is\n      switch (item.type) {\n        case 'weapon':\n          if (newState.equippedItems.weapon && newState.equippedItems.weapon.effect) {\n            removeEffects(newState.equippedItems.weapon, newState);\n          }\n          newState.equippedItems.weapon = item;\n          break;\n        case 'armor::body':\n          if (newState.equippedItems.armor && newState.equippedItems.armor.body && newState.equippedItems.armor.body.effect) {\n            removeEffects(newState.equippedItems.armor.body, newState);\n          }\n          // if there's already armor\n          // safely add new armor peice to object\n          newState.equippedItems.armor = {\n            ...newState.equippedItems.armor,\n            body: item\n          };\n          break;\n        case 'armor::helmet':\n          // if there's already armor\n          if (newState.equippedItems.armor && newState.equippedItems.armor.helmet && newState.equippedItems.armor.helmet.effect) {\n            removeEffects(newState.equippedItems.armor.helmet, newState);\n          }\n          // safely add new armor peice to object\n          newState.equippedItems.armor = {\n            ...newState.equippedItems.armor,\n            helmet: item\n          };\n          break;\n        case 'armor::pants':\n          // if there's already armor\n          if (newState.equippedItems.armor && newState.equippedItems.armor.pants && newState.equippedItems.armor.pants.effect) {\n            removeEffects(newState.equippedItems.armor.pants, newState);\n          }\n          // safely add new armor peice to object\n          newState.equippedItems.armor = {\n            ...newState.equippedItems.armor,\n            pants: item\n          };\n          break;\n        case 'armor::gloves':\n          // if there's already armor\n          if (newState.equippedItems.armor && newState.equippedItems.armor.gloves && newState.equippedItems.armor.gloves.effect) {\n            removeEffects(newState.equippedItems.armor.gloves, newState);\n          }\n          // safely add new armor peice to object\n          newState.equippedItems.armor = {\n            ...newState.equippedItems.armor,\n            gloves: item\n          };\n          break;\n        case 'armor::boots':\n          // if there's already armor\n          if (newState.equippedItems.armor && newState.equippedItems.armor.boots && newState.equippedItems.armor.boots.effect) {\n            removeEffects(newState.equippedItems.armor.boots, newState);\n          }\n          // safely add new armor peice to object\n          newState.equippedItems.armor = {\n            ...newState.equippedItems.armor,\n            boots: item\n          };\n          break;\n        case 'ring':\n          const equippedRing = newState.equippedItems.ring;\n          // if there's already a ring\n          if (equippedRing) {\n            // subtract it's benefits\n            Object.keys(equippedRing.effect).forEach(effectName => {\n              switch (effectName) {\n                case 'defence':\n                  newState.defence -= equippedRing.effect[effectName];\n                  break;\n                case 'hp':\n                  newState.hp -= equippedRing.effect[effectName];\n                  if (newState.hp < 1) newState.hp = 1;\n                  newState.maxHp -= equippedRing.effect[effectName];\n                  break;\n                default:\n              }\n            });\n          }\n          newState.equippedItems.ring = item;\n          break;\n        default:\n      }\n\n      // iterate over each new effect\n      Object.keys(item.effect).forEach(effectName => {\n        switch (effectName) {\n          case 'defence':\n            newState.defence += item.effect[effectName];\n            break;\n          case 'hp':\n            newState.hp += item.effect[effectName];\n            newState.maxHp += item.effect[effectName];\n            break;\n          case 'mana':\n            newState.mana += payload.effect[effectName];\n            newState.maxMana += payload.effect[effectName];\n            break;\n          default:\n        }\n      });\n      return newState;\n    case 'HEAL_HP':\n      // heal the hp\n      let _hp = state.hp + payload;\n      // dont go above max hp\n      if (_hp > state.maxHp) _hp = state.maxHp;\n      return {\n        ...state,\n        hp: _hp\n      };\n    case 'RESTORE_MANA':\n      // regenerate the mana\n      let _mana = state.mana + payload.amount;\n      // don't go above max mana\n      if (_mana > state.maxMana) _mana = state.maxMana;\n      return {\n        ...state,\n        mana: _mana\n      };\n    case 'CAST_SPELL':\n      return {\n        ...state,\n        mana: state.mana - payload.projectile.manaCost\n      };\n    case 'DAMAGE_TO_PLAYER':\n      return {\n        ...state,\n        hp: state.hp - payload.damage\n      };\n    case 'GET_EXP':\n      newState = _cloneDeep(state);\n      const newTotalExp = state.exp + payload;\n      const {\n        expToLevel\n      } = state;\n      // if they are leveling up\n      if (newTotalExp >= expToLevel) {\n        // increment level\n        newState.level += 1;\n\n        // calculate leftover exp if it isn't exactly enough\n        if (!(newState.exp === expToLevel)) {\n          const leftoverExp = newTotalExp % expToLevel;\n          newState.exp = leftoverExp;\n        }\n\n        // set next exp goal to be 1.5 times as much if player is 5 or less\n        if (newState.level < 6) {\n          newState.expToLevel = Math.floor(state.expToLevel * 1.5);\n        } // otherwise set it to be 1.25 times as much\n        else if (newState.level < 20) {\n          newState.expToLevel = Math.floor(state.expToLevel * 1.25);\n        } else {} // let the exp goal remain static if they are lv 20+\n\n        // calculate new hp\n        const newAbilityModifierHp = calculateMaxHpPool(newState.level, calculateModifier(state.abilities.constitution));\n        newState.levelUp.hp = newAbilityModifierHp - state.abilityModifierHp;\n        newState.hp += newState.levelUp.hp;\n        newState.maxHp += newState.levelUp.hp;\n        newState.abilityModifierHp = newAbilityModifierHp;\n\n        // calculate new mana\n        const newAbilityModifierMana = calculateMaxManaPool(newState.level, calculateModifier(state.abilities.intelligence));\n        newState.levelUp.mana = newAbilityModifierMana - state.abilityModifierMana;\n        newState.mana += newState.levelUp.mana;\n        newState.maxMana += newState.levelUp.mana;\n        newState.abilityModifierMana = newAbilityModifierMana;\n        newState.levelUp.level = newState.level;\n      } else {\n        // they aren't leveling up\n        newState.exp += payload;\n      }\n      return newState;\n    case 'RESET':\n      return initialState;\n    case 'LOAD_DATA':\n      return {\n        ...initialState,\n        ...payload.stats\n      };\n    default:\n      return state;\n  }\n};\nconst removeEffects = (item, newState) => {\n  Object.keys(item.effect).forEach(effectName => {\n    switch (effectName) {\n      case 'defence':\n        newState.defence -= item.effect[effectName];\n        break;\n      case 'hp':\n        newState.hp -= item.effect[effectName];\n        if (newState.hp < 1) newState.hp = 1;\n        newState.maxHp -= item.effect[effectName];\n        break;\n      case 'mana':\n        newState.mana -= item.effect[effectName];\n        if (newState.mana < 1) newState.mana = 1;\n        newState.maxMana -= item.effect[effectName];\n        break;\n      default:\n    }\n  });\n};\nexport default statsReducer;","map":{"version":3,"names":["_cloneDeep","calculateModifier","calculateMaxManaPool","calculateMaxHpPool","calculateDefenceBonus","initialState","abilities","constitution","dexterity","strength","wisdom","intelligence","charisma","points","character","characterName","characterRace","characterClass","hp","abilityModifierHp","maxHp","mana","abilityModifierMana","maxMana","defence","level","exp","expToLevel","gold","equippedItems","levelUp","statsReducer","state","arguments","length","undefined","type","payload","newState","newAbilityModifierMana","manaDifference","newAbilityModifierHp","hpDifference","previousDex","currentDex","prevDefenceBonus","currDefenceBonus","Object","keys","effect","forEach","effectName","weapon","armor","body","helmet","pants","boots","gloves","ring","item","removeEffects","equippedRing","_hp","_mana","amount","projectile","manaCost","damage","newTotalExp","leftoverExp","Math","floor","stats"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/stats/reducer.jsx"],"sourcesContent":["import _cloneDeep from 'lodash.clonedeep';\nimport calculateModifier from '../../utils/calculate-modifier';\nimport calculateMaxManaPool from '../../utils/calculate-max-mana-pool';\nimport calculateMaxHpPool from '../../utils/calculate-max-hp-pool';\nimport calculateDefenceBonus from '../../utils/calculate-defence-bonus';\n\nconst initialState = {\n  abilities: {\n    constitution: 0,\n    dexterity: 0,\n    strength: 0,\n    wisdom: 0,\n    intelligence: 0,\n    charisma: 0,\n    points: 0,\n  },\n  character: {\n    characterName: '',\n    characterRace: '',\n    characterClass: '',\n  },\n  hp: 0,\n  abilityModifierHp: 0,\n  maxHp: 0,\n  mana: 0,\n  abilityModifierMana: 0,\n  maxMana: 0,\n  defence: 0,\n  level: 1,\n  exp: 0,\n  expToLevel: 20,\n  gold: 0,\n  equippedItems: {},\n  levelUp: { level: 0, hp: 0, mana: 0 },\n};\n\nconst statsReducer = (state = initialState, { type, payload }) => {\n  let newState;\n\n  switch (type) {\n    case 'CREATE_CHARACTER':\n      return {\n        ...state,\n        character: {\n          characterName: payload.characterName,\n          characterRace: payload.characterRace,\n          characterClass: payload.characterClass,\n        },\n      };\n\n    case 'GET_GOLD':\n      // add gold to current gold\n      return { ...state, gold: state.gold + payload };\n\n    case 'LOSE_GOLD':\n      // add gold to current gold\n      return { ...state, gold: state.gold - payload };\n\n    case 'SET_ABILITY_SCORES':\n      // calculate new mana\n      const newAbilityModifierMana = calculateMaxManaPool(\n        state.level,\n        calculateModifier(payload.abilities.intelligence)\n      );\n      const manaDifference = newAbilityModifierMana - state.abilityModifierMana;\n\n      state.mana += manaDifference;\n      state.maxMana += manaDifference;\n      state.abilityModifierMana = newAbilityModifierMana;\n\n      // calculate new hp\n      const newAbilityModifierHp = calculateMaxHpPool(\n        state.level,\n        calculateModifier(payload.abilities.constitution)\n      );\n      const hpDifference = newAbilityModifierHp - state.abilityModifierHp;\n\n      state.hp += hpDifference;\n      state.maxHp += hpDifference;\n      state.abilityModifierHp = newAbilityModifierHp;\n\n      const previousDex = calculateModifier(state.abilities.dexterity);\n      const currentDex = calculateModifier(payload.abilities.dexterity);\n\n      const prevDefenceBonus = calculateDefenceBonus(previousDex);\n      const currDefenceBonus = calculateDefenceBonus(currentDex);\n\n      state.defence = state.defence - prevDefenceBonus + currDefenceBonus;\n\n      return { ...state, abilities: payload.abilities };\n\n    case 'UNEQUIP_ITEM':\n      newState = _cloneDeep(state);\n\n      // iterate over each effect\n      Object.keys(payload.effect).forEach((effectName) => {\n        switch (effectName) {\n          case 'defence':\n            newState.defence -= payload.effect[effectName];\n            break;\n\n          case 'hp':\n            newState.hp -= payload.effect[effectName];\n            if (newState.hp < 1) newState.hp = 1;\n            newState.maxHp -= payload.effect[effectName];\n            break;\n\n          case 'mana':\n            newState.mana -= payload.effect[effectName];\n            if (newState.mana < 1) newState.mana = 1;\n            newState.maxMana -= payload.effect[effectName];\n            break;\n\n          default:\n        }\n      });\n\n      // check the type\n      switch (payload.type) {\n        case 'weapon':\n          delete newState.equippedItems.weapon;\n          break;\n\n        case 'armor::body':\n          delete newState.equippedItems.armor.body;\n          break;\n\n        case 'armor::helmet':\n          delete newState.equippedItems.armor.helmet;\n          break;\n\n        case 'armor::pants':\n          delete newState.equippedItems.armor.pants;\n          break;\n\n        case 'armor::boots':\n          delete newState.equippedItems.armor.boots;\n          break;\n\n        case 'armor::gloves':\n          delete newState.equippedItems.armor.gloves;\n          break;\n\n        case 'ring':\n          delete newState.equippedItems.ring;\n\n          break;\n\n        default:\n      }\n\n      return newState;\n\n    case 'EQUIP_ITEM':\n      newState = _cloneDeep(state);\n      const item = payload;\n      // see what type of item it is\n      switch (item.type) {\n        case 'weapon':\n          if (newState.equippedItems.weapon && newState.equippedItems.weapon.effect) {\n            removeEffects(newState.equippedItems.weapon, newState);\n          }\n          newState.equippedItems.weapon = item;\n          break;\n\n        case 'armor::body':\n          if (\n            newState.equippedItems.armor &&\n            newState.equippedItems.armor.body &&\n            newState.equippedItems.armor.body.effect\n          ) {\n            removeEffects(newState.equippedItems.armor.body, newState);\n          }\n          // if there's already armor\n          // safely add new armor peice to object\n          newState.equippedItems.armor = {\n            ...newState.equippedItems.armor,\n            body: item,\n          };\n          break;\n\n        case 'armor::helmet':\n          // if there's already armor\n          if (\n            newState.equippedItems.armor &&\n            newState.equippedItems.armor.helmet &&\n            newState.equippedItems.armor.helmet.effect\n          ) {\n            removeEffects(newState.equippedItems.armor.helmet, newState);\n          }\n          // safely add new armor peice to object\n          newState.equippedItems.armor = {\n            ...newState.equippedItems.armor,\n            helmet: item,\n          };\n          break;\n\n        case 'armor::pants':\n          // if there's already armor\n          if (\n            newState.equippedItems.armor &&\n            newState.equippedItems.armor.pants &&\n            newState.equippedItems.armor.pants.effect\n          ) {\n            removeEffects(newState.equippedItems.armor.pants, newState);\n          }\n          // safely add new armor peice to object\n          newState.equippedItems.armor = {\n            ...newState.equippedItems.armor,\n            pants: item,\n          };\n          break;\n\n        case 'armor::gloves':\n          // if there's already armor\n          if (\n            newState.equippedItems.armor &&\n            newState.equippedItems.armor.gloves &&\n            newState.equippedItems.armor.gloves.effect\n          ) {\n            removeEffects(newState.equippedItems.armor.gloves, newState);\n          }\n          // safely add new armor peice to object\n          newState.equippedItems.armor = {\n            ...newState.equippedItems.armor,\n            gloves: item,\n          };\n          break;\n\n        case 'armor::boots':\n          // if there's already armor\n          if (\n            newState.equippedItems.armor &&\n            newState.equippedItems.armor.boots &&\n            newState.equippedItems.armor.boots.effect\n          ) {\n            removeEffects(newState.equippedItems.armor.boots, newState);\n          }\n          // safely add new armor peice to object\n          newState.equippedItems.armor = {\n            ...newState.equippedItems.armor,\n            boots: item,\n          };\n          break;\n\n        case 'ring':\n          const equippedRing = newState.equippedItems.ring;\n          // if there's already a ring\n          if (equippedRing) {\n            // subtract it's benefits\n            Object.keys(equippedRing.effect).forEach((effectName) => {\n              switch (effectName) {\n                case 'defence':\n                  newState.defence -= equippedRing.effect[effectName];\n                  break;\n\n                case 'hp':\n                  newState.hp -= equippedRing.effect[effectName];\n                  if (newState.hp < 1) newState.hp = 1;\n                  newState.maxHp -= equippedRing.effect[effectName];\n                  break;\n\n                default:\n              }\n            });\n          }\n\n          newState.equippedItems.ring = item;\n          break;\n\n        default:\n      }\n\n      // iterate over each new effect\n      Object.keys(item.effect).forEach((effectName) => {\n        switch (effectName) {\n          case 'defence':\n            newState.defence += item.effect[effectName];\n            break;\n\n          case 'hp':\n            newState.hp += item.effect[effectName];\n            newState.maxHp += item.effect[effectName];\n            break;\n\n          case 'mana':\n            newState.mana += payload.effect[effectName];\n            newState.maxMana += payload.effect[effectName];\n            break;\n\n          default:\n        }\n      });\n      return newState;\n\n    case 'HEAL_HP':\n      // heal the hp\n      let _hp = state.hp + payload;\n      // dont go above max hp\n      if (_hp > state.maxHp) _hp = state.maxHp;\n\n      return { ...state, hp: _hp };\n\n    case 'RESTORE_MANA':\n      // regenerate the mana\n      let _mana = state.mana + payload.amount;\n      // don't go above max mana\n      if (_mana > state.maxMana) _mana = state.maxMana;\n\n      return { ...state, mana: _mana };\n\n    case 'CAST_SPELL':\n      return { ...state, mana: state.mana - payload.projectile.manaCost };\n\n    case 'DAMAGE_TO_PLAYER':\n      return { ...state, hp: state.hp - payload.damage };\n\n    case 'GET_EXP':\n      newState = _cloneDeep(state);\n\n      const newTotalExp = state.exp + payload;\n      const { expToLevel } = state;\n      // if they are leveling up\n      if (newTotalExp >= expToLevel) {\n        // increment level\n        newState.level += 1;\n\n        // calculate leftover exp if it isn't exactly enough\n        if (!(newState.exp === expToLevel)) {\n          const leftoverExp = newTotalExp % expToLevel;\n          newState.exp = leftoverExp;\n        }\n\n        // set next exp goal to be 1.5 times as much if player is 5 or less\n        if (newState.level < 6) {\n          newState.expToLevel = Math.floor(state.expToLevel * 1.5);\n        } // otherwise set it to be 1.25 times as much\n        else if (newState.level < 20) {\n          newState.expToLevel = Math.floor(state.expToLevel * 1.25);\n        } else {\n        } // let the exp goal remain static if they are lv 20+\n\n        // calculate new hp\n        const newAbilityModifierHp = calculateMaxHpPool(\n          newState.level,\n          calculateModifier(state.abilities.constitution)\n        );\n        newState.levelUp.hp = newAbilityModifierHp - state.abilityModifierHp;\n        newState.hp += newState.levelUp.hp;\n        newState.maxHp += newState.levelUp.hp;\n        newState.abilityModifierHp = newAbilityModifierHp;\n\n        // calculate new mana\n        const newAbilityModifierMana = calculateMaxManaPool(\n          newState.level,\n          calculateModifier(state.abilities.intelligence)\n        );\n        newState.levelUp.mana = newAbilityModifierMana - state.abilityModifierMana;\n        newState.mana += newState.levelUp.mana;\n        newState.maxMana += newState.levelUp.mana;\n        newState.abilityModifierMana = newAbilityModifierMana;\n\n        newState.levelUp.level = newState.level;\n      } else {\n        // they aren't leveling up\n        newState.exp += payload;\n      }\n\n      return newState;\n\n    case 'RESET':\n      return initialState;\n\n    case 'LOAD_DATA':\n      return { ...initialState, ...payload.stats };\n\n    default:\n      return state;\n  }\n};\n\nconst removeEffects = (item, newState) => {\n  Object.keys(item.effect).forEach((effectName) => {\n    switch (effectName) {\n      case 'defence':\n        newState.defence -= item.effect[effectName];\n        break;\n\n      case 'hp':\n        newState.hp -= item.effect[effectName];\n        if (newState.hp < 1) newState.hp = 1;\n        newState.maxHp -= item.effect[effectName];\n        break;\n\n      case 'mana':\n        newState.mana -= item.effect[effectName];\n        if (newState.mana < 1) newState.mana = 1;\n        newState.maxMana -= item.effect[effectName];\n        break;\n\n      default:\n    }\n  });\n};\n\nexport default statsReducer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}