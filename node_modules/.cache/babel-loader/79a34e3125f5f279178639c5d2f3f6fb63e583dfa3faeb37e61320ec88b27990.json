{"ast":null,"code":"import { getNewPosition } from '../../player/actions/move-player';\nimport getNextTile from '../../../utils/get-next-tile';\nimport { SPRITE_SIZE } from '../../../config/constants';\nimport { radiusTiles } from '../../../utils/get-surrounding-tiles';\nconst MONSTER_ATTACK_RADIUS = 1;\nexport function getRandomDirection() {\n  const directions = ['up', 'down', 'left', 'right'];\n  const randomNumber = Math.floor(Math.random() * directions.length);\n  return directions[randomNumber];\n}\nexport const playerInView = (monsterPosition, range) => {\n  return (dispatch, getState) => {\n    const {\n      position\n    } = getState().player;\n    monsterPosition = monsterPosition.map(val => val * SPRITE_SIZE);\n    range *= SPRITE_SIZE;\n    for (let y = monsterPosition[1]; y > monsterPosition[1] - range; y -= SPRITE_SIZE) {\n      const pos = getNewPosition([monsterPosition[0], y], 'NORTH');\n      if (!dispatch(observeImpassable(pos))) break;\n      if (position[0] === pos[0] && position[1] === pos[1]) {\n        return true;\n      }\n    }\n    for (let y = monsterPosition[1]; y < monsterPosition[1] + range; y += SPRITE_SIZE) {\n      const pos = getNewPosition([monsterPosition[0], y], 'SOUTH');\n      if (!dispatch(observeImpassable(pos))) break;\n      if (position[0] === pos[0] && position[1] === pos[1]) {\n        return true;\n      }\n    }\n    for (let x = monsterPosition[0]; x < monsterPosition[0] + range; x += SPRITE_SIZE) {\n      const pos = getNewPosition([x, monsterPosition[1]], 'EAST');\n      if (!dispatch(observeImpassable(pos))) break;\n      if (position[0] === pos[0] && position[1] === pos[1]) {\n        return true;\n      }\n    }\n    for (let x = monsterPosition[0]; x > monsterPosition[0] - range; x -= SPRITE_SIZE) {\n      const pos = getNewPosition([x, monsterPosition[1]], 'WEST');\n      if (!dispatch(observeImpassable(pos))) break;\n      if (position[0] === pos[0] && position[1] === pos[1]) {\n        return true;\n      }\n    }\n    return false;\n  };\n};\nexport function playerInRange(playerPos, monsterPos) {\n  let range = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MONSTER_ATTACK_RADIUS;\n  let inRange = false;\n  // for each tile around the monster\n  radiusTiles(range).forEach(tile => {\n    // add the monsters location\n    const offsetX = tile.x + monsterPos[0];\n    const offsetY = tile.y + monsterPos[1];\n    // see if the player is in range\n    const playerLocation = playerPos.map(value => value / SPRITE_SIZE);\n    if (JSON.stringify([offsetX, offsetY]) === JSON.stringify(playerLocation)) {\n      inRange = true;\n    }\n  });\n  return inRange;\n}\nexport function observeImpassable(newPos) {\n  return (_, getState) => {\n    const nextTile = getNextTile(getState().world, newPos);\n    return nextTile < 5 ? newPos : false;\n  };\n}\n\n/**\n * Check to see if any other monster is at the position this monster is trying to move to\n *\n * @param {*} id The id of the monster that's trying to move\n * @param {*} position The position its moving to\n * @param {*} currentMap THe map that the monsrer is in\n */\nexport function checkForOtherMonster(id, position, currentMap) {\n  return (_, getState) => {\n    // get current monsters\n    const monsterList = getState().monsters.components[currentMap];\n    // check list of monsters\n    return Object.keys(monsterList).filter(monsterID => {\n      const monster = monsterList[monsterID];\n      // see if there's another monster in the next position\n      return monsterID !== id && monster.position[0] === position[0] && monster.position[1] === position[1];\n    }).pop();\n  };\n}","map":{"version":3,"names":["getNewPosition","getNextTile","SPRITE_SIZE","radiusTiles","MONSTER_ATTACK_RADIUS","getRandomDirection","directions","randomNumber","Math","floor","random","length","playerInView","monsterPosition","range","dispatch","getState","position","player","map","val","y","pos","observeImpassable","x","playerInRange","playerPos","monsterPos","arguments","undefined","inRange","forEach","tile","offsetX","offsetY","playerLocation","value","JSON","stringify","newPos","_","nextTile","world","checkForOtherMonster","id","currentMap","monsterList","monsters","components","Object","keys","filter","monsterID","monster","pop"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/monsters/actions/move-monster.jsx"],"sourcesContent":["import { getNewPosition } from '../../player/actions/move-player';\nimport getNextTile from '../../../utils/get-next-tile';\nimport { SPRITE_SIZE } from '../../../config/constants';\nimport { radiusTiles } from '../../../utils/get-surrounding-tiles';\n\nconst MONSTER_ATTACK_RADIUS = 1;\nexport function getRandomDirection() {\n    const directions = ['up', 'down', 'left', 'right'];\n    const randomNumber = Math.floor(Math.random() * directions.length);\n    return directions[randomNumber];\n}\n\nexport const playerInView = (monsterPosition, range) => {\n    return (dispatch, getState) => {\n        const { position } = getState().player;\n\n        monsterPosition = monsterPosition.map(val => val * SPRITE_SIZE);\n        range *= SPRITE_SIZE;\n\n        for (\n            let y = monsterPosition[1];\n            y > monsterPosition[1] - range;\n            y -= SPRITE_SIZE\n        ) {\n            const pos = getNewPosition([monsterPosition[0], y], 'NORTH');\n            if (!dispatch(observeImpassable(pos))) break;\n            if (position[0] === pos[0] && position[1] === pos[1]) {\n                return true;\n            }\n        }\n        for (\n            let y = monsterPosition[1];\n            y < monsterPosition[1] + range;\n            y += SPRITE_SIZE\n        ) {\n            const pos = getNewPosition([monsterPosition[0], y], 'SOUTH');\n            if (!dispatch(observeImpassable(pos))) break;\n            if (position[0] === pos[0] && position[1] === pos[1]) {\n                return true;\n            }\n        }\n\n        for (\n            let x = monsterPosition[0];\n            x < monsterPosition[0] + range;\n            x += SPRITE_SIZE\n        ) {\n            const pos = getNewPosition([x, monsterPosition[1]], 'EAST');\n            if (!dispatch(observeImpassable(pos))) break;\n            if (position[0] === pos[0] && position[1] === pos[1]) {\n                return true;\n            }\n        }\n\n        for (\n            let x = monsterPosition[0];\n            x > monsterPosition[0] - range;\n            x -= SPRITE_SIZE\n        ) {\n            const pos = getNewPosition([x, monsterPosition[1]], 'WEST');\n            if (!dispatch(observeImpassable(pos))) break;\n            if (position[0] === pos[0] && position[1] === pos[1]) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n};\n\nexport function playerInRange(\n    playerPos,\n    monsterPos,\n    range = MONSTER_ATTACK_RADIUS\n) {\n    let inRange = false;\n    // for each tile around the monster\n    radiusTiles(range).forEach(tile => {\n        // add the monsters location\n        const offsetX = tile.x + monsterPos[0];\n        const offsetY = tile.y + monsterPos[1];\n        // see if the player is in range\n        const playerLocation = playerPos.map(value => value / SPRITE_SIZE);\n        if (\n            JSON.stringify([offsetX, offsetY]) ===\n            JSON.stringify(playerLocation)\n        ) {\n            inRange = true;\n        }\n    });\n    return inRange;\n}\n\nexport function observeImpassable(newPos) {\n    return (_, getState) => {\n        const nextTile = getNextTile(getState().world, newPos);\n\n        return nextTile < 5 ? newPos : false;\n    };\n}\n\n/**\n * Check to see if any other monster is at the position this monster is trying to move to\n *\n * @param {*} id The id of the monster that's trying to move\n * @param {*} position The position its moving to\n * @param {*} currentMap THe map that the monsrer is in\n */\nexport function checkForOtherMonster(id, position, currentMap) {\n    return (_, getState) => {\n        // get current monsters\n        const monsterList = getState().monsters.components[currentMap];\n        // check list of monsters\n        return Object.keys(monsterList)\n            .filter(monsterID => {\n                const monster = monsterList[monsterID];\n                // see if there's another monster in the next position\n                return (\n                    monsterID !== id &&\n                    monster.position[0] === position[0] &&\n                    monster.position[1] === position[1]\n                );\n            })\n            .pop();\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}