{"ast":null,"code":"import { calculateDamage } from '../../../utils/dice';\nimport { SPRITE_SIZE } from '../../../config/constants';\nexport default function attackPlayer(monster) {\n  return (dispatch, getState) => {\n    const {\n      stats,\n      player\n    } = getState();\n    const {\n      attackValue,\n      dice,\n      type,\n      projectile,\n      position\n    } = monster;\n    const attack = calculateDamage(attackValue);\n    const calculatedMonsterDamage = attack >= Math.max(stats.defence, 0) ? calculateDamage(dice) : 0;\n    if (projectile && !projectile.target.includes('self')) {\n      let direction = '';\n      const targetPosition = [position[0] - player.position[0], position[1] - player.position[1]];\n      if (player.position[0] !== position[0]) {\n        if (player.position[0] < position[0]) {\n          direction = 'WEST';\n          targetPosition[0] -= SPRITE_SIZE;\n        } else {\n          direction = 'EAST';\n          targetPosition[0] += SPRITE_SIZE;\n        }\n      } else if (player.position[1] !== position[1]) {\n        if (player.position[1] < position[1]) {\n          direction = 'NORTH';\n          targetPosition[1] -= SPRITE_SIZE;\n        } else {\n          direction = 'SOUTH';\n          targetPosition[1] += SPRITE_SIZE;\n        }\n      }\n      dispatch({\n        type: 'MONSTER_USE_PROJECTILE',\n        payload: {\n          position: targetPosition,\n          projectile,\n          direction,\n          entity: type\n        }\n      });\n    }\n    dispatch({\n      type: 'MONSTER_ABILITY_CHECK',\n      payload: {\n        attackValue: attack,\n        check: Math.max(stats.defence, 0),\n        against: 'defence',\n        entity: type,\n        defender: 'player'\n      }\n    });\n    if (calculatedMonsterDamage > 0) {\n      // show the attack animation and play sound\n      dispatch({\n        type: 'MONSTER_ATTACK',\n        payload: null\n      });\n    }\n    dispatch({\n      type: 'DAMAGE_TO_PLAYER',\n      payload: {\n        damage: calculatedMonsterDamage,\n        entity: type\n      }\n    });\n\n    // check if player died\n    if (stats.hp - calculatedMonsterDamage <= 0) {\n      // play death sound\n      dispatch({\n        type: 'PLAYER_DIED',\n        payload: {\n          entity: type\n        }\n      });\n      // if it did, game over\n      dispatch({\n        type: 'PAUSE',\n        payload: {\n          gameOver: true,\n          pause: true\n        }\n      });\n    }\n  };\n}","map":{"version":3,"names":["calculateDamage","SPRITE_SIZE","attackPlayer","monster","dispatch","getState","stats","player","attackValue","dice","type","projectile","position","attack","calculatedMonsterDamage","Math","max","defence","target","includes","direction","targetPosition","payload","entity","check","against","defender","damage","hp","gameOver","pause"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/monsters/actions/attack-player.jsx"],"sourcesContent":["import { calculateDamage } from '../../../utils/dice';\nimport { SPRITE_SIZE } from '../../../config/constants';\n\nexport default function attackPlayer(monster) {\n  return (dispatch, getState) => {\n    const { stats, player } = getState();\n    const { attackValue, dice, type, projectile, position } = monster;\n\n    const attack = calculateDamage(attackValue);\n\n    const calculatedMonsterDamage =\n      attack >= Math.max(stats.defence, 0) ? calculateDamage(dice) : 0;\n\n    if (projectile && !projectile.target.includes('self')) {\n      let direction = '';\n      const targetPosition = [position[0] - player.position[0], position[1] - player.position[1]];\n\n      if (player.position[0] !== position[0]) {\n        if (player.position[0] < position[0]) {\n          direction = 'WEST';\n          targetPosition[0] -= SPRITE_SIZE;\n        } else {\n          direction = 'EAST';\n          targetPosition[0] += SPRITE_SIZE;\n        }\n      } else if (player.position[1] !== position[1]) {\n        if (player.position[1] < position[1]) {\n          direction = 'NORTH';\n          targetPosition[1] -= SPRITE_SIZE;\n        } else {\n          direction = 'SOUTH';\n          targetPosition[1] += SPRITE_SIZE;\n        }\n      }\n      dispatch({\n        type: 'MONSTER_USE_PROJECTILE',\n        payload: {\n          position: targetPosition,\n          projectile,\n          direction,\n          entity: type,\n        },\n      });\n    }\n\n    dispatch({\n      type: 'MONSTER_ABILITY_CHECK',\n      payload: {\n        attackValue: attack,\n        check: Math.max(stats.defence, 0),\n        against: 'defence',\n        entity: type,\n        defender: 'player',\n      },\n    });\n\n    if (calculatedMonsterDamage > 0) {\n      // show the attack animation and play sound\n      dispatch({\n        type: 'MONSTER_ATTACK',\n        payload: null,\n      });\n    }\n\n    dispatch({\n      type: 'DAMAGE_TO_PLAYER',\n      payload: { damage: calculatedMonsterDamage, entity: type },\n    });\n\n    // check if player died\n    if (stats.hp - calculatedMonsterDamage <= 0) {\n      // play death sound\n      dispatch({\n        type: 'PLAYER_DIED',\n        payload: { entity: type },\n      });\n      // if it did, game over\n      dispatch({\n        type: 'PAUSE',\n        payload: {\n          gameOver: true,\n          pause: true,\n        },\n      });\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}