{"ast":null,"code":"import { calculateDamage } from '../../../utils/dice';\nimport { SPRITE_SIZE } from '../../../config/constants';\nexport default function attackMonster(attackingMonster, defendingMonsterID, currentMap) {\n  return (dispatch, getState) => {\n    const defender = getState().monsters.components[currentMap][defendingMonsterID];\n    const {\n      dice,\n      attackValue\n    } = attackingMonster;\n    const {\n      defence,\n      type,\n      hp,\n      position\n    } = defender;\n    const attack = calculateDamage(attackValue);\n    const calculatedMonsterDamage = attack >= Math.max(defence, 0) ? calculateDamage(dice) : 0;\n    dispatch({\n      type: 'MONSTER_ABILITY_CHECK',\n      payload: {\n        attackValue: attack,\n        check: Math.max(defence, 0),\n        against: 'defence',\n        entity: attackingMonster.type,\n        defender: type\n      }\n    });\n    if (calculatedMonsterDamage > 0) {\n      // show the attack animation and play sound\n      dispatch({\n        type: 'MONSTER_ATTACK',\n        payload: null\n      });\n    }\n    dispatch({\n      type: 'DAMAGE_TO_MONSTER',\n      payload: {\n        damage: calculatedMonsterDamage,\n        id: defendingMonsterID,\n        map: currentMap,\n        from: attackingMonster.type,\n        entity: type\n      }\n    });\n\n    // check if player died\n    if (hp - calculatedMonsterDamage <= 0) {\n      dispatch({\n        type: 'MONSTER_DIED',\n        payload: type\n      });\n\n      // replace monster will blood spill\n      // need to pass relative tile index\n      dispatch({\n        type: 'ADD_BLOOD_SPILL',\n        payload: {\n          x: position[0] / SPRITE_SIZE,\n          y: position[1] / SPRITE_SIZE\n        }\n      });\n    }\n  };\n}","map":{"version":3,"names":["calculateDamage","SPRITE_SIZE","attackMonster","attackingMonster","defendingMonsterID","currentMap","dispatch","getState","defender","monsters","components","dice","attackValue","defence","type","hp","position","attack","calculatedMonsterDamage","Math","max","payload","check","against","entity","damage","id","map","from","x","y"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/monsters/actions/attack-monster.jsx"],"sourcesContent":["import { calculateDamage } from '../../../utils/dice';\nimport { SPRITE_SIZE } from '../../../config/constants';\n\nexport default function attackMonster(attackingMonster, defendingMonsterID, currentMap) {\n  return (dispatch, getState) => {\n    const defender = getState().monsters.components[currentMap][defendingMonsterID];\n\n    const { dice, attackValue } = attackingMonster;\n    const { defence, type, hp, position } = defender;\n\n    const attack = calculateDamage(attackValue);\n    const calculatedMonsterDamage = attack >= Math.max(defence, 0) ? calculateDamage(dice) : 0;\n\n    dispatch({\n      type: 'MONSTER_ABILITY_CHECK',\n      payload: {\n        attackValue: attack,\n        check: Math.max(defence, 0),\n        against: 'defence',\n        entity: attackingMonster.type,\n        defender: type,\n      },\n    });\n\n    if (calculatedMonsterDamage > 0) {\n      // show the attack animation and play sound\n      dispatch({\n        type: 'MONSTER_ATTACK',\n        payload: null,\n      });\n    }\n\n    dispatch({\n      type: 'DAMAGE_TO_MONSTER',\n      payload: {\n        damage: calculatedMonsterDamage,\n        id: defendingMonsterID,\n        map: currentMap,\n        from: attackingMonster.type,\n        entity: type,\n      },\n    });\n\n    // check if player died\n    if (hp - calculatedMonsterDamage <= 0) {\n      dispatch({\n        type: 'MONSTER_DIED',\n        payload: type,\n      });\n\n      // replace monster will blood spill\n      // need to pass relative tile index\n      dispatch({\n        type: 'ADD_BLOOD_SPILL',\n        payload: {\n          x: position[0] / SPRITE_SIZE,\n          y: position[1] / SPRITE_SIZE,\n        },\n      });\n    }\n  };\n}\n"],"mappings":"AAAA,SAASA,eAAe,QAAQ,qBAAqB;AACrD,SAASC,WAAW,QAAQ,2BAA2B;AAEvD,eAAe,SAASC,aAAaA,CAACC,gBAAgB,EAAEC,kBAAkB,EAAEC,UAAU,EAAE;EACtF,OAAO,CAACC,QAAQ,EAAEC,QAAQ,KAAK;IAC7B,MAAMC,QAAQ,GAAGD,QAAQ,CAAC,CAAC,CAACE,QAAQ,CAACC,UAAU,CAACL,UAAU,CAAC,CAACD,kBAAkB,CAAC;IAE/E,MAAM;MAAEO,IAAI;MAAEC;IAAY,CAAC,GAAGT,gBAAgB;IAC9C,MAAM;MAAEU,OAAO;MAAEC,IAAI;MAAEC,EAAE;MAAEC;IAAS,CAAC,GAAGR,QAAQ;IAEhD,MAAMS,MAAM,GAAGjB,eAAe,CAACY,WAAW,CAAC;IAC3C,MAAMM,uBAAuB,GAAGD,MAAM,IAAIE,IAAI,CAACC,GAAG,CAACP,OAAO,EAAE,CAAC,CAAC,GAAGb,eAAe,CAACW,IAAI,CAAC,GAAG,CAAC;IAE1FL,QAAQ,CAAC;MACPQ,IAAI,EAAE,uBAAuB;MAC7BO,OAAO,EAAE;QACPT,WAAW,EAAEK,MAAM;QACnBK,KAAK,EAAEH,IAAI,CAACC,GAAG,CAACP,OAAO,EAAE,CAAC,CAAC;QAC3BU,OAAO,EAAE,SAAS;QAClBC,MAAM,EAAErB,gBAAgB,CAACW,IAAI;QAC7BN,QAAQ,EAAEM;MACZ;IACF,CAAC,CAAC;IAEF,IAAII,uBAAuB,GAAG,CAAC,EAAE;MAC/B;MACAZ,QAAQ,CAAC;QACPQ,IAAI,EAAE,gBAAgB;QACtBO,OAAO,EAAE;MACX,CAAC,CAAC;IACJ;IAEAf,QAAQ,CAAC;MACPQ,IAAI,EAAE,mBAAmB;MACzBO,OAAO,EAAE;QACPI,MAAM,EAAEP,uBAAuB;QAC/BQ,EAAE,EAAEtB,kBAAkB;QACtBuB,GAAG,EAAEtB,UAAU;QACfuB,IAAI,EAAEzB,gBAAgB,CAACW,IAAI;QAC3BU,MAAM,EAAEV;MACV;IACF,CAAC,CAAC;;IAEF;IACA,IAAIC,EAAE,GAAGG,uBAAuB,IAAI,CAAC,EAAE;MACrCZ,QAAQ,CAAC;QACPQ,IAAI,EAAE,cAAc;QACpBO,OAAO,EAAEP;MACX,CAAC,CAAC;;MAEF;MACA;MACAR,QAAQ,CAAC;QACPQ,IAAI,EAAE,iBAAiB;QACvBO,OAAO,EAAE;UACPQ,CAAC,EAAEb,QAAQ,CAAC,CAAC,CAAC,GAAGf,WAAW;UAC5B6B,CAAC,EAAEd,QAAQ,CAAC,CAAC,CAAC,GAAGf;QACnB;MACF,CAAC,CAAC;IACJ;EACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}