{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\devis\\\\Downloads\\\\react-rpg.com-master\\\\src\\\\features\\\\player\\\\index.jsx\";\nimport React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport ReactTimeout from 'react-timeout';\nimport Sound from 'react-sound';\nimport MonsterAttack from '../monsters/assets/monster-attack.wav';\nimport MonsterDeath from '../monsters/assets/monster-death.wav';\nimport MonsterSlash from '../monsters/assets/monster-slash.png';\nimport PlayerDeath from './assets/player-death.mp3';\nimport SwordSlash from './assets/sword-slash.png';\nimport PlayerStep from './assets/player-step.wav';\nimport SwordSwish from './assets/player-sword-swish.wav';\nimport Animation from '../../components/animation';\nimport PlayerHair from './assets/player-hair.png';\nimport PlayerEyes from './assets/player-eyes.png';\nimport PlayerSkin from './assets/player-skin.png';\nimport PlayerArmour from './assets/player-armour.png';\nimport PlayerClothes from './assets/player-clothes.png';\nimport PlayerOutline from './assets/player-outline.png';\nimport { ANIMATION_SPEED, SPRITE_SIZE, FISTS, HUE_OFFSETS } from '../../config/constants';\nimport './styles.scss';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nclass Player extends Component {\n  constructor(props) {\n    super(props);\n    this.canvasRef = /*#__PURE__*/React.createRef();\n    this.directionMap = {\n      SOUTH: 0,\n      // facing down, line 1 of spritesheet\n      NORTH: 1,\n      // facinf up, line 2 of spritesheet\n      WEST: 2,\n      // facing left, line 3 of spritesheet\n      EAST: 3 // facing right, line 4 of spritesheet\n    };\n    this.state = {\n      attackAnimationPlay: 'paused',\n      attackAnimationLoc: [0, 0],\n      animationWalkSound: null,\n      animationAttackSound: null,\n      monsterAttackAnimationPlay: 'paused',\n      monsterAnimationAttackSound: null,\n      monsterProjectileAnimation: null,\n      monsterDeath: null,\n      playerDeath: null,\n      leftSideStride: true,\n      stamp: 0\n    };\n  }\n  avatar(action) {\n    let dir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (this.canvasRef && this.canvasRef.current) {\n      const ctx = this.canvasRef.current.getContext('2d');\n      const spriteLine = dir * SPRITE_SIZE;\n      let currentFrame = this.state.leftSideStride ? 0 : 5;\n      let currentTick = 0;\n      const ticksPerFrame = 5;\n      const {\n        hairColour,\n        skinColour,\n        armourColour,\n        clothesColour\n      } = this.props.dialog.appearance;\n      const colours = [['hair', \"hue-rotate(\".concat(hairColour + HUE_OFFSETS.hairColour, \"deg)\")], ['skin', \"hue-rotate(\".concat(skinColour + HUE_OFFSETS.skinColour, \"deg)\")], ['armour', \"hue-rotate(\".concat(armourColour + HUE_OFFSETS.armourColour, \"deg)\")], ['clothes', \"hue-rotate(\".concat(clothesColour + HUE_OFFSETS.clothesColour, \"deg)\")], ['outline', 'none'], ['eyes', 'none']];\n      const draw = frame => {\n        // don't allow invalid frames\n        if (frame > 7 || frame < 0) frame = 0;\n        ctx.clearRect(0, 0, SPRITE_SIZE, SPRITE_SIZE);\n        colours.forEach(colour => {\n          ctx.filter = colour[1];\n          ctx.drawImage(this.sprite[colour[0]], frame * SPRITE_SIZE, spriteLine, SPRITE_SIZE, SPRITE_SIZE, 0, 0, SPRITE_SIZE, SPRITE_SIZE);\n        });\n      };\n      const update = () => {\n        currentTick += 1;\n        if (currentTick > ticksPerFrame) {\n          currentTick = 0;\n          currentFrame += 1;\n        }\n      };\n      const main = () => {\n        draw(currentFrame);\n        update();\n        const id = window.requestAnimationFrame(main);\n        if (this.state.leftSideStride && currentFrame > 4) {\n          window.cancelAnimationFrame(id);\n        }\n        if (!this.state.leftSideStride && currentFrame > 8) {\n          window.cancelAnimationFrame(id);\n        }\n      };\n      if (action === 'draw') {\n        draw(0);\n      }\n      if (action === 'animate') {\n        main();\n      }\n    }\n  }\n  componentDidMount() {\n    this.sprite = {\n      hair: new Image(),\n      eyes: new Image(),\n      skin: new Image(),\n      armour: new Image(),\n      clothes: new Image(),\n      outline: new Image()\n    };\n    this.sprite.hair.src = PlayerHair;\n    this.sprite.eyes.src = PlayerEyes;\n    this.sprite.skin.src = PlayerSkin;\n    this.sprite.armour.src = PlayerArmour;\n    this.sprite.clothes.src = PlayerClothes;\n    this.sprite.outline.src = PlayerOutline;\n    this.sprite.onload = () => {\n      this.avatar('draw', this.directionMap[this.props.player.direction]);\n    };\n  }\n\n  // this is used to tell when to animate the player\n  componentDidUpdate(prevProps, prevState) {\n    this.avatar('draw', this.directionMap[this.props.player.direction]);\n\n    // detemine when the player has moved\n    if (prevProps.player.playerMoved !== this.props.player.playerMoved && this.state.stamp + ANIMATION_SPEED < Date.now()) {\n      let animationWalkSound = null;\n      if (this.props.gameMenu.sound) {\n        animationWalkSound = /*#__PURE__*/_jsxDEV(Sound, {\n          url: PlayerStep,\n          playStatus: 'PLAYING',\n          autoLoad: true,\n          volume: 100\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 161,\n          columnNumber: 21\n        }, this);\n      }\n      this.setState({\n        stamp: Date.now(),\n        animationWalkSound,\n        leftSideStride: !this.state.leftSideStride\n      }, () => {\n        this.avatar('animate', this.directionMap[this.props.player.direction]);\n      });\n    }\n    // see if player died\n    else if (prevProps.player.playerDied !== this.props.player.playerDied) {\n      let playerDeath = null;\n      if (this.props.gameMenu.sound) {\n        playerDeath = /*#__PURE__*/_jsxDEV(Sound, {\n          url: PlayerDeath,\n          playStatus: 'PLAYING',\n          autoLoad: true,\n          volume: 100\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 188,\n          columnNumber: 21\n        }, this);\n      }\n      // player the player death sound after\n      this.props.setTimeout(() => this.setState({\n        playerDeath\n      }), ANIMATION_SPEED);\n      // pause the infinite animation after 1 iteration\n      this.props.setTimeout(() => this.setState({\n        playerDeath: null\n      }), ANIMATION_SPEED + ANIMATION_SPEED * 4);\n    }\n    // see if a monster died\n    else if (prevProps.player.monsterDied !== this.props.player.monsterDied) {\n      let monsterDeath = null;\n      if (this.props.gameMenu.sound) {\n        monsterDeath = /*#__PURE__*/_jsxDEV(Sound, {\n          url: MonsterDeath,\n          playStatus: 'PLAYING',\n          autoLoad: true,\n          volume: 100\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 214,\n          columnNumber: 21\n        }, this);\n      }\n      // play the monster death sound after delay\n      this.props.setTimeout(() => this.setState({\n        monsterDeath\n      }), ANIMATION_SPEED);\n      // pause the infinite animation after 1 iteration and the delay\n      this.props.setTimeout(() => this.setState({\n        monsterDeath: null\n      }), ANIMATION_SPEED + ANIMATION_SPEED * 3.5);\n    }\n    // see if a monster attacked the player\n    else if (prevProps.player.monsterAttacked !== this.props.player.monsterAttacked || prevProps.player.monsterUseProjectile !== this.props.player.monsterUseProjectile) {\n      let monsterAnimationAttackSound = null;\n      let monsterProjectileAnimation = null;\n      if (this.props.gameMenu.sound) {\n        monsterAnimationAttackSound = /*#__PURE__*/_jsxDEV(Sound, {\n          url: MonsterAttack,\n          playStatus: 'PLAYING',\n          autoLoad: true,\n          volume: 100\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 244,\n          columnNumber: 21\n        }, this);\n      }\n      if (prevProps.player.monsterUseProjectile !== this.props.player.monsterUseProjectile) {\n        // A monster used a projectile, so we need to show that\n        monsterProjectileAnimation = /*#__PURE__*/_jsxDEV(Animation, {\n          projectile: this.props.player.monsterProjectile,\n          startPosition: [this.props.player.monsterProjectileTargetPosition[0] - this.props.player.position[0], this.props.player.monsterProjectileTargetPosition[1] - this.props.player.position[1]],\n          endPosition: this.props.player.monsterProjectile.target.includes('self') ? this.props.player.monsterProjectileTargetPosition // If they're tartgetting themselves, then use their position\n          : [0, 0] // Otherwise it's targetting the player\n          ,\n          direction: this.props.player.monsterProjectileDirection\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 259,\n          columnNumber: 21\n        }, this);\n      }\n\n      // animate the player\n      this.setState({\n        monsterAttackAnimationPlay: 'running',\n        monsterAnimationAttackSound,\n        monsterProjectileAnimation\n      });\n      // pause the infinite animation after 1 iteration plus delay time (250ms)\n      this.props.setTimeout(() => this.setState({\n        monsterAttackAnimationPlay: 'paused',\n        monsterAnimationAttackSound: null,\n        monsterProjectileAnimation: null\n      }), ANIMATION_SPEED + 250);\n    }\n    // see if the player attacked\n    else if (prevProps.player.spellCast !== this.props.player.spellCast) {\n      let attackAnimationLoc = [0, 0];\n      // calculate which way the sword should slash\n      switch (this.props.player.direction) {\n        case 'SOUTH':\n          attackAnimationLoc = [0, SPRITE_SIZE];\n          break;\n        case 'EAST':\n          attackAnimationLoc = [SPRITE_SIZE, 0];\n          break;\n        case 'WEST':\n          attackAnimationLoc = [-SPRITE_SIZE, 0];\n          break;\n        case 'NORTH':\n          attackAnimationLoc = [0, -SPRITE_SIZE];\n          break;\n        default:\n      }\n      let animationAttackSound = null;\n      if (this.props.gameMenu.sound) {\n        animationAttackSound = /*#__PURE__*/_jsxDEV(Sound, {\n          url: SwordSwish,\n          playStatus: 'PLAYING',\n          autoLoad: true,\n          volume: 100\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 319,\n          columnNumber: 21\n        }, this);\n      }\n      // animate the sword slash\n      this.setState({\n        attackAnimationPlay: 'spell',\n        attackAnimationLoc,\n        animationAttackSound\n      });\n      // pause the infinite animation after 1 iteration\n      this.props.setTimeout(() => this.setState({\n        attackAnimationPlay: 'paused',\n        animationAttackSound: null\n      }), ANIMATION_SPEED);\n    } else if (prevProps.player.playerAttacked !== this.props.player.playerAttacked) {\n      let attackAnimationLoc = [0, 0];\n      // calculate which way the sword should slash\n      switch (this.props.player.direction) {\n        case 'SOUTH':\n          attackAnimationLoc = [0, SPRITE_SIZE];\n          break;\n        case 'EAST':\n          attackAnimationLoc = [SPRITE_SIZE, 0];\n          break;\n        case 'WEST':\n          attackAnimationLoc = [-SPRITE_SIZE, 0];\n          break;\n        case 'NORTH':\n          attackAnimationLoc = [0, -SPRITE_SIZE];\n          break;\n        default:\n      }\n      let animationAttackSound = null;\n      if (this.props.gameMenu.sound) {\n        animationAttackSound = /*#__PURE__*/_jsxDEV(Sound, {\n          url: SwordSwish,\n          playStatus: 'PLAYING',\n          autoLoad: true,\n          volume: 100\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 365,\n          columnNumber: 21\n        }, this);\n      }\n      const weapon = this.props.stats.equippedItems.weapon || FISTS;\n\n      // animate the sword slash\n      this.setState({\n        attackAnimationPlay: weapon.kind || 'running',\n        attackAnimationLoc,\n        animationAttackSound\n      });\n      // pause the infinite animation after 1 iteration\n      this.props.setTimeout(() => this.setState({\n        attackAnimationPlay: 'paused',\n        animationAttackSound: null\n      }), ANIMATION_SPEED);\n    }\n  }\n  render() {\n    const {\n      attackAnimationPlay,\n      attackAnimationLoc,\n      animationWalkSound,\n      animationAttackSound,\n      monsterAnimationAttackSound,\n      monsterAttackAnimationPlay,\n      monsterProjectileAnimation,\n      monsterDeath,\n      playerDeath\n    } = this.state;\n    const {\n      player,\n      dialog,\n      stats\n    } = this.props;\n    const {\n      gameStart\n    } = dialog;\n    // game start menu open, hide the player\n    if (gameStart) return null;\n\n    // Determine what the projectile the player used was\n    const projectile = attackAnimationPlay === 'spell' ? player.spell : attackAnimationPlay === 'ranged' ? stats.equippedItems.weapon.projectile : null;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"player__animation\",\n      style: {\n        top: player.position[1],\n        left: player.position[0]\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: this.canvasRef,\n        width: 40,\n        height: 40\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 428,\n        columnNumber: 17\n      }, this), animationWalkSound, animationAttackSound, monsterAnimationAttackSound, monsterDeath, playerDeath, monsterProjectileAnimation, monsterAttackAnimationPlay === 'running' && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"monster__slash\",\n        style: {\n          backgroundImage: \"url('\".concat(MonsterSlash, \"')\")\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 438,\n        columnNumber: 21\n      }, this), attackAnimationPlay !== 'paused' && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"sword__slash\",\n        style: {\n          top: attackAnimationLoc[1],\n          left: attackAnimationLoc[0],\n          backgroundImage: \"url('\".concat(SwordSlash, \"')\")\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 445,\n        columnNumber: 21\n      }, this), projectile && /*#__PURE__*/_jsxDEV(Animation, {\n        projectile: projectile,\n        startPosition: attackAnimationLoc,\n        endPosition: [player.targetPosition[0] - player.position[0], player.targetPosition[1] - player.position[1]],\n        direction: player.direction\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 456,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 421,\n      columnNumber: 13\n    }, this);\n  }\n}\nconst mapStateToProps = _ref => {\n  let {\n    gameMenu,\n    player,\n    dialog,\n    stats\n  } = _ref;\n  return {\n    gameMenu,\n    player,\n    dialog,\n    stats\n  };\n};\nexport default connect(mapStateToProps)(ReactTimeout(Player));","map":{"version":3,"names":["React","Component","connect","ReactTimeout","Sound","MonsterAttack","MonsterDeath","MonsterSlash","PlayerDeath","SwordSlash","PlayerStep","SwordSwish","Animation","PlayerHair","PlayerEyes","PlayerSkin","PlayerArmour","PlayerClothes","PlayerOutline","ANIMATION_SPEED","SPRITE_SIZE","FISTS","HUE_OFFSETS","jsxDEV","_jsxDEV","Player","constructor","props","canvasRef","createRef","directionMap","SOUTH","NORTH","WEST","EAST","state","attackAnimationPlay","attackAnimationLoc","animationWalkSound","animationAttackSound","monsterAttackAnimationPlay","monsterAnimationAttackSound","monsterProjectileAnimation","monsterDeath","playerDeath","leftSideStride","stamp","avatar","action","dir","arguments","length","undefined","current","ctx","getContext","spriteLine","currentFrame","currentTick","ticksPerFrame","hairColour","skinColour","armourColour","clothesColour","dialog","appearance","colours","concat","draw","frame","clearRect","forEach","colour","filter","drawImage","sprite","update","main","id","window","requestAnimationFrame","cancelAnimationFrame","componentDidMount","hair","Image","eyes","skin","armour","clothes","outline","src","onload","player","direction","componentDidUpdate","prevProps","prevState","playerMoved","Date","now","gameMenu","sound","url","playStatus","autoLoad","volume","fileName","_jsxFileName","lineNumber","columnNumber","setState","playerDied","setTimeout","monsterDied","monsterAttacked","monsterUseProjectile","projectile","monsterProjectile","startPosition","monsterProjectileTargetPosition","position","endPosition","target","includes","monsterProjectileDirection","spellCast","playerAttacked","weapon","stats","equippedItems","kind","render","gameStart","spell","className","style","top","left","children","ref","width","height","backgroundImage","targetPosition","mapStateToProps","_ref"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/player/index.jsx"],"sourcesContent":["import React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport ReactTimeout from 'react-timeout';\nimport Sound from 'react-sound';\n\nimport MonsterAttack from '../monsters/assets/monster-attack.wav';\nimport MonsterDeath from '../monsters/assets/monster-death.wav';\nimport MonsterSlash from '../monsters/assets/monster-slash.png';\nimport PlayerDeath from './assets/player-death.mp3';\nimport SwordSlash from './assets/sword-slash.png';\nimport PlayerStep from './assets/player-step.wav';\nimport SwordSwish from './assets/player-sword-swish.wav';\nimport Animation from '../../components/animation';\n\nimport PlayerHair from './assets/player-hair.png';\nimport PlayerEyes from './assets/player-eyes.png';\nimport PlayerSkin from './assets/player-skin.png';\nimport PlayerArmour from './assets/player-armour.png';\nimport PlayerClothes from './assets/player-clothes.png';\nimport PlayerOutline from './assets/player-outline.png';\n\nimport { ANIMATION_SPEED, SPRITE_SIZE, FISTS, HUE_OFFSETS } from '../../config/constants';\n\nimport './styles.scss';\n\nclass Player extends Component {\n    constructor(props) {\n        super(props);\n\n        this.canvasRef = React.createRef();\n        this.directionMap = {\n            SOUTH: 0, // facing down, line 1 of spritesheet\n            NORTH: 1, // facinf up, line 2 of spritesheet\n            WEST: 2, // facing left, line 3 of spritesheet\n            EAST: 3, // facing right, line 4 of spritesheet\n        };\n\n        this.state = {\n            attackAnimationPlay: 'paused',\n            attackAnimationLoc: [0, 0],\n            animationWalkSound: null,\n            animationAttackSound: null,\n            monsterAttackAnimationPlay: 'paused',\n            monsterAnimationAttackSound: null,\n            monsterProjectileAnimation: null,\n            monsterDeath: null,\n            playerDeath: null,\n            leftSideStride: true,\n            stamp: 0,\n        };\n    }\n\n    avatar(action, dir = 0) {\n        if (this.canvasRef && this.canvasRef.current) {\n            const ctx = this.canvasRef.current.getContext('2d');\n            const spriteLine = dir * SPRITE_SIZE;\n\n            let currentFrame = this.state.leftSideStride ? 0 : 5;\n            let currentTick = 0;\n            const ticksPerFrame = 5;\n\n            const { hairColour, skinColour, armourColour, clothesColour } =\n                this.props.dialog.appearance;\n\n            const colours = [\n                ['hair', `hue-rotate(${hairColour + HUE_OFFSETS.hairColour}deg)`],\n                ['skin', `hue-rotate(${skinColour + HUE_OFFSETS.skinColour}deg)`],\n                ['armour', `hue-rotate(${armourColour + HUE_OFFSETS.armourColour}deg)`],\n                ['clothes', `hue-rotate(${clothesColour + HUE_OFFSETS.clothesColour}deg)`],\n                ['outline', 'none'],\n                ['eyes', 'none'],\n            ];\n\n            const draw = (frame) => {\n                // don't allow invalid frames\n                if (frame > 7 || frame < 0) frame = 0;\n\n                ctx.clearRect(0, 0, SPRITE_SIZE, SPRITE_SIZE);\n\n                colours.forEach((colour) => {\n                    ctx.filter = colour[1];\n                    ctx.drawImage(\n                        this.sprite[colour[0]],\n                        frame * SPRITE_SIZE,\n                        spriteLine,\n                        SPRITE_SIZE,\n                        SPRITE_SIZE,\n                        0,\n                        0,\n                        SPRITE_SIZE,\n                        SPRITE_SIZE\n                    );\n                });\n            };\n\n            const update = () => {\n                currentTick += 1;\n\n                if (currentTick > ticksPerFrame) {\n                    currentTick = 0;\n                    currentFrame += 1;\n                }\n            };\n\n            const main = () => {\n                draw(currentFrame);\n                update();\n                const id = window.requestAnimationFrame(main);\n                if (this.state.leftSideStride && currentFrame > 4) {\n                    window.cancelAnimationFrame(id);\n                }\n                if (!this.state.leftSideStride && currentFrame > 8) {\n                    window.cancelAnimationFrame(id);\n                }\n            };\n\n            if (action === 'draw') {\n                draw(0);\n            }\n\n            if (action === 'animate') {\n                main();\n            }\n        }\n    }\n\n    componentDidMount() {\n        this.sprite = {\n            hair: new Image(),\n            eyes: new Image(),\n            skin: new Image(),\n            armour: new Image(),\n            clothes: new Image(),\n            outline: new Image(),\n        };\n\n        this.sprite.hair.src = PlayerHair;\n        this.sprite.eyes.src = PlayerEyes;\n        this.sprite.skin.src = PlayerSkin;\n        this.sprite.armour.src = PlayerArmour;\n        this.sprite.clothes.src = PlayerClothes;\n        this.sprite.outline.src = PlayerOutline;\n\n        this.sprite.onload = () => {\n            this.avatar('draw', this.directionMap[this.props.player.direction]);\n        };\n    }\n\n    // this is used to tell when to animate the player\n    componentDidUpdate(prevProps, prevState) {\n        this.avatar('draw', this.directionMap[this.props.player.direction]);\n\n        // detemine when the player has moved\n        if (\n            prevProps.player.playerMoved !== this.props.player.playerMoved &&\n            this.state.stamp + ANIMATION_SPEED < Date.now()\n        ) {\n            let animationWalkSound = null;\n            if (this.props.gameMenu.sound) {\n                animationWalkSound = (\n                    <Sound\n                        url={PlayerStep}\n                        playStatus={'PLAYING'}\n                        autoLoad={true}\n                        volume={100}\n                    />\n                );\n            }\n            this.setState(\n                {\n                    stamp: Date.now(),\n                    animationWalkSound,\n                    leftSideStride: !this.state.leftSideStride,\n                },\n                () => {\n                    this.avatar(\n                        'animate',\n                        this.directionMap[this.props.player.direction]\n                    );\n                }\n            );\n        }\n        // see if player died\n        else if (prevProps.player.playerDied !== this.props.player.playerDied) {\n            let playerDeath = null;\n            if (this.props.gameMenu.sound) {\n                playerDeath = (\n                    <Sound\n                        url={PlayerDeath}\n                        playStatus={'PLAYING'}\n                        autoLoad={true}\n                        volume={100}\n                    />\n                );\n            }\n            // player the player death sound after\n            this.props.setTimeout(\n                () => this.setState({ playerDeath }),\n                ANIMATION_SPEED\n            );\n            // pause the infinite animation after 1 iteration\n            this.props.setTimeout(\n                () => this.setState({ playerDeath: null }),\n                ANIMATION_SPEED + ANIMATION_SPEED * 4\n            );\n        }\n        // see if a monster died\n        else if (\n            prevProps.player.monsterDied !== this.props.player.monsterDied\n        ) {\n            let monsterDeath = null;\n            if (this.props.gameMenu.sound) {\n                monsterDeath = (\n                    <Sound\n                        url={MonsterDeath}\n                        playStatus={'PLAYING'}\n                        autoLoad={true}\n                        volume={100}\n                    />\n                );\n            }\n            // play the monster death sound after delay\n            this.props.setTimeout(\n                () => this.setState({ monsterDeath }),\n                ANIMATION_SPEED\n            );\n            // pause the infinite animation after 1 iteration and the delay\n            this.props.setTimeout(\n                () => this.setState({ monsterDeath: null }),\n                ANIMATION_SPEED + ANIMATION_SPEED * 3.5\n            );\n        }\n        // see if a monster attacked the player\n        else if (\n            prevProps.player.monsterAttacked !==\n                this.props.player.monsterAttacked ||\n            prevProps.player.monsterUseProjectile !==\n                this.props.player.monsterUseProjectile\n        ) {\n            let monsterAnimationAttackSound = null;\n            let monsterProjectileAnimation = null;\n            if (this.props.gameMenu.sound) {\n                monsterAnimationAttackSound = (\n                    <Sound\n                        url={MonsterAttack}\n                        playStatus={'PLAYING'}\n                        autoLoad={true}\n                        volume={100}\n                    />\n                );\n            }\n\n            if (\n                prevProps.player.monsterUseProjectile !==\n                this.props.player.monsterUseProjectile\n            ) {\n                // A monster used a projectile, so we need to show that\n                monsterProjectileAnimation = (\n                    <Animation\n                        projectile={this.props.player.monsterProjectile}\n                        startPosition={\n                            [\n                                this.props.player.monsterProjectileTargetPosition[0] - this.props.player.position[0],\n                                this.props.player.monsterProjectileTargetPosition[1] - this.props.player.position[1],\n                            ]\n                        }\n                        endPosition={\n                            this.props.player.monsterProjectile.target.includes(\n                                'self'\n                            )\n                                ? this.props.player\n                                      .monsterProjectileTargetPosition // If they're tartgetting themselves, then use their position\n                                : [0, 0] // Otherwise it's targetting the player\n                        }\n                        direction={this.props.player.monsterProjectileDirection}\n                    />\n                );\n            }\n\n            // animate the player\n            this.setState({\n                monsterAttackAnimationPlay: 'running',\n                monsterAnimationAttackSound,\n                monsterProjectileAnimation,\n            });\n            // pause the infinite animation after 1 iteration plus delay time (250ms)\n            this.props.setTimeout(\n                () =>\n                    this.setState({\n                        monsterAttackAnimationPlay: 'paused',\n                        monsterAnimationAttackSound: null,\n                        monsterProjectileAnimation: null,\n                    }),\n                ANIMATION_SPEED + 250\n            );\n        }\n        // see if the player attacked\n        else if (prevProps.player.spellCast !== this.props.player.spellCast) {\n            let attackAnimationLoc = [0, 0];\n            // calculate which way the sword should slash\n            switch (this.props.player.direction) {\n                case 'SOUTH':\n                    attackAnimationLoc = [0, SPRITE_SIZE];\n                    break;\n                case 'EAST':\n                    attackAnimationLoc = [SPRITE_SIZE, 0];\n                    break;\n                case 'WEST':\n                    attackAnimationLoc = [-SPRITE_SIZE, 0];\n                    break;\n                case 'NORTH':\n                    attackAnimationLoc = [0, -SPRITE_SIZE];\n                    break;\n                default:\n            }\n            let animationAttackSound = null;\n            if (this.props.gameMenu.sound) {\n                animationAttackSound = (\n                    <Sound\n                        url={SwordSwish}\n                        playStatus={'PLAYING'}\n                        autoLoad={true}\n                        volume={100}\n                    />\n                );\n            }\n            // animate the sword slash\n            this.setState({\n                attackAnimationPlay: 'spell',\n                attackAnimationLoc,\n                animationAttackSound,\n            });\n            // pause the infinite animation after 1 iteration\n            this.props.setTimeout(\n                () =>\n                    this.setState({\n                        attackAnimationPlay: 'paused',\n                        animationAttackSound: null,\n                    }),\n                ANIMATION_SPEED\n            );\n        } else if (\n            prevProps.player.playerAttacked !== this.props.player.playerAttacked\n        ) {\n            let attackAnimationLoc = [0, 0];\n            // calculate which way the sword should slash\n            switch (this.props.player.direction) {\n                case 'SOUTH':\n                    attackAnimationLoc = [0, SPRITE_SIZE];\n                    break;\n                case 'EAST':\n                    attackAnimationLoc = [SPRITE_SIZE, 0];\n                    break;\n                case 'WEST':\n                    attackAnimationLoc = [-SPRITE_SIZE, 0];\n                    break;\n                case 'NORTH':\n                    attackAnimationLoc = [0, -SPRITE_SIZE];\n                    break;\n                default:\n            }\n            let animationAttackSound = null;\n            if (this.props.gameMenu.sound) {\n                animationAttackSound = (\n                    <Sound\n                        url={SwordSwish}\n                        playStatus={'PLAYING'}\n                        autoLoad={true}\n                        volume={100}\n                    />\n                );\n            }\n\n            const weapon = this.props.stats.equippedItems.weapon || FISTS;\n\n            // animate the sword slash\n            this.setState({\n                attackAnimationPlay: weapon.kind || 'running',\n                attackAnimationLoc,\n                animationAttackSound,\n            });\n            // pause the infinite animation after 1 iteration\n            this.props.setTimeout(\n                () =>\n                    this.setState({\n                        attackAnimationPlay: 'paused',\n                        animationAttackSound: null,\n                    }),\n                ANIMATION_SPEED\n            );\n        }\n    }\n\n    render() {\n        const {\n            attackAnimationPlay,\n            attackAnimationLoc,\n            animationWalkSound,\n            animationAttackSound,\n            monsterAnimationAttackSound,\n            monsterAttackAnimationPlay,\n            monsterProjectileAnimation,\n            monsterDeath,\n            playerDeath,\n        } = this.state;\n        const { player, dialog, stats } = this.props;\n\n        const { gameStart } = dialog;\n        // game start menu open, hide the player\n        if (gameStart) return null;\n\n        // Determine what the projectile the player used was\n        const projectile =\n            attackAnimationPlay === 'spell'\n                ? player.spell\n                : attackAnimationPlay === 'ranged'\n                ? stats.equippedItems.weapon.projectile\n                : null;\n\n        return (\n            <div\n                className=\"player__animation\"\n                style={{\n                    top: player.position[1],\n                    left: player.position[0],\n                }}\n            >\n                <canvas ref={this.canvasRef} width={40} height={40} />\n\n                {animationWalkSound}\n                {animationAttackSound}\n                {monsterAnimationAttackSound}\n                {monsterDeath}\n                {playerDeath}\n                {monsterProjectileAnimation}\n\n                {monsterAttackAnimationPlay === 'running' && (\n                    <div\n                        className=\"monster__slash\"\n                        style={{ backgroundImage: `url('${MonsterSlash}')` }}\n                    />\n                )}\n\n                {attackAnimationPlay !== 'paused' && (\n                    <div\n                        className=\"sword__slash\"\n                        style={{\n                            top: attackAnimationLoc[1],\n                            left: attackAnimationLoc[0],\n                            backgroundImage: `url('${SwordSlash}')`,\n                        }}\n                    />\n                )}\n\n                {projectile && (\n                    <Animation\n                        projectile={projectile}\n                        startPosition={attackAnimationLoc}\n                        endPosition={[\n                            player.targetPosition[0] - player.position[0],\n                            player.targetPosition[1] - player.position[1],\n                        ]}\n                        direction={player.direction}\n                    />\n                )}\n            </div>\n        );\n    }\n}\n\nconst mapStateToProps = ({ gameMenu, player, dialog, stats }) => ({\n    gameMenu,\n    player,\n    dialog,\n    stats,\n});\n\nexport default connect(mapStateToProps)(ReactTimeout(Player));\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}