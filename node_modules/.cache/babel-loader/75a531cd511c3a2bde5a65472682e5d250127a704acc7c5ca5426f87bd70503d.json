{"ast":null,"code":"import { playerInRange, getRandomDirection } from './move-monster';\nimport { move } from './normal-ai';\nimport attackPlayer from './attack-player';\nimport { SPRITE_SIZE } from '../../../config/constants';\nimport monsterCastSpell from './monster-cast-spell';\n\n/**\n * An AI for monsters who have the capability of healing themselves\n *\n * @param {*} sightBox The players FOV\n * @param {*} currentMap The map the player is in\n * @param {*} monster The monster we're moving\n */\nexport default function healer(sightBox, currentMap, monster) {\n  return (dispatch, getState) => {\n    const {\n      id,\n      position,\n      hp,\n      maxHp\n    } = monster;\n    const monsterPosition = position.map(pos => pos / SPRITE_SIZE);\n    let monsterVisible = false;\n    // look through each current sight box tile\n    sightBox.forEach(tile => {\n      // if the monster is in sight\n      if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n        monsterVisible = true;\n      }\n    });\n    if (monsterVisible) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n      const {\n        player\n      } = getState();\n      if (hp <= maxHp / 2) {\n        // Attempt to heal some health\n        dispatch(monsterCastSpell(monster));\n      } else if (playerInRange(player.position, monsterPosition)) {\n        // check if player is in range\n        dispatch(attackPlayer(monster));\n      } else {\n        // no player in range, time to move!\n        // get the monsters actual position in pixels\n        const position = monsterPosition.map(value => value * SPRITE_SIZE);\n        // get distance from player on both axis\n        const xDiff = position[0] - player.position[0];\n        const yDiff = position[1] - player.position[1];\n        const greaterY = Math.abs(yDiff) > Math.abs(xDiff);\n        // see if y axis is greater distance from player\n        if (greaterY) {\n          // if the monster is mostly below the player on the y axis\n          if (yDiff > 0) {\n            // move the monster 'up' relatively\n            dispatch(move('up', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n          // if the monster is mostly above the player on the y axis\n          else if (yDiff < 0) {\n            // move the monster 'down' relatively\n            dispatch(move('down', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n        } // x axis is greater distance from player\n        else {\n          // if the monster is mostly to the right of the player\n          if (xDiff > 0) {\n            // move the monster 'left' relatively\n            dispatch(move('left', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n          // if the monster is mostly to the left of the player\n          else if (xDiff < 0) {\n            // move the monster 'right' relatively\n            dispatch(move('right', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n        }\n      }\n    } else {\n      // monster is too far away from the player\n      dispatch({\n        type: 'HIDE_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n      // give a 25% chance to move the monster when hidden\n      if (Math.round(Math.random() * (4 - 1) + 1) !== 4) {\n        const randomDirection = getRandomDirection();\n        // move the monster in a random direction\n        dispatch(move(randomDirection, position, currentMap, id, 0));\n      }\n    }\n  };\n}","map":{"version":3,"names":["playerInRange","getRandomDirection","move","attackPlayer","SPRITE_SIZE","monsterCastSpell","healer","sightBox","currentMap","monster","dispatch","getState","id","position","hp","maxHp","monsterPosition","map","pos","monsterVisible","forEach","tile","JSON","stringify","type","payload","player","value","xDiff","yDiff","greaterY","Math","abs","round","random","randomDirection"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/monsters/actions/healer-ai.jsx"],"sourcesContent":["import { playerInRange, getRandomDirection } from './move-monster';\nimport { move } from './normal-ai';\nimport attackPlayer from './attack-player';\nimport { SPRITE_SIZE } from '../../../config/constants';\nimport monsterCastSpell from './monster-cast-spell';\n\n/**\n * An AI for monsters who have the capability of healing themselves\n *\n * @param {*} sightBox The players FOV\n * @param {*} currentMap The map the player is in\n * @param {*} monster The monster we're moving\n */\nexport default function healer(sightBox, currentMap, monster) {\n  return (dispatch, getState) => {\n    const { id, position, hp, maxHp } = monster;\n\n    const monsterPosition = position.map((pos) => pos / SPRITE_SIZE);\n\n    let monsterVisible = false;\n    // look through each current sight box tile\n    sightBox.forEach((tile) => {\n      // if the monster is in sight\n      if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n        monsterVisible = true;\n      }\n    });\n\n    if (monsterVisible) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: { id, map: currentMap },\n      });\n\n      const { player } = getState();\n      if (hp <= maxHp / 2) {\n        // Attempt to heal some health\n        dispatch(monsterCastSpell(monster));\n      } else if (playerInRange(player.position, monsterPosition)) {\n        // check if player is in range\n        dispatch(attackPlayer(monster));\n      } else {\n        // no player in range, time to move!\n        // get the monsters actual position in pixels\n        const position = monsterPosition.map((value) => value * SPRITE_SIZE);\n        // get distance from player on both axis\n        const xDiff = position[0] - player.position[0];\n        const yDiff = position[1] - player.position[1];\n        const greaterY = Math.abs(yDiff) > Math.abs(xDiff);\n        // see if y axis is greater distance from player\n        if (greaterY) {\n          // if the monster is mostly below the player on the y axis\n          if (yDiff > 0) {\n            // move the monster 'up' relatively\n            dispatch(move('up', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n          // if the monster is mostly above the player on the y axis\n          else if (yDiff < 0) {\n            // move the monster 'down' relatively\n            dispatch(move('down', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n        } // x axis is greater distance from player\n        else {\n          // if the monster is mostly to the right of the player\n          if (xDiff > 0) {\n            // move the monster 'left' relatively\n            dispatch(move('left', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n          // if the monster is mostly to the left of the player\n          else if (xDiff < 0) {\n            // move the monster 'right' relatively\n            dispatch(move('right', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n        }\n      }\n    } else {\n      // monster is too far away from the player\n      dispatch({\n        type: 'HIDE_MONSTER',\n        payload: { id, map: currentMap },\n      });\n      // give a 25% chance to move the monster when hidden\n      if (Math.round(Math.random() * (4 - 1) + 1) !== 4) {\n        const randomDirection = getRandomDirection();\n        // move the monster in a random direction\n        dispatch(move(randomDirection, position, currentMap, id, 0));\n      }\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}