{"ast":null,"code":"import { observeImpassable, checkForOtherMonster, playerInRange, getRandomDirection } from './move-monster';\nimport attackPlayer from './attack-player';\nimport { SPRITE_SIZE } from '../../../config/constants';\n\n// recursive function for moving the monster to the next available tile\n// will try to go towards the player if possible\nexport function move(direction, position, currentMap, id, count) {\n  let preference = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  return (dispatch, getState) => {\n    count++;\n    // dont allow for infinite loops when monster can't move\n    if (count >= 5) return;\n    let nextPos = [0, 0];\n    switch (direction) {\n      case 'up':\n        nextPos = [position[0], position[1] - SPRITE_SIZE];\n        // see if the monster can move to the next location\n        if (dispatch(observeImpassable(nextPos))) {\n          // if we found a monster\n          if (dispatch(checkForOtherMonster(id, nextPos, currentMap))) {\n            // move in a circle, but the opposite direction\n            return dispatch(move(preference ? preference : 'left', position, currentMap, id, count));\n          } else {\n            // otherwise just move to the next spot\n            position[1] -= SPRITE_SIZE;\n          }\n          break;\n        } else {\n          // otherwise move them to another spot\n          return dispatch(move(preference ? preference : 'right', position, currentMap, id, count));\n        }\n      case 'down':\n        nextPos = [position[0], position[1] + SPRITE_SIZE];\n        // see if the monster can move to the next location\n        if (dispatch(observeImpassable(nextPos))) {\n          // if we found a monster\n          if (dispatch(checkForOtherMonster(id, nextPos, currentMap))) {\n            // move in a circle, but the opposite direction\n            return dispatch(move(preference ? preference : 'right', position, currentMap, id, count));\n          } else {\n            // otherwise just move to the next spot\n            position[1] += SPRITE_SIZE;\n          }\n          break;\n        } else {\n          // otherwise move them to another spot\n          return dispatch(move(preference ? preference : 'left', position, currentMap, id, count));\n        }\n      case 'left':\n        nextPos = [position[0] - SPRITE_SIZE, position[1]];\n        // see if the monster can move to the next location\n        if (dispatch(observeImpassable(nextPos))) {\n          // if we found a monster\n          if (dispatch(checkForOtherMonster(id, nextPos, currentMap))) {\n            // move in a circle, but the opposite direction\n            return dispatch(move(preference ? preference : 'down', position, currentMap, id, count));\n          } else {\n            // otherwise just move to the next spot\n            position[0] -= SPRITE_SIZE;\n          }\n          break;\n        } else {\n          // otherwise move them to another spot\n          return dispatch(move(preference ? preference : 'up', position, currentMap, id, count));\n        }\n      case 'right':\n        nextPos = [position[0] + SPRITE_SIZE, position[1]];\n        // see if the monster can move to the next location\n        if (dispatch(observeImpassable(nextPos))) {\n          // if we found a monster\n          if (dispatch(checkForOtherMonster(id, nextPos, currentMap))) {\n            // move in a circle, but the opposite direction\n            return dispatch(move(preference ? preference : 'up', position, currentMap, id, count));\n          } else {\n            // otherwise just move to the next spot\n            position[0] += SPRITE_SIZE;\n          }\n          break;\n        } else {\n          // otherwise move them to another spot\n          return dispatch(move(preference ? preference : 'down', position, currentMap, id, count));\n        }\n      default:\n    }\n\n    // recalculate if the monster is in sight\n    const {\n      sightBox\n    } = getState().map;\n    let inSight = false;\n    // look through each current sight box tile\n    sightBox.forEach(tile => {\n      // if the monster is in sight\n      const newMonsterPos = position.map(value => value / SPRITE_SIZE);\n      if (JSON.stringify(tile) === JSON.stringify(newMonsterPos)) {\n        inSight = true;\n      }\n    });\n    // if the monster is now in sight\n    if (inSight) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n    } else {\n      // if the monster is now out of sight\n      dispatch({\n        type: 'HIDE_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n    }\n    const monster = getState().monsters.components[currentMap][id];\n    // move the monster\n    dispatch({\n      type: 'MOVE_MONSTER',\n      payload: {\n        map: currentMap,\n        id,\n        position,\n        direction: direction === 'up' || direction === 'down' ? monster.direction : direction === 'left' ? 'WEST' : 'EAST'\n      }\n    });\n  };\n}\nexport default function moveNormally(sightBox, currentMap, monster) {\n  return (dispatch, getState) => {\n    const {\n      id,\n      position\n    } = monster;\n    const monsterPosition = position.map(pos => pos / SPRITE_SIZE);\n    let monsterVisible = false;\n    // look through each current sight box tile\n    sightBox.forEach(tile => {\n      // if the monster is in sight\n      if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n        monsterVisible = true;\n      }\n    });\n    if (monsterVisible) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n      const {\n        player\n      } = getState();\n      // check if player is in range\n      if (playerInRange(player.position, monsterPosition)) {\n        dispatch(attackPlayer(monster));\n      } else {\n        // no player in range, time to move!\n        // get the monsters actual position in pixels\n        const position = monsterPosition.map(value => value * SPRITE_SIZE);\n        // get distance from player on both axis\n        const xDiff = position[0] - player.position[0];\n        const yDiff = position[1] - player.position[1];\n        const greaterY = Math.abs(yDiff) > Math.abs(xDiff);\n        // see if y axis is greater distance from player\n        if (greaterY) {\n          // if the monster is mostly below the player on the y axis\n          if (yDiff > 0) {\n            // move the monster 'up' relatively\n            dispatch(move('up', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n          // if the monster is mostly above the player on the y axis\n          else if (yDiff < 0) {\n            // move the monster 'down' relatively\n            dispatch(move('down', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n        } // x axis is greater distance from player\n        else {\n          // if the monster is mostly to the right of the player\n          if (xDiff > 0) {\n            // move the monster 'left' relatively\n            dispatch(move('left', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n          // if the monster is mostly to the left of the player\n          else if (xDiff < 0) {\n            // move the monster 'right' relatively\n            dispatch(move('right', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n        }\n      }\n    } else {\n      // monster is too far away from the player\n      dispatch({\n        type: 'HIDE_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n      // give a 25% chance to move the monster when hidden\n      if (Math.round(Math.random() * (4 - 1) + 1) !== 4) {\n        const randomDirection = getRandomDirection();\n        // move the monster in a random direction\n        dispatch(move(randomDirection, position, currentMap, id, 0));\n      }\n    }\n  };\n}","map":{"version":3,"names":["observeImpassable","checkForOtherMonster","playerInRange","getRandomDirection","attackPlayer","SPRITE_SIZE","move","direction","position","currentMap","id","count","preference","arguments","length","undefined","dispatch","getState","nextPos","sightBox","map","inSight","forEach","tile","newMonsterPos","value","JSON","stringify","type","payload","monster","monsters","components","moveNormally","monsterPosition","pos","monsterVisible","player","xDiff","yDiff","greaterY","Math","abs","round","random","randomDirection"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/monsters/actions/normal-ai.jsx"],"sourcesContent":["import {\n    observeImpassable,\n    checkForOtherMonster,\n    playerInRange,\n    getRandomDirection,\n} from './move-monster';\nimport attackPlayer from './attack-player';\nimport { SPRITE_SIZE } from '../../../config/constants';\n\n// recursive function for moving the monster to the next available tile\n// will try to go towards the player if possible\nexport function move(\n    direction,\n    position,\n    currentMap,\n    id,\n    count,\n    preference = false\n) {\n    return (dispatch, getState) => {\n        count++;\n        // dont allow for infinite loops when monster can't move\n        if (count >= 5) return;\n\n        let nextPos = [0, 0];\n\n        switch (direction) {\n            case 'up':\n                nextPos = [position[0], position[1] - SPRITE_SIZE];\n                // see if the monster can move to the next location\n                if (dispatch(observeImpassable(nextPos))) {\n                    // if we found a monster\n                    if (\n                        dispatch(checkForOtherMonster(id, nextPos, currentMap))\n                    ) {\n                        // move in a circle, but the opposite direction\n                        return dispatch(\n                            move(\n                                preference ? preference : 'left',\n                                position,\n                                currentMap,\n                                id,\n                                count\n                            )\n                        );\n                    } else {\n                        // otherwise just move to the next spot\n                        position[1] -= SPRITE_SIZE;\n                    }\n                    break;\n                } else {\n                    // otherwise move them to another spot\n                    return dispatch(\n                        move(\n                            preference ? preference : 'right',\n                            position,\n                            currentMap,\n                            id,\n                            count\n                        )\n                    );\n                }\n            case 'down':\n                nextPos = [position[0], position[1] + SPRITE_SIZE];\n                // see if the monster can move to the next location\n                if (dispatch(observeImpassable(nextPos))) {\n                    // if we found a monster\n                    if (\n                        dispatch(checkForOtherMonster(id, nextPos, currentMap))\n                    ) {\n                        // move in a circle, but the opposite direction\n                        return dispatch(\n                            move(\n                                preference ? preference : 'right',\n                                position,\n                                currentMap,\n                                id,\n                                count\n                            )\n                        );\n                    } else {\n                        // otherwise just move to the next spot\n                        position[1] += SPRITE_SIZE;\n                    }\n                    break;\n                } else {\n                    // otherwise move them to another spot\n                    return dispatch(\n                        move(\n                            preference ? preference : 'left',\n                            position,\n                            currentMap,\n                            id,\n                            count\n                        )\n                    );\n                }\n            case 'left':\n                nextPos = [position[0] - SPRITE_SIZE, position[1]];\n                // see if the monster can move to the next location\n                if (dispatch(observeImpassable(nextPos))) {\n                    // if we found a monster\n                    if (\n                        dispatch(checkForOtherMonster(id, nextPos, currentMap))\n                    ) {\n                        // move in a circle, but the opposite direction\n                        return dispatch(\n                            move(\n                                preference ? preference : 'down',\n                                position,\n                                currentMap,\n                                id,\n                                count\n                            )\n                        );\n                    } else {\n                        // otherwise just move to the next spot\n                        position[0] -= SPRITE_SIZE;\n                    }\n                    break;\n                } else {\n                    // otherwise move them to another spot\n                    return dispatch(\n                        move(\n                            preference ? preference : 'up',\n                            position,\n                            currentMap,\n                            id,\n                            count\n                        )\n                    );\n                }\n            case 'right':\n                nextPos = [position[0] + SPRITE_SIZE, position[1]];\n                // see if the monster can move to the next location\n                if (dispatch(observeImpassable(nextPos))) {\n                    // if we found a monster\n                    if (\n                        dispatch(checkForOtherMonster(id, nextPos, currentMap))\n                    ) {\n                        // move in a circle, but the opposite direction\n                        return dispatch(\n                            move(\n                                preference ? preference : 'up',\n                                position,\n                                currentMap,\n                                id,\n                                count\n                            )\n                        );\n                    } else {\n                        // otherwise just move to the next spot\n                        position[0] += SPRITE_SIZE;\n                    }\n                    break;\n                } else {\n                    // otherwise move them to another spot\n                    return dispatch(\n                        move(\n                            preference ? preference : 'down',\n                            position,\n                            currentMap,\n                            id,\n                            count\n                        )\n                    );\n                }\n            default:\n        }\n\n        // recalculate if the monster is in sight\n        const { sightBox } = getState().map;\n        let inSight = false;\n        // look through each current sight box tile\n        sightBox.forEach(tile => {\n            // if the monster is in sight\n            const newMonsterPos = position.map(value => value / SPRITE_SIZE);\n            if (JSON.stringify(tile) === JSON.stringify(newMonsterPos)) {\n                inSight = true;\n            }\n        });\n        // if the monster is now in sight\n        if (inSight) {\n            dispatch({\n                type: 'REVEAL_MONSTER',\n                payload: { id, map: currentMap },\n            });\n        } else {\n            // if the monster is now out of sight\n            dispatch({\n                type: 'HIDE_MONSTER',\n                payload: { id, map: currentMap },\n            });\n        }\n        const monster = getState().monsters.components[currentMap][id];\n        // move the monster\n        dispatch({\n            type: 'MOVE_MONSTER',\n            payload: {\n                map: currentMap,\n                id,\n                position,\n                direction:\n                    direction === 'up' || direction === 'down'\n                        ? monster.direction\n                        : direction === 'left'\n                        ? 'WEST'\n                        : 'EAST',\n            },\n        });\n    };\n}\n\nexport default function moveNormally(sightBox, currentMap, monster) {\n    return (dispatch, getState) => {\n        const { id, position } = monster;\n\n        const monsterPosition = position.map(pos => pos / SPRITE_SIZE);\n\n        let monsterVisible = false;\n        // look through each current sight box tile\n        sightBox.forEach(tile => {\n            // if the monster is in sight\n            if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n                monsterVisible = true;\n            }\n        });\n\n        if (monsterVisible) {\n            dispatch({\n                type: 'REVEAL_MONSTER',\n                payload: { id, map: currentMap },\n            });\n\n            const { player } = getState();\n            // check if player is in range\n            if (playerInRange(player.position, monsterPosition)) {\n                dispatch(attackPlayer(monster));\n            } else {\n                // no player in range, time to move!\n                // get the monsters actual position in pixels\n                const position = monsterPosition.map(\n                    value => value * SPRITE_SIZE\n                );\n                // get distance from player on both axis\n                const xDiff = position[0] - player.position[0];\n                const yDiff = position[1] - player.position[1];\n                const greaterY = Math.abs(yDiff) > Math.abs(xDiff);\n                // see if y axis is greater distance from player\n                if (greaterY) {\n                    // if the monster is mostly below the player on the y axis\n                    if (yDiff > 0) {\n                        // move the monster 'up' relatively\n                        dispatch(\n                            move(\n                                'up',\n                                position,\n                                currentMap,\n                                id,\n                                0,\n                                xDiff >= 0 ? 'left' : 'right'\n                            )\n                        );\n                    }\n                    // if the monster is mostly above the player on the y axis\n                    else if (yDiff < 0) {\n                        // move the monster 'down' relatively\n                        dispatch(\n                            move(\n                                'down',\n                                position,\n                                currentMap,\n                                id,\n                                0,\n                                xDiff >= 0 ? 'left' : 'right'\n                            )\n                        );\n                    }\n                } // x axis is greater distance from player\n                else {\n                    // if the monster is mostly to the right of the player\n                    if (xDiff > 0) {\n                        // move the monster 'left' relatively\n                        dispatch(\n                            move(\n                                'left',\n                                position,\n                                currentMap,\n                                id,\n                                0,\n                                yDiff >= 0 ? 'up' : 'down'\n                            )\n                        );\n                    }\n                    // if the monster is mostly to the left of the player\n                    else if (xDiff < 0) {\n                        // move the monster 'right' relatively\n                        dispatch(\n                            move(\n                                'right',\n                                position,\n                                currentMap,\n                                id,\n                                0,\n                                yDiff >= 0 ? 'up' : 'down'\n                            )\n                        );\n                    }\n                }\n            }\n        } else {\n            // monster is too far away from the player\n            dispatch({\n                type: 'HIDE_MONSTER',\n                payload: { id, map: currentMap },\n            });\n            // give a 25% chance to move the monster when hidden\n            if (Math.round(Math.random() * (4 - 1) + 1) !== 4) {\n                const randomDirection = getRandomDirection();\n                // move the monster in a random direction\n                dispatch(move(randomDirection, position, currentMap, id, 0));\n            }\n        }\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}