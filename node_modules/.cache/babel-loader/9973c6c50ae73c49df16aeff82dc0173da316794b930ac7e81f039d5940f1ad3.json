{"ast":null,"code":"import { checkForMonster, applyEffects } from './move-player';\nimport { calculateDamage, d20 } from '../../../utils/dice';\nimport calculateModifier from '../../../utils/calculate-modifier';\nimport { SPRITE_SIZE } from '../../../config/constants';\nimport errorMessage from '../../dialog-manager/actions/error-message';\nimport { findTarget } from './attack-monster';\nfunction doesProcOnBoss() {\n  // Give the bosses some chance to not have their AI changed when hit\n  return Math.random() * 100 < 20;\n}\nfunction changeBossAI(spell, currMonster, criticalHit) {\n  return dispatch => {\n    if (criticalHit || doesProcOnBoss()) dispatch(changeMonsterAI(spell, currMonster));\n  };\n}\n\n/**\n * Change a monsters AI from an effect that the spell the players casting\n * causes.\n *\n * @param {*} spell The spell the player is casting\n * @param {*} currMonster The monster that's being targetted\n */\nfunction changeMonsterAI(spell, currMonster) {\n  return (dispatch, getState) => {\n    const {\n      currentMap\n    } = getState().world;\n    const {\n      to,\n      turns,\n      proc\n    } = spell.effects.changeAI;\n\n    // If they're already under the effects of something, don't apply a new effect\n    if (currMonster.ai !== currMonster.originalAI) return;\n\n    // If we have a probabilty to hit, then use that to check if we do\n    if (!proc || proc()) {\n      dispatch({\n        type: 'CHANGE_AI',\n        payload: {\n          from: currMonster.ai,\n          ai: to,\n          turns,\n          id: currMonster.id,\n          map: currentMap,\n          entity: currMonster.type,\n          original: currMonster.originalAI\n        }\n      });\n    }\n  };\n}\nexport default function castSpell() {\n  return (dispatch, getState) => {\n    const {\n      stats,\n      player,\n      monsters,\n      world\n    } = getState();\n    const {\n      position,\n      direction,\n      spell\n    } = player;\n    if (spell === null) {\n      dispatch(errorMessage('Select a spell first (\"b\")'));\n      return;\n    } else if (spell.manaCost > stats.mana) {\n      dispatch(errorMessage('Not enough mana'));\n      return;\n    }\n    const target = spell.target.split('::');\n    if (target[0] === 'self') {\n      dispatch({\n        type: 'CAST_SPELL',\n        payload: {\n          position: position,\n          projectile: spell\n        }\n      });\n      const intelligenceModifier = calculateModifier(stats.abilities.intelligence);\n      const healAmount = calculateDamage(spell.damage) + (intelligenceModifier > 0 ? intelligenceModifier : 0);\n      if (target[1] === 'heal') {\n        dispatch({\n          type: 'HEAL_HP',\n          payload: healAmount\n        });\n      }\n      dispatch({\n        type: 'TAKE_TURN',\n        payload: null\n      });\n      dispatch(applyEffects());\n    } else if (target[0] === 'enemy') {\n      const spellPosition = dispatch(findTarget(position, direction, spell.range * SPRITE_SIZE));\n      const {\n        currentMap\n      } = world;\n      const {\n        components\n      } = monsters;\n      const monsterId = dispatch(checkForMonster(spellPosition));\n      if (monsterId) {\n        // If we're targetting a monster\n        const currMonster = components[currentMap][monsterId];\n        const monsterPos = currMonster.position;\n        const modifier = calculateModifier(stats.abilities.intelligence);\n        const roll = d20();\n        const criticalHit = roll === 20;\n        const attackValue = roll + modifier;\n        dispatch({\n          type: 'CAST_SPELL',\n          payload: {\n            position: spellPosition,\n            projectile: spell\n          }\n        });\n        if (criticalHit) {\n          dispatch({\n            type: 'CRITICAL_HIT',\n            payload: {\n              notation: 'd20 + ' + modifier,\n              roll: roll,\n              ability: 'intelligence'\n            }\n          });\n        } else {\n          dispatch({\n            type: 'ABILITY_CHECK',\n            payload: {\n              notation: 'd20 + ' + modifier,\n              roll: attackValue,\n              ability: 'intelligence',\n              check: currMonster.defence,\n              entity: currMonster.type,\n              against: 'defence'\n            }\n          });\n        }\n        const damage = criticalHit ? calculateDamage(spell.damage, true) : attackValue >= currMonster.defence ? calculateDamage(spell.damage, false) : 0;\n\n        // deal damage to monster\n        dispatch({\n          type: 'DAMAGE_TO_MONSTER',\n          payload: {\n            damage,\n            id: currMonster.id,\n            map: currentMap,\n            entity: currMonster.type,\n            from: 'player'\n          }\n        });\n\n        // check if monster died\n        if (currMonster.hp - damage <= 0) {\n          // and get some exp\n          dispatch({\n            type: 'GET_EXP',\n            payload: currMonster.exp\n          });\n          if (stats.exp + currMonster.exp >= stats.expToLevel) {\n            dispatch({\n              type: 'PAUSE',\n              payload: {\n                pause: true,\n                levelUp: true\n              }\n            });\n          }\n          // play death sound\n          dispatch({\n            type: 'MONSTER_DIED',\n            payload: currMonster.type\n          });\n          // replace monster will blood spill\n          // need to pass relative tile index\n          dispatch({\n            type: 'ADD_BLOOD_SPILL',\n            payload: {\n              x: monsterPos[0] / SPRITE_SIZE,\n              y: monsterPos[1] / SPRITE_SIZE\n            }\n          });\n        } else if (damage > 0 && spell.effects && spell.effects.changeAI) {\n          if (currMonster.originalAI === 'boss') {\n            dispatch(changeBossAI(spell, currMonster, criticalHit));\n          } else {\n            dispatch(changeMonsterAI(spell, currMonster));\n          }\n        }\n\n        // take a turn if the player attacked something\n        dispatch({\n          type: 'TAKE_TURN',\n          payload: null\n        });\n        dispatch(applyEffects());\n      } else {\n        // Hit a wall or something else\n        dispatch({\n          type: 'CAST_SPELL',\n          payload: {\n            position: spellPosition,\n            projectile: spell\n          }\n        });\n      }\n    }\n  };\n}","map":{"version":3,"names":["checkForMonster","applyEffects","calculateDamage","d20","calculateModifier","SPRITE_SIZE","errorMessage","findTarget","doesProcOnBoss","Math","random","changeBossAI","spell","currMonster","criticalHit","dispatch","changeMonsterAI","getState","currentMap","world","to","turns","proc","effects","changeAI","ai","originalAI","type","payload","from","id","map","entity","original","castSpell","stats","player","monsters","position","direction","manaCost","mana","target","split","projectile","intelligenceModifier","abilities","intelligence","healAmount","damage","spellPosition","range","components","monsterId","monsterPos","modifier","roll","attackValue","notation","ability","check","defence","against","hp","exp","expToLevel","pause","levelUp","x","y"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/player/actions/cast-spell.jsx"],"sourcesContent":["import { checkForMonster, applyEffects } from './move-player';\nimport { calculateDamage, d20 } from '../../../utils/dice';\nimport calculateModifier from '../../../utils/calculate-modifier';\nimport { SPRITE_SIZE } from '../../../config/constants';\nimport errorMessage from '../../dialog-manager/actions/error-message';\nimport { findTarget } from './attack-monster';\n\nfunction doesProcOnBoss() {\n    // Give the bosses some chance to not have their AI changed when hit\n    return Math.random() * 100 < 20;\n}\n\nfunction changeBossAI(spell, currMonster, criticalHit) {\n    return dispatch => {\n        if (criticalHit || doesProcOnBoss())\n            dispatch(changeMonsterAI(spell, currMonster));\n    };\n}\n\n/**\n * Change a monsters AI from an effect that the spell the players casting\n * causes.\n *\n * @param {*} spell The spell the player is casting\n * @param {*} currMonster The monster that's being targetted\n */\nfunction changeMonsterAI(spell, currMonster) {\n    return (dispatch, getState) => {\n        const { currentMap } = getState().world;\n        const { to, turns, proc } = spell.effects.changeAI;\n\n        // If they're already under the effects of something, don't apply a new effect\n        if (currMonster.ai !== currMonster.originalAI) return;\n\n        // If we have a probabilty to hit, then use that to check if we do\n        if (!proc || proc()) {\n            dispatch({\n                type: 'CHANGE_AI',\n                payload: {\n                    from: currMonster.ai,\n                    ai: to,\n                    turns,\n                    id: currMonster.id,\n                    map: currentMap,\n                    entity: currMonster.type,\n                    original: currMonster.originalAI,\n                },\n            });\n        }\n    };\n}\n\nexport default function castSpell() {\n    return (dispatch, getState) => {\n        const { stats, player, monsters, world } = getState();\n        const { position, direction, spell } = player;\n\n        if (spell === null) {\n            dispatch(errorMessage('Select a spell first (\"b\")'));\n            return;\n        } else if (spell.manaCost > stats.mana) {\n            dispatch(errorMessage('Not enough mana'));\n            return;\n        }\n\n        const target = spell.target.split('::');\n\n        if (target[0] === 'self') {\n            dispatch({\n                type: 'CAST_SPELL',\n                payload: { position: position, projectile: spell },\n            });\n\n            const intelligenceModifier = calculateModifier(\n                stats.abilities.intelligence\n            );\n            const healAmount =\n                calculateDamage(spell.damage) +\n                (intelligenceModifier > 0 ? intelligenceModifier : 0);\n\n            if (target[1] === 'heal') {\n                dispatch({\n                    type: 'HEAL_HP',\n                    payload: healAmount,\n                });\n            }\n\n            dispatch({\n                type: 'TAKE_TURN',\n                payload: null,\n            });\n            dispatch(applyEffects());\n        } else if (target[0] === 'enemy') {\n            const spellPosition = dispatch(\n                findTarget(position, direction, spell.range * SPRITE_SIZE)\n            );\n\n            const { currentMap } = world;\n            const { components } = monsters;\n\n            const monsterId = dispatch(checkForMonster(spellPosition));\n            if (monsterId) {\n                // If we're targetting a monster\n                const currMonster = components[currentMap][monsterId];\n                const monsterPos = currMonster.position;\n\n                const modifier = calculateModifier(\n                    stats.abilities.intelligence\n                );\n\n                const roll = d20();\n                const criticalHit = roll === 20;\n                const attackValue = roll + modifier;\n\n                dispatch({\n                    type: 'CAST_SPELL',\n                    payload: { position: spellPosition, projectile: spell },\n                });\n\n                if (criticalHit) {\n                    dispatch({\n                        type: 'CRITICAL_HIT',\n                        payload: {\n                            notation: 'd20 + ' + modifier,\n                            roll: roll,\n                            ability: 'intelligence',\n                        },\n                    });\n                } else {\n                    dispatch({\n                        type: 'ABILITY_CHECK',\n                        payload: {\n                            notation: 'd20 + ' + modifier,\n                            roll: attackValue,\n                            ability: 'intelligence',\n                            check: currMonster.defence,\n                            entity: currMonster.type,\n                            against: 'defence',\n                        },\n                    });\n                }\n\n                const damage = criticalHit\n                    ? calculateDamage(spell.damage, true)\n                    : attackValue >= currMonster.defence\n                    ? calculateDamage(spell.damage, false)\n                    : 0;\n\n                // deal damage to monster\n                dispatch({\n                    type: 'DAMAGE_TO_MONSTER',\n                    payload: {\n                        damage,\n                        id: currMonster.id,\n                        map: currentMap,\n                        entity: currMonster.type,\n                        from: 'player',\n                    },\n                });\n\n                // check if monster died\n                if (currMonster.hp - damage <= 0) {\n                    // and get some exp\n                    dispatch({\n                        type: 'GET_EXP',\n                        payload: currMonster.exp,\n                    });\n                    if (stats.exp + currMonster.exp >= stats.expToLevel) {\n                        dispatch({\n                            type: 'PAUSE',\n                            payload: {\n                                pause: true,\n                                levelUp: true,\n                            },\n                        });\n                    }\n                    // play death sound\n                    dispatch({\n                        type: 'MONSTER_DIED',\n                        payload: currMonster.type,\n                    });\n                    // replace monster will blood spill\n                    // need to pass relative tile index\n                    dispatch({\n                        type: 'ADD_BLOOD_SPILL',\n                        payload: {\n                            x: monsterPos[0] / SPRITE_SIZE,\n                            y: monsterPos[1] / SPRITE_SIZE,\n                        },\n                    });\n                } else if (\n                    damage > 0 &&\n                    spell.effects &&\n                    spell.effects.changeAI\n                ) {\n                    if (currMonster.originalAI === 'boss') {\n                        dispatch(changeBossAI(spell, currMonster, criticalHit));\n                    } else {\n                        dispatch(changeMonsterAI(spell, currMonster));\n                    }\n                }\n\n                // take a turn if the player attacked something\n                dispatch({\n                    type: 'TAKE_TURN',\n                    payload: null,\n                });\n\n                dispatch(applyEffects());\n            } else {\n                // Hit a wall or something else\n                dispatch({\n                    type: 'CAST_SPELL',\n                    payload: { position: spellPosition, projectile: spell },\n                });\n            }\n        }\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}