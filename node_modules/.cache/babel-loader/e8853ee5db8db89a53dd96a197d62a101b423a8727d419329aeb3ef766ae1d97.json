{"ast":null,"code":"import { calculateDamage } from '../../../utils/dice';\nimport { SPRITE_SIZE, AI_CHANGE_TURNS, POISON_DAMAGE } from '../../../config/constants';\nexport default function monsterCastSpell(monster) {\n  return (dispatch, getState) => {\n    const {\n      stats,\n      player,\n      world\n    } = getState();\n    const {\n      id,\n      attackValue,\n      dice,\n      type,\n      position\n    } = monster;\n    const {\n      currentMap\n    } = world;\n    const target = monster.projectile.target.split('::');\n    if (target[0] === 'self') {\n      dispatch({\n        type: 'MONSTER_CAST_SPELL',\n        payload: {\n          position,\n          direction: 'NORTH',\n          entity: monster.type,\n          spell: monster.projectile\n        }\n      });\n      const healAmount = calculateDamage(monster.projectile.damage);\n      if (target[1] === 'heal') {\n        dispatch({\n          type: 'MONSTER_HEAL_HP',\n          payload: {\n            healAmount,\n            id,\n            map: currentMap,\n            entity: type\n          }\n        });\n      }\n    } else {\n      const attack = calculateDamage(attackValue);\n      const calculatedMonsterDamage = attack >= Math.max(stats.defence, 0) ? calculateDamage(dice) : 0;\n      dispatch({\n        type: 'MONSTER_ABILITY_CHECK',\n        payload: {\n          attackValue: attack,\n          check: Math.max(stats.defence, 0),\n          against: 'defence',\n          entity: type,\n          defender: 'player'\n        }\n      });\n      const targetPosition = [position[0] - player.position[0], position[1] - player.position[1]];\n      let direction = '';\n      if (player.position[0] !== position[0]) {\n        if (player.position[0] < position[0]) {\n          direction = 'WEST';\n          targetPosition[0] -= SPRITE_SIZE;\n        } else {\n          direction = 'EAST';\n          targetPosition[0] += SPRITE_SIZE;\n        }\n      } else if (player.position[1] !== position[1]) {\n        if (player.position[1] < position[1]) {\n          direction = 'NORTH';\n          targetPosition[1] -= SPRITE_SIZE;\n        } else {\n          direction = 'SOUTH';\n          targetPosition[1] += SPRITE_SIZE;\n        }\n      }\n      dispatch({\n        type: 'MONSTER_CAST_SPELL',\n        payload: {\n          position: targetPosition,\n          direction,\n          entity: monster.type,\n          spell: monster.projectile\n        }\n      });\n      if (calculatedMonsterDamage > 0) {\n        // show the attack animation and play sound\n        dispatch({\n          type: 'MONSTER_ATTACK',\n          payload: null\n        });\n        const {\n          changeAI\n        } = monster.projectile.effects;\n        if (changeAI) {\n          if (player.effects[changeAI.to] && player.effects[changeAI.to].immunityTurns <= 0) {\n            dispatch({\n              type: 'EFFECT_PLAYER',\n              payload: {\n                effect: changeAI.to,\n                turns: AI_CHANGE_TURNS,\n                damage: POISON_DAMAGE,\n                from: changeAI.effect\n              }\n            });\n          }\n        }\n      }\n      dispatch({\n        type: 'DAMAGE_TO_PLAYER',\n        payload: {\n          damage: calculatedMonsterDamage,\n          entity: type\n        }\n      });\n\n      // check if player died\n      if (stats.hp - calculatedMonsterDamage <= 0) {\n        // play death sound\n        dispatch({\n          type: 'PLAYER_DIED',\n          payload: {\n            entity: type\n          }\n        });\n        // if it did, game over\n        dispatch({\n          type: 'PAUSE',\n          payload: {\n            gameOver: true,\n            pause: true\n          }\n        });\n      }\n    }\n  };\n}","map":{"version":3,"names":["calculateDamage","SPRITE_SIZE","AI_CHANGE_TURNS","POISON_DAMAGE","monsterCastSpell","monster","dispatch","getState","stats","player","world","id","attackValue","dice","type","position","currentMap","target","projectile","split","payload","direction","entity","spell","healAmount","damage","map","attack","calculatedMonsterDamage","Math","max","defence","check","against","defender","targetPosition","changeAI","effects","to","immunityTurns","effect","turns","from","hp","gameOver","pause"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/monsters/actions/monster-cast-spell.jsx"],"sourcesContent":["import { calculateDamage } from '../../../utils/dice';\nimport {\n    SPRITE_SIZE,\n    AI_CHANGE_TURNS,\n    POISON_DAMAGE,\n} from '../../../config/constants';\n\nexport default function monsterCastSpell(monster) {\n    return (dispatch, getState) => {\n        const { stats, player, world } = getState();\n        const { id, attackValue, dice, type, position } = monster;\n        const { currentMap } = world;\n\n        const target = monster.projectile.target.split('::');\n\n        if (target[0] === 'self') {\n            dispatch({\n                type: 'MONSTER_CAST_SPELL',\n                payload: {\n                    position,\n                    direction: 'NORTH',\n                    entity: monster.type,\n                    spell: monster.projectile,\n                },\n            });\n\n            const healAmount = calculateDamage(monster.projectile.damage);\n\n            if (target[1] === 'heal') {\n                dispatch({\n                    type: 'MONSTER_HEAL_HP',\n                    payload: { healAmount, id, map: currentMap, entity: type },\n                });\n            }\n        } else {\n            const attack = calculateDamage(attackValue);\n            const calculatedMonsterDamage =\n                attack >= Math.max(stats.defence, 0)\n                    ? calculateDamage(dice)\n                    : 0;\n\n            dispatch({\n                type: 'MONSTER_ABILITY_CHECK',\n                payload: {\n                    attackValue: attack,\n                    check: Math.max(stats.defence, 0),\n                    against: 'defence',\n                    entity: type,\n                    defender: 'player',\n                },\n            });\n\n            const targetPosition = [\n                position[0] - player.position[0],\n                position[1] - player.position[1],\n            ];\n\n            let direction = '';\n            if (player.position[0] !== position[0]) {\n                if (player.position[0] < position[0]) {\n                    direction = 'WEST';\n                    targetPosition[0] -= SPRITE_SIZE;\n                } else {\n                    direction = 'EAST';\n                    targetPosition[0] += SPRITE_SIZE;\n                }\n            } else if (player.position[1] !== position[1]) {\n                if (player.position[1] < position[1]) {\n                    direction = 'NORTH';\n                    targetPosition[1] -= SPRITE_SIZE;\n                } else {\n                    direction = 'SOUTH';\n                    targetPosition[1] += SPRITE_SIZE;\n                }\n            }\n\n            dispatch({\n                type: 'MONSTER_CAST_SPELL',\n                payload: {\n                    position: targetPosition,\n                    direction,\n                    entity: monster.type,\n                    spell: monster.projectile,\n                },\n            });\n\n            if (calculatedMonsterDamage > 0) {\n                // show the attack animation and play sound\n                dispatch({\n                    type: 'MONSTER_ATTACK',\n                    payload: null,\n                });\n\n                const { changeAI } = monster.projectile.effects;\n                if (changeAI) {\n                    if (\n                        player.effects[changeAI.to] &&\n                        player.effects[changeAI.to].immunityTurns <= 0\n                    ) {\n                        dispatch({\n                            type: 'EFFECT_PLAYER',\n                            payload: {\n                                effect: changeAI.to,\n                                turns: AI_CHANGE_TURNS,\n                                damage: POISON_DAMAGE,\n                                from: changeAI.effect,\n                            },\n                        });\n                    }\n                }\n            }\n\n            dispatch({\n                type: 'DAMAGE_TO_PLAYER',\n                payload: { damage: calculatedMonsterDamage, entity: type },\n            });\n\n            // check if player died\n            if (stats.hp - calculatedMonsterDamage <= 0) {\n                // play death sound\n                dispatch({\n                    type: 'PLAYER_DIED',\n                    payload: { entity: type },\n                });\n                // if it did, game over\n                dispatch({\n                    type: 'PAUSE',\n                    payload: {\n                        gameOver: true,\n                        pause: true,\n                    },\n                });\n            }\n        }\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}