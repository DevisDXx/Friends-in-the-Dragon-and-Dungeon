{"ast":null,"code":"import _cloneDeep from 'lodash.clonedeep';\nimport attachMetaToTiles from '../../utils/attach-meta-to-tiles';\nimport generatePaddingTiles from '../../utils/generate-padding-tiles';\nimport maps from '../../data/maps';\nimport { getChestName } from '../../utils/get-chest-name';\nconst initialState = {\n  currentMap: null,\n  gameMode: null,\n  turn: 0,\n  storyMaps: {},\n  randomMaps: [],\n  chests: {},\n  floorNum: null,\n  mapTransition: false\n};\nconst worldReducer = function () {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let {\n    type,\n    payload\n  } = arguments.length > 1 ? arguments[1] : undefined;\n  let newState;\n  let currentMapData;\n  switch (type) {\n    case 'MAP_TRANSITION':\n      return {\n        ...state,\n        mapTransition: !state.mapTransition\n      };\n    case 'ADD_BLOOD_SPILL':\n      newState = _cloneDeep(state);\n      currentMapData = getCurrentMap(newState);\n      // we need this check to not override chests, stairs, etc.\n      // check if the next tile is an empty one\n      if (currentMapData.tiles[payload.y][payload.x].value === 0) {\n        // set current tile to blood spill tile\n        currentMapData.tiles[payload.y][payload.x].value = -1;\n      }\n      return newState;\n    case 'SET_CHEST_DATA':\n      newState = _cloneDeep(state);\n      currentMapData = getCurrentMap(newState);\n      if (payload) {\n        // We pass 'false' around if we're setting up a new chest, so here we've got an existing chest\n        const {\n          x,\n          y,\n          item\n        } = payload;\n        if (item === null) {\n          // This chest has either been completely looted, or there never was an item in it.\n          // This will make the chest appear to the player as open.\n          currentMapData.tiles[y][x].value = -2;\n        }\n        if (x !== undefined && y !== undefined) {\n          // This will either:\n          //   1. Ensure any item's left in the chest are still there, or\n          //   2. Ensure that the item for this chest is null (meaning it\n          //      either never had an item, or it was just looted completely)\n          newState.chests[getChestName(state.currentMap, x, y)] = {\n            item: item\n          };\n        }\n      }\n      return newState;\n    case 'OPEN_CHEST':\n      const {\n        x,\n        y\n      } = payload;\n      const chest = state.chests[getChestName(state.currentMap, x, y)];\n      if (chest === undefined) {\n        // This chest hasn't been opened before, so let's generate one\n        state.chests[getChestName(state.currentMap, x, y)] = {\n          item: null\n        };\n      }\n      newState = _cloneDeep(state);\n      currentMapData = getCurrentMap(newState);\n      return newState;\n    case 'EXPLORE_TILES':\n      newState = _cloneDeep(state);\n      const {\n        tiles,\n        paddingTiles\n      } = payload;\n      currentMapData = getCurrentMap(newState);\n      // get each tile\n      tiles.forEach(tile => {\n        currentMapData.tiles[tile[1]][tile[0]].explored = 1;\n      });\n\n      // create new array of the padding tiles location as strings\n      // make sure to reverse the padding tiles values to get them in [y, x],\n      // which is the format the map reads them (since its a 2d array, columns then rows)\n      const paddTiles = paddingTiles.map(value => JSON.stringify(value.reverse()));\n      // check each padding tile direction and see if any\n      // tiles are contained in the new sightbox\n      if (paddTiles.length > 0) {\n        Object.keys(currentMapData.paddingTiles).forEach(direction => {\n          currentMapData.paddingTiles[direction] = currentMapData.paddingTiles[direction].map(tileRow => {\n            return tileRow.map(tile => {\n              if (paddTiles.indexOf(JSON.stringify(tile.location)) > -1) {\n                tile.explored = 1;\n              }\n              return tile;\n            });\n          });\n        });\n      }\n      return newState;\n    case 'LOAD_STORY_MAPS':\n      const _maps = _cloneDeep(maps);\n      // go over each story map and add explored values\n      // and variation data to the tiles\n      Object.keys(_maps).forEach(mapName => {\n        const newTiles = attachMetaToTiles(_maps[mapName].tiles);\n        const newPaddTiles = generatePaddingTiles();\n        _maps[mapName] = {\n          ..._maps[mapName],\n          tiles: newTiles,\n          paddingTiles: newPaddTiles\n        };\n      });\n      return {\n        ...state,\n        storyMaps: _maps\n      };\n    case 'ADD_RANDOM_MAP':\n      const _randomMaps = _cloneDeep(state.randomMaps);\n      const randomTiles = attachMetaToTiles(payload.tiles);\n      const randomPaddTiles = generatePaddingTiles();\n      _randomMaps.push({\n        tiles: randomTiles,\n        id: payload.id,\n        paddingTiles: randomPaddTiles\n      });\n      return {\n        ...state,\n        randomMaps: _randomMaps\n      };\n    case 'TAKE_TURN':\n      // increment the turn\n      return {\n        ...state,\n        turn: state.turn + 1\n      };\n    case 'SET_STORY_MAP':\n      const {\n        direction,\n        currentMap\n      } = payload;\n      const {\n        stairs\n      } = state.storyMaps[currentMap];\n      return {\n        ...state,\n        currentMap: stairs[direction]\n      };\n    case 'SET_ENDLESS_MAP':\n      return {\n        ...state,\n        currentMap: payload.map,\n        floorNum: payload.floorNum\n      };\n    case 'SET_START_MAP':\n      const {\n        startMap,\n        gameMode,\n        floorNum\n      } = payload;\n      return {\n        ...state,\n        gameMode,\n        currentMap: startMap,\n        floorNum: floorNum ? floorNum : state.floorNum\n      };\n    case 'RESET':\n      return initialState;\n    case 'LOAD_DATA':\n      return {\n        ...initialState,\n        ...payload.world\n      };\n    default:\n      return state;\n  }\n\n  // returns a reference to the object on newState with the map data\n  function getCurrentMap(stateObj) {\n    if (stateObj.gameMode === 'story') {\n      return stateObj.storyMaps[stateObj.currentMap];\n    } else {\n      return stateObj.randomMaps[stateObj.floorNum - 1];\n    }\n  }\n};\nexport default worldReducer;","map":{"version":3,"names":["_cloneDeep","attachMetaToTiles","generatePaddingTiles","maps","getChestName","initialState","currentMap","gameMode","turn","storyMaps","randomMaps","chests","floorNum","mapTransition","worldReducer","state","arguments","length","undefined","type","payload","newState","currentMapData","getCurrentMap","tiles","y","x","value","item","chest","paddingTiles","forEach","tile","explored","paddTiles","map","JSON","stringify","reverse","Object","keys","direction","tileRow","indexOf","location","_maps","mapName","newTiles","newPaddTiles","_randomMaps","randomTiles","randomPaddTiles","push","id","stairs","startMap","world","stateObj"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/world/reducer.jsx"],"sourcesContent":["import _cloneDeep from 'lodash.clonedeep';\n\nimport attachMetaToTiles from '../../utils/attach-meta-to-tiles';\nimport generatePaddingTiles from '../../utils/generate-padding-tiles';\nimport maps from '../../data/maps';\n\nimport { getChestName } from '../../utils/get-chest-name';\n\nconst initialState = {\n  currentMap: null,\n  gameMode: null,\n  turn: 0,\n  storyMaps: {},\n  randomMaps: [],\n  chests: {},\n  floorNum: null,\n  mapTransition: false,\n};\n\nconst worldReducer = (state = initialState, { type, payload }) => {\n  let newState;\n  let currentMapData;\n\n  switch (type) {\n    case 'MAP_TRANSITION':\n      return { ...state, mapTransition: !state.mapTransition };\n\n    case 'ADD_BLOOD_SPILL':\n      newState = _cloneDeep(state);\n      currentMapData = getCurrentMap(newState);\n      // we need this check to not override chests, stairs, etc.\n      // check if the next tile is an empty one\n      if (currentMapData.tiles[payload.y][payload.x].value === 0) {\n        // set current tile to blood spill tile\n        currentMapData.tiles[payload.y][payload.x].value = -1;\n      }\n      return newState;\n\n    case 'SET_CHEST_DATA':\n      newState = _cloneDeep(state);\n      currentMapData = getCurrentMap(newState);\n\n      if (payload) {\n        // We pass 'false' around if we're setting up a new chest, so here we've got an existing chest\n        const { x, y, item } = payload;\n        if (item === null) {\n          // This chest has either been completely looted, or there never was an item in it.\n          // This will make the chest appear to the player as open.\n          currentMapData.tiles[y][x].value = -2;\n        }\n\n        if (x !== undefined && y !== undefined) {\n          // This will either:\n          //   1. Ensure any item's left in the chest are still there, or\n          //   2. Ensure that the item for this chest is null (meaning it\n          //      either never had an item, or it was just looted completely)\n          newState.chests[getChestName(state.currentMap, x, y)] = {\n            item: item,\n          };\n        }\n      }\n\n      return newState;\n\n    case 'OPEN_CHEST':\n      const { x, y } = payload;\n      const chest = state.chests[getChestName(state.currentMap, x, y)];\n      if (chest === undefined) {\n        // This chest hasn't been opened before, so let's generate one\n        state.chests[getChestName(state.currentMap, x, y)] = {\n          item: null,\n        };\n      }\n\n      newState = _cloneDeep(state);\n      currentMapData = getCurrentMap(newState);\n\n      return newState;\n\n    case 'EXPLORE_TILES':\n      newState = _cloneDeep(state);\n\n      const { tiles, paddingTiles } = payload;\n      currentMapData = getCurrentMap(newState);\n      // get each tile\n      tiles.forEach((tile) => {\n        currentMapData.tiles[tile[1]][tile[0]].explored = 1;\n      });\n\n      // create new array of the padding tiles location as strings\n      // make sure to reverse the padding tiles values to get them in [y, x],\n      // which is the format the map reads them (since its a 2d array, columns then rows)\n      const paddTiles = paddingTiles.map((value) => JSON.stringify(value.reverse()));\n      // check each padding tile direction and see if any\n      // tiles are contained in the new sightbox\n      if (paddTiles.length > 0) {\n        Object.keys(currentMapData.paddingTiles).forEach((direction) => {\n          currentMapData.paddingTiles[direction] = currentMapData.paddingTiles[direction].map(\n            (tileRow) => {\n              return tileRow.map((tile) => {\n                if (paddTiles.indexOf(JSON.stringify(tile.location)) > -1) {\n                  tile.explored = 1;\n                }\n                return tile;\n              });\n            }\n          );\n        });\n      }\n\n      return newState;\n\n    case 'LOAD_STORY_MAPS':\n      const _maps = _cloneDeep(maps);\n      // go over each story map and add explored values\n      // and variation data to the tiles\n      Object.keys(_maps).forEach((mapName) => {\n        const newTiles = attachMetaToTiles(_maps[mapName].tiles);\n        const newPaddTiles = generatePaddingTiles();\n\n        _maps[mapName] = {\n          ..._maps[mapName],\n          tiles: newTiles,\n          paddingTiles: newPaddTiles,\n        };\n      });\n\n      return { ...state, storyMaps: _maps };\n\n    case 'ADD_RANDOM_MAP':\n      const _randomMaps = _cloneDeep(state.randomMaps);\n\n      const randomTiles = attachMetaToTiles(payload.tiles);\n      const randomPaddTiles = generatePaddingTiles();\n\n      _randomMaps.push({\n        tiles: randomTiles,\n        id: payload.id,\n        paddingTiles: randomPaddTiles,\n      });\n\n      return { ...state, randomMaps: _randomMaps };\n\n    case 'TAKE_TURN':\n      // increment the turn\n      return { ...state, turn: state.turn + 1 };\n\n    case 'SET_STORY_MAP':\n      const { direction, currentMap } = payload;\n\n      const { stairs } = state.storyMaps[currentMap];\n\n      return { ...state, currentMap: stairs[direction] };\n\n    case 'SET_ENDLESS_MAP':\n      return {\n        ...state,\n        currentMap: payload.map,\n        floorNum: payload.floorNum,\n      };\n\n    case 'SET_START_MAP':\n      const { startMap, gameMode, floorNum } = payload;\n\n      return {\n        ...state,\n        gameMode,\n        currentMap: startMap,\n        floorNum: floorNum ? floorNum : state.floorNum,\n      };\n\n    case 'RESET':\n      return initialState;\n\n    case 'LOAD_DATA':\n      return { ...initialState, ...payload.world };\n\n    default:\n      return state;\n  }\n\n  // returns a reference to the object on newState with the map data\n  function getCurrentMap(stateObj) {\n    if (stateObj.gameMode === 'story') {\n      return stateObj.storyMaps[stateObj.currentMap];\n    } else {\n      return stateObj.randomMaps[stateObj.floorNum - 1];\n    }\n  }\n};\n\nexport default worldReducer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}