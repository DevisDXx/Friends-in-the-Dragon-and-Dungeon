{"ast":null,"code":"import { getNewPosition } from '../../player/actions/move-player';\nimport getNextTile from '../../../utils/get-next-tile';\nimport { SPRITE_SIZE } from '../../../config/constants';\nimport { radiusTiles } from '../../../utils/get-surrounding-tiles';\nconst MONSTER_ATTACK_RADIUS = 1;\nexport function getRandomDirection() {\n  const directions = ['up', 'down', 'left', 'right'];\n  const randomNumber = Math.floor(Math.random() * directions.length);\n  return directions[randomNumber];\n}\nexport const playerInView = (monsterPosition, range) => {\n  return (dispatch, getState) => {\n    const {\n      position\n    } = getState().player;\n    monsterPosition = monsterPosition.map(val => val * SPRITE_SIZE);\n    range *= SPRITE_SIZE;\n    for (let y = monsterPosition[1]; y > monsterPosition[1] - range; y -= SPRITE_SIZE) {\n      const pos = getNewPosition([monsterPosition[0], y], 'NORTH');\n      if (!dispatch(observeImpassable(pos))) break;\n      if (position[0] === pos[0] && position[1] === pos[1]) {\n        return true;\n      }\n    }\n    for (let y = monsterPosition[1]; y < monsterPosition[1] + range; y += SPRITE_SIZE) {\n      const pos = getNewPosition([monsterPosition[0], y], 'SOUTH');\n      if (!dispatch(observeImpassable(pos))) break;\n      if (position[0] === pos[0] && position[1] === pos[1]) {\n        return true;\n      }\n    }\n    for (let x = monsterPosition[0]; x < monsterPosition[0] + range; x += SPRITE_SIZE) {\n      const pos = getNewPosition([x, monsterPosition[1]], 'EAST');\n      if (!dispatch(observeImpassable(pos))) break;\n      if (position[0] === pos[0] && position[1] === pos[1]) {\n        return true;\n      }\n    }\n    for (let x = monsterPosition[0]; x > monsterPosition[0] - range; x -= SPRITE_SIZE) {\n      const pos = getNewPosition([x, monsterPosition[1]], 'WEST');\n      if (!dispatch(observeImpassable(pos))) break;\n      if (position[0] === pos[0] && position[1] === pos[1]) {\n        return true;\n      }\n    }\n    return false;\n  };\n};\nexport function playerInRange(playerPos, monsterPos) {\n  let range = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MONSTER_ATTACK_RADIUS;\n  let inRange = false;\n  // for each tile around the monster\n  radiusTiles(range).forEach(tile => {\n    // add the monsters location\n    const offsetX = tile.x + monsterPos[0];\n    const offsetY = tile.y + monsterPos[1];\n    // see if the player is in range\n    const playerLocation = playerPos.map(value => value / SPRITE_SIZE);\n    if (JSON.stringify([offsetX, offsetY]) === JSON.stringify(playerLocation)) {\n      inRange = true;\n    }\n  });\n  return inRange;\n}\nexport function observeImpassable(newPos) {\n  return (_, getState) => {\n    const nextTile = getNextTile(getState().world, newPos);\n    return nextTile < 5 ? newPos : false;\n  };\n}\n\n/**\n * Check to see if any other monster is at the position this monster is trying to move to\n *\n * @param {*} id The id of the monster that's trying to move\n * @param {*} position The position its moving to\n * @param {*} currentMap THe map that the monsrer is in\n */\nexport function checkForOtherMonster(id, position, currentMap) {\n  return (_, getState) => {\n    // get current monsters\n    const monsterList = getState().monsters.components[currentMap];\n    // check list of monsters\n    return Object.keys(monsterList).filter(monsterID => {\n      const monster = monsterList[monsterID];\n      // see if there's another monster in the next position\n      return monsterID !== id && monster.position[0] === position[0] && monster.position[1] === position[1];\n    }).pop();\n  };\n}","map":{"version":3,"names":["getNewPosition","getNextTile","SPRITE_SIZE","radiusTiles","MONSTER_ATTACK_RADIUS","getRandomDirection","directions","randomNumber","Math","floor","random","length","playerInView","monsterPosition","range","dispatch","getState","position","player","map","val","y","pos","observeImpassable","x","playerInRange","playerPos","monsterPos","arguments","undefined","inRange","forEach","tile","offsetX","offsetY","playerLocation","value","JSON","stringify","newPos","_","nextTile","world","checkForOtherMonster","id","currentMap","monsterList","monsters","components","Object","keys","filter","monsterID","monster","pop"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/monsters/actions/move-monster.jsx"],"sourcesContent":["import { getNewPosition } from '../../player/actions/move-player';\nimport getNextTile from '../../../utils/get-next-tile';\nimport { SPRITE_SIZE } from '../../../config/constants';\nimport { radiusTiles } from '../../../utils/get-surrounding-tiles';\n\nconst MONSTER_ATTACK_RADIUS = 1;\nexport function getRandomDirection() {\n  const directions = ['up', 'down', 'left', 'right'];\n  const randomNumber = Math.floor(Math.random() * directions.length);\n  return directions[randomNumber];\n}\n\nexport const playerInView = (monsterPosition, range) => {\n  return (dispatch, getState) => {\n    const { position } = getState().player;\n\n    monsterPosition = monsterPosition.map((val) => val * SPRITE_SIZE);\n    range *= SPRITE_SIZE;\n\n    for (let y = monsterPosition[1]; y > monsterPosition[1] - range; y -= SPRITE_SIZE) {\n      const pos = getNewPosition([monsterPosition[0], y], 'NORTH');\n      if (!dispatch(observeImpassable(pos))) break;\n      if (position[0] === pos[0] && position[1] === pos[1]) {\n        return true;\n      }\n    }\n    for (let y = monsterPosition[1]; y < monsterPosition[1] + range; y += SPRITE_SIZE) {\n      const pos = getNewPosition([monsterPosition[0], y], 'SOUTH');\n      if (!dispatch(observeImpassable(pos))) break;\n      if (position[0] === pos[0] && position[1] === pos[1]) {\n        return true;\n      }\n    }\n\n    for (let x = monsterPosition[0]; x < monsterPosition[0] + range; x += SPRITE_SIZE) {\n      const pos = getNewPosition([x, monsterPosition[1]], 'EAST');\n      if (!dispatch(observeImpassable(pos))) break;\n      if (position[0] === pos[0] && position[1] === pos[1]) {\n        return true;\n      }\n    }\n\n    for (let x = monsterPosition[0]; x > monsterPosition[0] - range; x -= SPRITE_SIZE) {\n      const pos = getNewPosition([x, monsterPosition[1]], 'WEST');\n      if (!dispatch(observeImpassable(pos))) break;\n      if (position[0] === pos[0] && position[1] === pos[1]) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n};\n\nexport function playerInRange(playerPos, monsterPos, range = MONSTER_ATTACK_RADIUS) {\n  let inRange = false;\n  // for each tile around the monster\n  radiusTiles(range).forEach((tile) => {\n    // add the monsters location\n    const offsetX = tile.x + monsterPos[0];\n    const offsetY = tile.y + monsterPos[1];\n    // see if the player is in range\n    const playerLocation = playerPos.map((value) => value / SPRITE_SIZE);\n    if (JSON.stringify([offsetX, offsetY]) === JSON.stringify(playerLocation)) {\n      inRange = true;\n    }\n  });\n  return inRange;\n}\n\nexport function observeImpassable(newPos) {\n  return (_, getState) => {\n    const nextTile = getNextTile(getState().world, newPos);\n\n    return nextTile < 5 ? newPos : false;\n  };\n}\n\n/**\n * Check to see if any other monster is at the position this monster is trying to move to\n *\n * @param {*} id The id of the monster that's trying to move\n * @param {*} position The position its moving to\n * @param {*} currentMap THe map that the monsrer is in\n */\nexport function checkForOtherMonster(id, position, currentMap) {\n  return (_, getState) => {\n    // get current monsters\n    const monsterList = getState().monsters.components[currentMap];\n    // check list of monsters\n    return Object.keys(monsterList)\n      .filter((monsterID) => {\n        const monster = monsterList[monsterID];\n        // see if there's another monster in the next position\n        return (\n          monsterID !== id &&\n          monster.position[0] === position[0] &&\n          monster.position[1] === position[1]\n        );\n      })\n      .pop();\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}