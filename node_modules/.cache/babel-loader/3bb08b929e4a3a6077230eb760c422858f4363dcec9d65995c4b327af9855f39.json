{"ast":null,"code":"import arrContainArr from '../../../utils/arr-contain-arr';\nimport getSurroundingTiles from '../../../utils/get-surrounding-tiles';\nimport { MAP_DIMENSIONS } from '../../../config/constants';\n\n/**\n * Generate all of the objects in the map, such as shops, chests.\n *\n * @param {*} map The map to generate the objects into\n * @param {*} floorNumber The floor number\n * @param {*} playerPosition The players position\n * @param {*} wallType The type of wall in the map\n */\nexport default function generateObjects(map, floorNumber, playerPosition, wallType) {\n  const initialTiles = [];\n  // we need to get the tiles from the surrounding tiles func,\n  // then reverse the coordinates because they come back in normal notation (y, x)\n  // but for the random map gen, we need them in (x, y)\n  const vision = getSurroundingTiles(playerPosition).tiles.map(tile => tile.reverse());\n  for (let i = 0; i < MAP_DIMENSIONS[1]; i++) {\n    for (let j = 0; j < MAP_DIMENSIONS[0]; j++) {\n      // get a list of floor tiles\n      if (map[i][j] === 0) {\n        initialTiles.push([i, j]);\n      }\n    }\n  }\n  const availableTiles = initialTiles.filter(value => {\n    // remove the available tiles that are vision tiles\n    return !arrContainArr(vision, value);\n  });\n\n  // show stairs down if floor is greater than 1\n  if (floorNumber > 1) {\n    map[playerPosition[1]][playerPosition[0]] = 2;\n  }\n\n  // generate stairs up OUTSIDE the player's sight if possible\n  if (availableTiles.length > 0) {\n    const randomIndex = Math.floor(Math.random() * availableTiles.length);\n    const tile = availableTiles[randomIndex];\n    map[tile[0]][tile[1]] = 3;\n    availableTiles.splice(randomIndex, 1);\n  } // if we don't have room outside player sight, place stairs on any floor tile\n  else {\n    const randomIndex = Math.floor(Math.random() * initialTiles.length);\n    const tile = initialTiles[randomIndex];\n    // if the tile is occupied by the player\n    // remove the player's position from available tiles and get another random one\n    if (tile[0] === playerPosition[1] && tile[1] === playerPosition[0]) {\n      initialTiles.splice(randomIndex, 1);\n      const newRandomIndex = Math.floor(Math.random() * initialTiles.length);\n      const newTile = initialTiles[newRandomIndex];\n      map[newTile[0]][newTile[1]] = 3;\n    } // safely place the stairs\n    else {\n      map[tile[0]][tile[1]] = 3;\n    }\n  }\n\n  // generate a random number of chests between 0 - 5\n  const max = 5;\n  const min = 0;\n  const randomChests = Math.round(Math.random() * (max - min) + min);\n  // place the chests on empty tiles\n  for (let x = 0; x < randomChests; x++) {\n    if (availableTiles.length > 0) {\n      const randomIndex = Math.floor(Math.random() * availableTiles.length);\n      const tile = availableTiles[randomIndex];\n      map[tile[0]][tile[1]] = 4;\n      availableTiles.splice(randomIndex, 1);\n    }\n  }\n\n  // generate a shop every 4 floors\n  if (floorNumber % 4 === 0) {\n    const availableWalls = [];\n\n    // get a list of available wall tiles\n    for (let i = 0; i < MAP_DIMENSIONS[1]; i++) {\n      for (let j = 0; j < MAP_DIMENSIONS[0]; j++) {\n        // make sure the wall tile touches a path so it can be reached\n        if (map[i][j] === wallType && (i - 1 > 0 && map[i - 1][j] === 0 || i + 1 < MAP_DIMENSIONS[1] && map[i + 1][j] === 0 || j - 1 > 0 && map[i][j - 1] === 0 || j + 1 < MAP_DIMENSIONS[0] && map[i][j + 1] === 0)) {\n          availableWalls.push([i, j]);\n        }\n      }\n    }\n    map = generateShop(map, availableWalls);\n  }\n  return map;\n}\n\n/**\n * Add a shop to the map\n *\n * @param {*} map The map we're working with\n * @param {*} availableWalls All of the available wall tiles\n */\nfunction generateShop(map, availableWalls) {\n  if (availableWalls.length > 0) {\n    const randomIndex = Math.floor(Math.random() * availableWalls.length);\n    const tile = availableWalls[randomIndex];\n    map[tile[0]][tile[1]] = 9;\n  }\n  return map;\n}","map":{"version":3,"names":["arrContainArr","getSurroundingTiles","MAP_DIMENSIONS","generateObjects","map","floorNumber","playerPosition","wallType","initialTiles","vision","tiles","tile","reverse","i","j","push","availableTiles","filter","value","length","randomIndex","Math","floor","random","splice","newRandomIndex","newTile","max","min","randomChests","round","x","availableWalls","generateShop"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/map/random-map-gen/generate-objects.jsx"],"sourcesContent":["import arrContainArr from '../../../utils/arr-contain-arr';\nimport getSurroundingTiles from '../../../utils/get-surrounding-tiles';\nimport { MAP_DIMENSIONS } from '../../../config/constants';\n\n/**\n * Generate all of the objects in the map, such as shops, chests.\n *\n * @param {*} map The map to generate the objects into\n * @param {*} floorNumber The floor number\n * @param {*} playerPosition The players position\n * @param {*} wallType The type of wall in the map\n */\nexport default function generateObjects(map, floorNumber, playerPosition, wallType) {\n  const initialTiles = [];\n  // we need to get the tiles from the surrounding tiles func,\n  // then reverse the coordinates because they come back in normal notation (y, x)\n  // but for the random map gen, we need them in (x, y)\n  const vision = getSurroundingTiles(playerPosition).tiles.map((tile) => tile.reverse());\n\n  for (let i = 0; i < MAP_DIMENSIONS[1]; i++) {\n    for (let j = 0; j < MAP_DIMENSIONS[0]; j++) {\n      // get a list of floor tiles\n      if (map[i][j] === 0) {\n        initialTiles.push([i, j]);\n      }\n    }\n  }\n\n  const availableTiles = initialTiles.filter((value) => {\n    // remove the available tiles that are vision tiles\n    return !arrContainArr(vision, value);\n  });\n\n  // show stairs down if floor is greater than 1\n  if (floorNumber > 1) {\n    map[playerPosition[1]][playerPosition[0]] = 2;\n  }\n\n  // generate stairs up OUTSIDE the player's sight if possible\n  if (availableTiles.length > 0) {\n    const randomIndex = Math.floor(Math.random() * availableTiles.length);\n    const tile = availableTiles[randomIndex];\n\n    map[tile[0]][tile[1]] = 3;\n    availableTiles.splice(randomIndex, 1);\n  } // if we don't have room outside player sight, place stairs on any floor tile\n  else {\n    const randomIndex = Math.floor(Math.random() * initialTiles.length);\n    const tile = initialTiles[randomIndex];\n    // if the tile is occupied by the player\n    // remove the player's position from available tiles and get another random one\n    if (tile[0] === playerPosition[1] && tile[1] === playerPosition[0]) {\n      initialTiles.splice(randomIndex, 1);\n\n      const newRandomIndex = Math.floor(Math.random() * initialTiles.length);\n      const newTile = initialTiles[newRandomIndex];\n\n      map[newTile[0]][newTile[1]] = 3;\n    } // safely place the stairs\n    else {\n      map[tile[0]][tile[1]] = 3;\n    }\n  }\n\n  // generate a random number of chests between 0 - 5\n  const max = 5;\n  const min = 0;\n  const randomChests = Math.round(Math.random() * (max - min) + min);\n  // place the chests on empty tiles\n  for (let x = 0; x < randomChests; x++) {\n    if (availableTiles.length > 0) {\n      const randomIndex = Math.floor(Math.random() * availableTiles.length);\n      const tile = availableTiles[randomIndex];\n\n      map[tile[0]][tile[1]] = 4;\n      availableTiles.splice(randomIndex, 1);\n    }\n  }\n\n  // generate a shop every 4 floors\n  if (floorNumber % 4 === 0) {\n    const availableWalls = [];\n\n    // get a list of available wall tiles\n    for (let i = 0; i < MAP_DIMENSIONS[1]; i++) {\n      for (let j = 0; j < MAP_DIMENSIONS[0]; j++) {\n        // make sure the wall tile touches a path so it can be reached\n        if (\n          map[i][j] === wallType &&\n          ((i - 1 > 0 && map[i - 1][j] === 0) ||\n            (i + 1 < MAP_DIMENSIONS[1] && map[i + 1][j] === 0) ||\n            (j - 1 > 0 && map[i][j - 1] === 0) ||\n            (j + 1 < MAP_DIMENSIONS[0] && map[i][j + 1] === 0))\n        ) {\n          availableWalls.push([i, j]);\n        }\n      }\n    }\n\n    map = generateShop(map, availableWalls);\n  }\n\n  return map;\n}\n\n/**\n * Add a shop to the map\n *\n * @param {*} map The map we're working with\n * @param {*} availableWalls All of the available wall tiles\n */\nfunction generateShop(map, availableWalls) {\n  if (availableWalls.length > 0) {\n    const randomIndex = Math.floor(Math.random() * availableWalls.length);\n    const tile = availableWalls[randomIndex];\n\n    map[tile[0]][tile[1]] = 9;\n  }\n  return map;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}