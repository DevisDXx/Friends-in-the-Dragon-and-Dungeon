{"ast":null,"code":"import { calculateDamage } from '../../../utils/dice';\nimport { SPRITE_SIZE, AI_CHANGE_TURNS, POISON_DAMAGE } from '../../../config/constants';\nexport default function monsterCastSpell(monster) {\n  return (dispatch, getState) => {\n    const {\n      stats,\n      player,\n      world\n    } = getState();\n    const {\n      id,\n      attackValue,\n      dice,\n      type,\n      position\n    } = monster;\n    const {\n      currentMap\n    } = world;\n    const target = monster.projectile.target.split('::');\n    if (target[0] === 'self') {\n      dispatch({\n        type: 'MONSTER_CAST_SPELL',\n        payload: {\n          position,\n          direction: 'NORTH',\n          entity: monster.type,\n          spell: monster.projectile\n        }\n      });\n      const healAmount = calculateDamage(monster.projectile.damage);\n      if (target[1] === 'heal') {\n        dispatch({\n          type: 'MONSTER_HEAL_HP',\n          payload: {\n            healAmount,\n            id,\n            map: currentMap,\n            entity: type\n          }\n        });\n      }\n    } else {\n      const attack = calculateDamage(attackValue);\n      const calculatedMonsterDamage = attack >= Math.max(stats.defence, 0) ? calculateDamage(dice) : 0;\n      dispatch({\n        type: 'MONSTER_ABILITY_CHECK',\n        payload: {\n          attackValue: attack,\n          check: Math.max(stats.defence, 0),\n          against: 'defence',\n          entity: type,\n          defender: 'player'\n        }\n      });\n      const targetPosition = [position[0] - player.position[0], position[1] - player.position[1]];\n      let direction = '';\n      if (player.position[0] !== position[0]) {\n        if (player.position[0] < position[0]) {\n          direction = 'WEST';\n          targetPosition[0] -= SPRITE_SIZE;\n        } else {\n          direction = 'EAST';\n          targetPosition[0] += SPRITE_SIZE;\n        }\n      } else if (player.position[1] !== position[1]) {\n        if (player.position[1] < position[1]) {\n          direction = 'NORTH';\n          targetPosition[1] -= SPRITE_SIZE;\n        } else {\n          direction = 'SOUTH';\n          targetPosition[1] += SPRITE_SIZE;\n        }\n      }\n      dispatch({\n        type: 'MONSTER_CAST_SPELL',\n        payload: {\n          position: targetPosition,\n          direction,\n          entity: monster.type,\n          spell: monster.projectile\n        }\n      });\n      if (calculatedMonsterDamage > 0) {\n        // show the attack animation and play sound\n        dispatch({\n          type: 'MONSTER_ATTACK',\n          payload: null\n        });\n        const {\n          changeAI\n        } = monster.projectile.effects;\n        if (changeAI) {\n          if (player.effects[changeAI.to] && player.effects[changeAI.to].immunityTurns <= 0) {\n            dispatch({\n              type: 'EFFECT_PLAYER',\n              payload: {\n                effect: changeAI.to,\n                turns: AI_CHANGE_TURNS,\n                damage: POISON_DAMAGE,\n                from: changeAI.effect\n              }\n            });\n          }\n        }\n      }\n      dispatch({\n        type: 'DAMAGE_TO_PLAYER',\n        payload: {\n          damage: calculatedMonsterDamage,\n          entity: type\n        }\n      });\n\n      // check if player died\n      if (stats.hp - calculatedMonsterDamage <= 0) {\n        // play death sound\n        dispatch({\n          type: 'PLAYER_DIED',\n          payload: {\n            entity: type\n          }\n        });\n        // if it did, game over\n        dispatch({\n          type: 'PAUSE',\n          payload: {\n            gameOver: true,\n            pause: true\n          }\n        });\n      }\n    }\n  };\n}","map":{"version":3,"names":["calculateDamage","SPRITE_SIZE","AI_CHANGE_TURNS","POISON_DAMAGE","monsterCastSpell","monster","dispatch","getState","stats","player","world","id","attackValue","dice","type","position","currentMap","target","projectile","split","payload","direction","entity","spell","healAmount","damage","map","attack","calculatedMonsterDamage","Math","max","defence","check","against","defender","targetPosition","changeAI","effects","to","immunityTurns","effect","turns","from","hp","gameOver","pause"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/monsters/actions/monster-cast-spell.jsx"],"sourcesContent":["import { calculateDamage } from '../../../utils/dice';\nimport { SPRITE_SIZE, AI_CHANGE_TURNS, POISON_DAMAGE } from '../../../config/constants';\n\nexport default function monsterCastSpell(monster) {\n  return (dispatch, getState) => {\n    const { stats, player, world } = getState();\n    const { id, attackValue, dice, type, position } = monster;\n    const { currentMap } = world;\n\n    const target = monster.projectile.target.split('::');\n\n    if (target[0] === 'self') {\n      dispatch({\n        type: 'MONSTER_CAST_SPELL',\n        payload: {\n          position,\n          direction: 'NORTH',\n          entity: monster.type,\n          spell: monster.projectile,\n        },\n      });\n\n      const healAmount = calculateDamage(monster.projectile.damage);\n\n      if (target[1] === 'heal') {\n        dispatch({\n          type: 'MONSTER_HEAL_HP',\n          payload: { healAmount, id, map: currentMap, entity: type },\n        });\n      }\n    } else {\n      const attack = calculateDamage(attackValue);\n      const calculatedMonsterDamage =\n        attack >= Math.max(stats.defence, 0) ? calculateDamage(dice) : 0;\n\n      dispatch({\n        type: 'MONSTER_ABILITY_CHECK',\n        payload: {\n          attackValue: attack,\n          check: Math.max(stats.defence, 0),\n          against: 'defence',\n          entity: type,\n          defender: 'player',\n        },\n      });\n\n      const targetPosition = [position[0] - player.position[0], position[1] - player.position[1]];\n\n      let direction = '';\n      if (player.position[0] !== position[0]) {\n        if (player.position[0] < position[0]) {\n          direction = 'WEST';\n          targetPosition[0] -= SPRITE_SIZE;\n        } else {\n          direction = 'EAST';\n          targetPosition[0] += SPRITE_SIZE;\n        }\n      } else if (player.position[1] !== position[1]) {\n        if (player.position[1] < position[1]) {\n          direction = 'NORTH';\n          targetPosition[1] -= SPRITE_SIZE;\n        } else {\n          direction = 'SOUTH';\n          targetPosition[1] += SPRITE_SIZE;\n        }\n      }\n\n      dispatch({\n        type: 'MONSTER_CAST_SPELL',\n        payload: {\n          position: targetPosition,\n          direction,\n          entity: monster.type,\n          spell: monster.projectile,\n        },\n      });\n\n      if (calculatedMonsterDamage > 0) {\n        // show the attack animation and play sound\n        dispatch({\n          type: 'MONSTER_ATTACK',\n          payload: null,\n        });\n\n        const { changeAI } = monster.projectile.effects;\n        if (changeAI) {\n          if (player.effects[changeAI.to] && player.effects[changeAI.to].immunityTurns <= 0) {\n            dispatch({\n              type: 'EFFECT_PLAYER',\n              payload: {\n                effect: changeAI.to,\n                turns: AI_CHANGE_TURNS,\n                damage: POISON_DAMAGE,\n                from: changeAI.effect,\n              },\n            });\n          }\n        }\n      }\n\n      dispatch({\n        type: 'DAMAGE_TO_PLAYER',\n        payload: { damage: calculatedMonsterDamage, entity: type },\n      });\n\n      // check if player died\n      if (stats.hp - calculatedMonsterDamage <= 0) {\n        // play death sound\n        dispatch({\n          type: 'PLAYER_DIED',\n          payload: { entity: type },\n        });\n        // if it did, game over\n        dispatch({\n          type: 'PAUSE',\n          payload: {\n            gameOver: true,\n            pause: true,\n          },\n        });\n      }\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}