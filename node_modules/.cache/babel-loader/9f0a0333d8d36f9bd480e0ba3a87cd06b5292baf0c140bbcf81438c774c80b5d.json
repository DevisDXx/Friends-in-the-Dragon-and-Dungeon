{"ast":null,"code":"import _debounce from 'lodash.debounce';\nimport generateMap from '../../map/random-map-gen/generate-map';\nimport endlessMapMessage from '../../map/random-map-gen/endless-map-message';\nimport uuidv4 from '../../../utils/uuid-v4';\nimport { SPRITE_SIZE, MAP_TRANSITION_DELAY } from '../../../config/constants';\nexport default function walkStairs(nextTile, playerPos) {\n  return _debounce((dispatch, getState) => {\n    const {\n      gameMode,\n      randomMaps,\n      floorNum,\n      currentMap,\n      storyMaps\n    } = getState().world;\n    playerPos = playerPos.map(value => value / SPRITE_SIZE);\n    let direction;\n    // player wants to go down\n    if (nextTile === 2) direction = 'down';\n    // player wants to go up\n    if (nextTile === 3) direction = 'up';\n    if (gameMode === 'endless') {\n      if (direction === 'up') {\n        // conditionally show a message based on floorNum\n        dispatch(endlessMapMessage(floorNum));\n        // if we have reached a new floor\n        if (floorNum === randomMaps.length) {\n          // generate a random map, save it, and set it as the current map\n          const randomMap = generateMap(playerPos, floorNum + 1);\n          const mapId = uuidv4();\n          dispatch({\n            type: 'ADD_RANDOM_MAP',\n            payload: {\n              tiles: randomMap,\n              id: mapId\n            }\n          });\n          dispatch({\n            type: 'SET_ENDLESS_MAP',\n            payload: {\n              map: mapId,\n              floorNum: floorNum + 1\n            }\n          });\n        } else {\n          // figure out the next map and set it as the current\n          dispatch({\n            type: 'SET_ENDLESS_MAP',\n            payload: {\n              // pass the floorNum because with array indexing this will get the next map\n              map: randomMaps[floorNum].id,\n              floorNum: floorNum + 1\n            }\n          });\n        }\n      } else if (direction === 'down' && floorNum > 1) {\n        // figure out the previous map and set it as the current\n        dispatch({\n          type: 'SET_ENDLESS_MAP',\n          payload: {\n            // offset by 2 because we want the previous map and account for array indexing\n            map: randomMaps[floorNum - 2].id,\n            floorNum: floorNum - 1\n          }\n        });\n      }\n    } else {\n      // change the story mode map\n      dispatch({\n        type: 'SET_STORY_MAP',\n        payload: {\n          direction,\n          currentMap,\n          storyMaps\n        }\n      });\n    }\n  }, MAP_TRANSITION_DELAY);\n}","map":{"version":3,"names":["_debounce","generateMap","endlessMapMessage","uuidv4","SPRITE_SIZE","MAP_TRANSITION_DELAY","walkStairs","nextTile","playerPos","dispatch","getState","gameMode","randomMaps","floorNum","currentMap","storyMaps","world","map","value","direction","length","randomMap","mapId","type","payload","tiles","id"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/player/actions/walk-stairs.jsx"],"sourcesContent":["import _debounce from 'lodash.debounce';\n\nimport generateMap from '../../map/random-map-gen/generate-map';\nimport endlessMapMessage from '../../map/random-map-gen/endless-map-message';\nimport uuidv4 from '../../../utils/uuid-v4';\nimport { SPRITE_SIZE, MAP_TRANSITION_DELAY } from '../../../config/constants';\n\nexport default function walkStairs(nextTile, playerPos) {\n  return _debounce((dispatch, getState) => {\n    const { gameMode, randomMaps, floorNum, currentMap, storyMaps } = getState().world;\n\n    playerPos = playerPos.map((value) => value / SPRITE_SIZE);\n\n    let direction;\n    // player wants to go down\n    if (nextTile === 2) direction = 'down';\n    // player wants to go up\n    if (nextTile === 3) direction = 'up';\n\n    if (gameMode === 'endless') {\n      if (direction === 'up') {\n        // conditionally show a message based on floorNum\n        dispatch(endlessMapMessage(floorNum));\n        // if we have reached a new floor\n        if (floorNum === randomMaps.length) {\n          // generate a random map, save it, and set it as the current map\n          const randomMap = generateMap(playerPos, floorNum + 1);\n          const mapId = uuidv4();\n\n          dispatch({\n            type: 'ADD_RANDOM_MAP',\n            payload: {\n              tiles: randomMap,\n              id: mapId,\n            },\n          });\n          dispatch({\n            type: 'SET_ENDLESS_MAP',\n            payload: {\n              map: mapId,\n              floorNum: floorNum + 1,\n            },\n          });\n        } else {\n          // figure out the next map and set it as the current\n          dispatch({\n            type: 'SET_ENDLESS_MAP',\n            payload: {\n              // pass the floorNum because with array indexing this will get the next map\n              map: randomMaps[floorNum].id,\n              floorNum: floorNum + 1,\n            },\n          });\n        }\n      } else if (direction === 'down' && floorNum > 1) {\n        // figure out the previous map and set it as the current\n        dispatch({\n          type: 'SET_ENDLESS_MAP',\n          payload: {\n            // offset by 2 because we want the previous map and account for array indexing\n            map: randomMaps[floorNum - 2].id,\n            floorNum: floorNum - 1,\n          },\n        });\n      }\n    } else {\n      // change the story mode map\n      dispatch({\n        type: 'SET_STORY_MAP',\n        payload: { direction, currentMap, storyMaps },\n      });\n    }\n  }, MAP_TRANSITION_DELAY);\n}\n"],"mappings":"AAAA,OAAOA,SAAS,MAAM,iBAAiB;AAEvC,OAAOC,WAAW,MAAM,uCAAuC;AAC/D,OAAOC,iBAAiB,MAAM,8CAA8C;AAC5E,OAAOC,MAAM,MAAM,wBAAwB;AAC3C,SAASC,WAAW,EAAEC,oBAAoB,QAAQ,2BAA2B;AAE7E,eAAe,SAASC,UAAUA,CAACC,QAAQ,EAAEC,SAAS,EAAE;EACtD,OAAOR,SAAS,CAAC,CAACS,QAAQ,EAAEC,QAAQ,KAAK;IACvC,MAAM;MAAEC,QAAQ;MAAEC,UAAU;MAAEC,QAAQ;MAAEC,UAAU;MAAEC;IAAU,CAAC,GAAGL,QAAQ,CAAC,CAAC,CAACM,KAAK;IAElFR,SAAS,GAAGA,SAAS,CAACS,GAAG,CAAEC,KAAK,IAAKA,KAAK,GAAGd,WAAW,CAAC;IAEzD,IAAIe,SAAS;IACb;IACA,IAAIZ,QAAQ,KAAK,CAAC,EAAEY,SAAS,GAAG,MAAM;IACtC;IACA,IAAIZ,QAAQ,KAAK,CAAC,EAAEY,SAAS,GAAG,IAAI;IAEpC,IAAIR,QAAQ,KAAK,SAAS,EAAE;MAC1B,IAAIQ,SAAS,KAAK,IAAI,EAAE;QACtB;QACAV,QAAQ,CAACP,iBAAiB,CAACW,QAAQ,CAAC,CAAC;QACrC;QACA,IAAIA,QAAQ,KAAKD,UAAU,CAACQ,MAAM,EAAE;UAClC;UACA,MAAMC,SAAS,GAAGpB,WAAW,CAACO,SAAS,EAAEK,QAAQ,GAAG,CAAC,CAAC;UACtD,MAAMS,KAAK,GAAGnB,MAAM,CAAC,CAAC;UAEtBM,QAAQ,CAAC;YACPc,IAAI,EAAE,gBAAgB;YACtBC,OAAO,EAAE;cACPC,KAAK,EAAEJ,SAAS;cAChBK,EAAE,EAAEJ;YACN;UACF,CAAC,CAAC;UACFb,QAAQ,CAAC;YACPc,IAAI,EAAE,iBAAiB;YACvBC,OAAO,EAAE;cACPP,GAAG,EAAEK,KAAK;cACVT,QAAQ,EAAEA,QAAQ,GAAG;YACvB;UACF,CAAC,CAAC;QACJ,CAAC,MAAM;UACL;UACAJ,QAAQ,CAAC;YACPc,IAAI,EAAE,iBAAiB;YACvBC,OAAO,EAAE;cACP;cACAP,GAAG,EAAEL,UAAU,CAACC,QAAQ,CAAC,CAACa,EAAE;cAC5Bb,QAAQ,EAAEA,QAAQ,GAAG;YACvB;UACF,CAAC,CAAC;QACJ;MACF,CAAC,MAAM,IAAIM,SAAS,KAAK,MAAM,IAAIN,QAAQ,GAAG,CAAC,EAAE;QAC/C;QACAJ,QAAQ,CAAC;UACPc,IAAI,EAAE,iBAAiB;UACvBC,OAAO,EAAE;YACP;YACAP,GAAG,EAAEL,UAAU,CAACC,QAAQ,GAAG,CAAC,CAAC,CAACa,EAAE;YAChCb,QAAQ,EAAEA,QAAQ,GAAG;UACvB;QACF,CAAC,CAAC;MACJ;IACF,CAAC,MAAM;MACL;MACAJ,QAAQ,CAAC;QACPc,IAAI,EAAE,eAAe;QACrBC,OAAO,EAAE;UAAEL,SAAS;UAAEL,UAAU;UAAEC;QAAU;MAC9C,CAAC,CAAC;IACJ;EACF,CAAC,EAAEV,oBAAoB,CAAC;AAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}