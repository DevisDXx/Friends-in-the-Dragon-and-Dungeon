{"ast":null,"code":"import _objectSpread from \"C:/Users/devis/Downloads/react-rpg.com-master/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _cloneDeep from 'lodash.clonedeep';\nimport attachMetaToTiles from '../../utils/attach-meta-to-tiles';\nimport generatePaddingTiles from '../../utils/generate-padding-tiles';\nimport maps from '../../data/maps';\nimport { getChestName } from '../../utils/get-chest-name';\nconst initialState = {\n  currentMap: null,\n  gameMode: null,\n  turn: 0,\n  storyMaps: {},\n  randomMaps: [],\n  chests: {},\n  floorNum: null,\n  mapTransition: false\n};\nconst worldReducer = function () {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let {\n    type,\n    payload\n  } = arguments.length > 1 ? arguments[1] : undefined;\n  let newState;\n  let currentMapData;\n  switch (type) {\n    case 'MAP_TRANSITION':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        mapTransition: !state.mapTransition\n      });\n    case 'ADD_BLOOD_SPILL':\n      newState = _cloneDeep(state);\n      currentMapData = getCurrentMap(newState);\n      // we need this check to not override chests, stairs, etc.\n      // check if the next tile is an empty one\n      if (currentMapData.tiles[payload.y][payload.x].value === 0) {\n        // set current tile to blood spill tile\n        currentMapData.tiles[payload.y][payload.x].value = -1;\n      }\n      return newState;\n    case 'SET_CHEST_DATA':\n      newState = _cloneDeep(state);\n      currentMapData = getCurrentMap(newState);\n      if (payload) {\n        // We pass 'false' around if we're setting up a new chest, so here we've got an existing chest\n        const {\n          x,\n          y,\n          item\n        } = payload;\n        if (item === null) {\n          // This chest has either been completely looted, or there never was an item in it.\n          // This will make the chest appear to the player as open.\n          currentMapData.tiles[y][x].value = -2;\n        }\n        if (x !== undefined && y !== undefined) {\n          // This will either:\n          //   1. Ensure any item's left in the chest are still there, or\n          //   2. Ensure that the item for this chest is null (meaning it\n          //      either never had an item, or it was just looted completely)\n          newState.chests[getChestName(state.currentMap, x, y)] = {\n            item: item\n          };\n        }\n      }\n      return newState;\n    case 'OPEN_CHEST':\n      const {\n        x,\n        y\n      } = payload;\n      const chest = state.chests[getChestName(state.currentMap, x, y)];\n      if (chest === undefined) {\n        // This chest hasn't been opened before, so let's generate one\n        state.chests[getChestName(state.currentMap, x, y)] = {\n          item: null\n        };\n      }\n      newState = _cloneDeep(state);\n      currentMapData = getCurrentMap(newState);\n      return newState;\n    case 'EXPLORE_TILES':\n      newState = _cloneDeep(state);\n      const {\n        tiles,\n        paddingTiles\n      } = payload;\n      currentMapData = getCurrentMap(newState);\n      // get each tile\n      tiles.forEach(tile => {\n        currentMapData.tiles[tile[1]][tile[0]].explored = 1;\n      });\n\n      // create new array of the padding tiles location as strings\n      // make sure to reverse the padding tiles values to get them in [y, x],\n      // which is the format the map reads them (since its a 2d array, columns then rows)\n      const paddTiles = paddingTiles.map(value => JSON.stringify(value.reverse()));\n      // check each padding tile direction and see if any\n      // tiles are contained in the new sightbox\n      if (paddTiles.length > 0) {\n        Object.keys(currentMapData.paddingTiles).forEach(direction => {\n          currentMapData.paddingTiles[direction] = currentMapData.paddingTiles[direction].map(tileRow => {\n            return tileRow.map(tile => {\n              if (paddTiles.indexOf(JSON.stringify(tile.location)) > -1) {\n                tile.explored = 1;\n              }\n              return tile;\n            });\n          });\n        });\n      }\n      return newState;\n    case 'LOAD_STORY_MAPS':\n      const _maps = _cloneDeep(maps);\n      // go over each story map and add explored values\n      // and variation data to the tiles\n      Object.keys(_maps).forEach(mapName => {\n        const newTiles = attachMetaToTiles(_maps[mapName].tiles);\n        const newPaddTiles = generatePaddingTiles();\n        _maps[mapName] = _objectSpread(_objectSpread({}, _maps[mapName]), {}, {\n          tiles: newTiles,\n          paddingTiles: newPaddTiles\n        });\n      });\n      return _objectSpread(_objectSpread({}, state), {}, {\n        storyMaps: _maps\n      });\n    case 'ADD_RANDOM_MAP':\n      const _randomMaps = _cloneDeep(state.randomMaps);\n      const randomTiles = attachMetaToTiles(payload.tiles);\n      const randomPaddTiles = generatePaddingTiles();\n      _randomMaps.push({\n        tiles: randomTiles,\n        id: payload.id,\n        paddingTiles: randomPaddTiles\n      });\n      return _objectSpread(_objectSpread({}, state), {}, {\n        randomMaps: _randomMaps\n      });\n    case 'TAKE_TURN':\n      // increment the turn\n      return _objectSpread(_objectSpread({}, state), {}, {\n        turn: state.turn + 1\n      });\n    case 'SET_STORY_MAP':\n      const {\n        direction,\n        currentMap\n      } = payload;\n      const {\n        stairs\n      } = state.storyMaps[currentMap];\n      return _objectSpread(_objectSpread({}, state), {}, {\n        currentMap: stairs[direction]\n      });\n    case 'SET_ENDLESS_MAP':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        currentMap: payload.map,\n        floorNum: payload.floorNum\n      });\n    case 'SET_START_MAP':\n      const {\n        startMap,\n        gameMode,\n        floorNum\n      } = payload;\n      return _objectSpread(_objectSpread({}, state), {}, {\n        gameMode,\n        currentMap: startMap,\n        floorNum: floorNum ? floorNum : state.floorNum\n      });\n    case 'RESET':\n      return initialState;\n    case 'LOAD_DATA':\n      return _objectSpread(_objectSpread({}, initialState), payload.world);\n    default:\n      return state;\n  }\n\n  // returns a reference to the object on newState with the map data\n  function getCurrentMap(stateObj) {\n    if (stateObj.gameMode === 'story') {\n      return stateObj.storyMaps[stateObj.currentMap];\n    } else {\n      return stateObj.randomMaps[stateObj.floorNum - 1];\n    }\n  }\n};\nexport default worldReducer;","map":{"version":3,"names":["_cloneDeep","attachMetaToTiles","generatePaddingTiles","maps","getChestName","initialState","currentMap","gameMode","turn","storyMaps","randomMaps","chests","floorNum","mapTransition","worldReducer","state","arguments","length","undefined","type","payload","newState","currentMapData","_objectSpread","getCurrentMap","tiles","y","x","value","item","chest","paddingTiles","forEach","tile","explored","paddTiles","map","JSON","stringify","reverse","Object","keys","direction","tileRow","indexOf","location","_maps","mapName","newTiles","newPaddTiles","_randomMaps","randomTiles","randomPaddTiles","push","id","stairs","startMap","world","stateObj"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/world/reducer.jsx"],"sourcesContent":["import _cloneDeep from 'lodash.clonedeep';\n\nimport attachMetaToTiles from '../../utils/attach-meta-to-tiles';\nimport generatePaddingTiles from '../../utils/generate-padding-tiles';\nimport maps from '../../data/maps';\n\nimport { getChestName } from '../../utils/get-chest-name';\n\nconst initialState = {\n    currentMap: null,\n    gameMode: null,\n    turn: 0,\n    storyMaps: {},\n    randomMaps: [],\n    chests: {},\n    floorNum: null,\n    mapTransition: false,\n};\n\nconst worldReducer = (state = initialState, { type, payload }) => {\n    let newState;\n    let currentMapData;\n\n    switch (type) {\n        case 'MAP_TRANSITION':\n            return { ...state, mapTransition: !state.mapTransition };\n\n        case 'ADD_BLOOD_SPILL':\n            newState = _cloneDeep(state);\n            currentMapData = getCurrentMap(newState);\n            // we need this check to not override chests, stairs, etc.\n            // check if the next tile is an empty one\n            if (currentMapData.tiles[payload.y][payload.x].value === 0) {\n                // set current tile to blood spill tile\n                currentMapData.tiles[payload.y][payload.x].value = -1;\n            }\n            return newState;\n\n        case 'SET_CHEST_DATA':\n            newState = _cloneDeep(state);\n            currentMapData = getCurrentMap(newState);\n\n            if (payload) {\n                // We pass 'false' around if we're setting up a new chest, so here we've got an existing chest\n                const { x, y, item } = payload;\n                if (item === null) {\n                    // This chest has either been completely looted, or there never was an item in it.\n                    // This will make the chest appear to the player as open.\n                    currentMapData.tiles[y][x].value = -2;\n                }\n\n                if (x !== undefined && y !== undefined) {\n                    // This will either:\n                    //   1. Ensure any item's left in the chest are still there, or\n                    //   2. Ensure that the item for this chest is null (meaning it\n                    //      either never had an item, or it was just looted completely)\n                    newState.chests[getChestName(state.currentMap, x, y)] = {\n                        item: item,\n                    };\n                }\n            }\n\n            return newState;\n\n        case 'OPEN_CHEST':\n            const { x, y } = payload;\n            const chest = state.chests[getChestName(state.currentMap, x, y)];\n            if (chest === undefined) {\n                // This chest hasn't been opened before, so let's generate one\n                state.chests[getChestName(state.currentMap, x, y)] = {\n                    item: null,\n                };\n            }\n\n            newState = _cloneDeep(state);\n            currentMapData = getCurrentMap(newState);\n\n            return newState;\n\n        case 'EXPLORE_TILES':\n            newState = _cloneDeep(state);\n\n            const { tiles, paddingTiles } = payload;\n            currentMapData = getCurrentMap(newState);\n            // get each tile\n            tiles.forEach(tile => {\n                currentMapData.tiles[tile[1]][tile[0]].explored = 1;\n            });\n\n            // create new array of the padding tiles location as strings\n            // make sure to reverse the padding tiles values to get them in [y, x],\n            // which is the format the map reads them (since its a 2d array, columns then rows)\n            const paddTiles = paddingTiles.map(value =>\n                JSON.stringify(value.reverse())\n            );\n            // check each padding tile direction and see if any\n            // tiles are contained in the new sightbox\n            if (paddTiles.length > 0) {\n                Object.keys(currentMapData.paddingTiles).forEach(direction => {\n                    currentMapData.paddingTiles[\n                        direction\n                    ] = currentMapData.paddingTiles[direction].map(tileRow => {\n                        return tileRow.map(tile => {\n                            if (\n                                paddTiles.indexOf(\n                                    JSON.stringify(tile.location)\n                                ) > -1\n                            ) {\n                                tile.explored = 1;\n                            }\n                            return tile;\n                        });\n                    });\n                });\n            }\n\n            return newState;\n\n        case 'LOAD_STORY_MAPS':\n            const _maps = _cloneDeep(maps);\n            // go over each story map and add explored values\n            // and variation data to the tiles\n            Object.keys(_maps).forEach(mapName => {\n                const newTiles = attachMetaToTiles(_maps[mapName].tiles);\n                const newPaddTiles = generatePaddingTiles();\n\n                _maps[mapName] = {\n                    ..._maps[mapName],\n                    tiles: newTiles,\n                    paddingTiles: newPaddTiles,\n                };\n            });\n\n            return { ...state, storyMaps: _maps };\n\n        case 'ADD_RANDOM_MAP':\n            const _randomMaps = _cloneDeep(state.randomMaps);\n\n            const randomTiles = attachMetaToTiles(payload.tiles);\n            const randomPaddTiles = generatePaddingTiles();\n\n            _randomMaps.push({\n                tiles: randomTiles,\n                id: payload.id,\n                paddingTiles: randomPaddTiles,\n            });\n\n            return { ...state, randomMaps: _randomMaps };\n\n        case 'TAKE_TURN':\n            // increment the turn\n            return { ...state, turn: state.turn + 1 };\n\n        case 'SET_STORY_MAP':\n            const { direction, currentMap } = payload;\n\n            const { stairs } = state.storyMaps[currentMap];\n\n            return { ...state, currentMap: stairs[direction] };\n\n        case 'SET_ENDLESS_MAP':\n            return {\n                ...state,\n                currentMap: payload.map,\n                floorNum: payload.floorNum,\n            };\n\n        case 'SET_START_MAP':\n            const { startMap, gameMode, floorNum } = payload;\n\n            return {\n                ...state,\n                gameMode,\n                currentMap: startMap,\n                floorNum: floorNum ? floorNum : state.floorNum,\n            };\n\n        case 'RESET':\n            return initialState;\n\n        case 'LOAD_DATA':\n            return { ...initialState, ...payload.world };\n\n        default:\n            return state;\n    }\n\n    // returns a reference to the object on newState with the map data\n    function getCurrentMap(stateObj) {\n        if (stateObj.gameMode === 'story') {\n            return stateObj.storyMaps[stateObj.currentMap];\n        } else {\n            return stateObj.randomMaps[stateObj.floorNum - 1];\n        }\n    }\n};\n\nexport default worldReducer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}