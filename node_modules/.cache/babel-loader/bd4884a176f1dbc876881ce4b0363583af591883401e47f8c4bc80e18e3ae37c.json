{"ast":null,"code":"import { SIGHT_RADIUS, MAP_DIMENSIONS, SPRITE_SIZE } from '../config/constants';\n\n/**\n * Generate a square of tiles of a size.\n *\n * @param {*} radiusSize The size of the square we want to generate\n */\nexport const radiusTiles = function () {\n  let radiusSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SIGHT_RADIUS;\n  let x, y;\n  const radTiles = [];\n  // calculate a tile map with desired radius\n  // (results in array = [[-4,-4]...[0,0]...[4,4]] )\n  for (y = -radiusSize; y <= radiusSize; y++) {\n    for (x = -radiusSize; x <= radiusSize; x++) {\n      if (x * x + y * y <= radiusSize * radiusSize) {\n        radTiles.push({\n          x,\n          y\n        });\n      }\n    }\n  }\n  return radTiles;\n};\n\n/**\n * Gather the tiles surrounding the position that the player has moved to.\n *\n * @param {*} newPos The position that the player will be moving to\n */\nexport default function getSurroundingTiles(newPos) {\n  // make sure the new position is in relative map tile size\n  const x = newPos[0] % SPRITE_SIZE === 0 ? newPos[0] / SPRITE_SIZE : newPos[0];\n  const y = newPos[1] % SPRITE_SIZE === 0 ? newPos[1] / SPRITE_SIZE : newPos[1];\n  // set tile to relative tile position\n  const startPos = [x, y];\n  // make sure the start position is within the bounds\n  if (startPos[0] >= MAP_DIMENSIONS[0] || startPos[0] < 0 || startPos[1] >= MAP_DIMENSIONS[1] || startPos[1] < 0) return false;\n  // then calculate the surrounding tiles according to the bounds\n  const surroundingTiles = [];\n  const paddingTiles = [];\n  // add position as offset to each radius tile\n  radiusTiles().forEach(_ref => {\n    let {\n      x,\n      y\n    } = _ref;\n    // get radius with location as offset\n    const offsetX = x + startPos[0];\n    const offsetY = y + startPos[1];\n    // if it is inside the bounds\n    if (offsetX >= 0 && offsetX < MAP_DIMENSIONS[0] && offsetY >= 0 && offsetY < MAP_DIMENSIONS[1]) {\n      // add to surrounding tile...\n      surroundingTiles.push([offsetX, offsetY]);\n    } // otherwise add the tile to padding tiles array\n    else {\n      paddingTiles.push([offsetX, offsetY]);\n    }\n  });\n  return {\n    tiles: surroundingTiles,\n    paddingTiles\n  };\n}","map":{"version":3,"names":["SIGHT_RADIUS","MAP_DIMENSIONS","SPRITE_SIZE","radiusTiles","radiusSize","arguments","length","undefined","x","y","radTiles","push","getSurroundingTiles","newPos","startPos","surroundingTiles","paddingTiles","forEach","_ref","offsetX","offsetY","tiles"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/utils/get-surrounding-tiles.js"],"sourcesContent":["import { SIGHT_RADIUS, MAP_DIMENSIONS, SPRITE_SIZE } from '../config/constants';\n\n/**\n * Generate a square of tiles of a size.\n *\n * @param {*} radiusSize The size of the square we want to generate\n */\nexport const radiusTiles = (radiusSize = SIGHT_RADIUS) => {\n  let x, y;\n  const radTiles = [];\n  // calculate a tile map with desired radius\n  // (results in array = [[-4,-4]...[0,0]...[4,4]] )\n  for (y = -radiusSize; y <= radiusSize; y++) {\n    for (x = -radiusSize; x <= radiusSize; x++) {\n      if (x * x + y * y <= radiusSize * radiusSize) {\n        radTiles.push({ x, y });\n      }\n    }\n  }\n  return radTiles;\n};\n\n/**\n * Gather the tiles surrounding the position that the player has moved to.\n *\n * @param {*} newPos The position that the player will be moving to\n */\nexport default function getSurroundingTiles(newPos) {\n  // make sure the new position is in relative map tile size\n  const x = newPos[0] % SPRITE_SIZE === 0 ? newPos[0] / SPRITE_SIZE : newPos[0];\n  const y = newPos[1] % SPRITE_SIZE === 0 ? newPos[1] / SPRITE_SIZE : newPos[1];\n  // set tile to relative tile position\n  const startPos = [x, y];\n  // make sure the start position is within the bounds\n  if (\n    startPos[0] >= MAP_DIMENSIONS[0] ||\n    startPos[0] < 0 ||\n    startPos[1] >= MAP_DIMENSIONS[1] ||\n    startPos[1] < 0\n  )\n    return false;\n  // then calculate the surrounding tiles according to the bounds\n  const surroundingTiles = [];\n  const paddingTiles = [];\n  // add position as offset to each radius tile\n  radiusTiles().forEach(({ x, y }) => {\n    // get radius with location as offset\n    const offsetX = x + startPos[0];\n    const offsetY = y + startPos[1];\n    // if it is inside the bounds\n    if (\n      offsetX >= 0 &&\n      offsetX < MAP_DIMENSIONS[0] &&\n      offsetY >= 0 &&\n      offsetY < MAP_DIMENSIONS[1]\n    ) {\n      // add to surrounding tile...\n      surroundingTiles.push([offsetX, offsetY]);\n    } // otherwise add the tile to padding tiles array\n    else {\n      paddingTiles.push([offsetX, offsetY]);\n    }\n  });\n\n  return {\n    tiles: surroundingTiles,\n    paddingTiles,\n  };\n}\n"],"mappings":"AAAA,SAASA,YAAY,EAAEC,cAAc,EAAEC,WAAW,QAAQ,qBAAqB;;AAE/E;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,WAAW,GAAG,SAAAA,CAAA,EAA+B;EAAA,IAA9BC,UAAU,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGL,YAAY;EACnD,IAAIQ,CAAC,EAAEC,CAAC;EACR,MAAMC,QAAQ,GAAG,EAAE;EACnB;EACA;EACA,KAAKD,CAAC,GAAG,CAACL,UAAU,EAAEK,CAAC,IAAIL,UAAU,EAAEK,CAAC,EAAE,EAAE;IAC1C,KAAKD,CAAC,GAAG,CAACJ,UAAU,EAAEI,CAAC,IAAIJ,UAAU,EAAEI,CAAC,EAAE,EAAE;MAC1C,IAAIA,CAAC,GAAGA,CAAC,GAAGC,CAAC,GAAGA,CAAC,IAAIL,UAAU,GAAGA,UAAU,EAAE;QAC5CM,QAAQ,CAACC,IAAI,CAAC;UAAEH,CAAC;UAAEC;QAAE,CAAC,CAAC;MACzB;IACF;EACF;EACA,OAAOC,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,eAAe,SAASE,mBAAmBA,CAACC,MAAM,EAAE;EAClD;EACA,MAAML,CAAC,GAAGK,MAAM,CAAC,CAAC,CAAC,GAAGX,WAAW,KAAK,CAAC,GAAGW,MAAM,CAAC,CAAC,CAAC,GAAGX,WAAW,GAAGW,MAAM,CAAC,CAAC,CAAC;EAC7E,MAAMJ,CAAC,GAAGI,MAAM,CAAC,CAAC,CAAC,GAAGX,WAAW,KAAK,CAAC,GAAGW,MAAM,CAAC,CAAC,CAAC,GAAGX,WAAW,GAAGW,MAAM,CAAC,CAAC,CAAC;EAC7E;EACA,MAAMC,QAAQ,GAAG,CAACN,CAAC,EAAEC,CAAC,CAAC;EACvB;EACA,IACEK,QAAQ,CAAC,CAAC,CAAC,IAAIb,cAAc,CAAC,CAAC,CAAC,IAChCa,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,IACfA,QAAQ,CAAC,CAAC,CAAC,IAAIb,cAAc,CAAC,CAAC,CAAC,IAChCa,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,EAEf,OAAO,KAAK;EACd;EACA,MAAMC,gBAAgB,GAAG,EAAE;EAC3B,MAAMC,YAAY,GAAG,EAAE;EACvB;EACAb,WAAW,CAAC,CAAC,CAACc,OAAO,CAACC,IAAA,IAAc;IAAA,IAAb;MAAEV,CAAC;MAAEC;IAAE,CAAC,GAAAS,IAAA;IAC7B;IACA,MAAMC,OAAO,GAAGX,CAAC,GAAGM,QAAQ,CAAC,CAAC,CAAC;IAC/B,MAAMM,OAAO,GAAGX,CAAC,GAAGK,QAAQ,CAAC,CAAC,CAAC;IAC/B;IACA,IACEK,OAAO,IAAI,CAAC,IACZA,OAAO,GAAGlB,cAAc,CAAC,CAAC,CAAC,IAC3BmB,OAAO,IAAI,CAAC,IACZA,OAAO,GAAGnB,cAAc,CAAC,CAAC,CAAC,EAC3B;MACA;MACAc,gBAAgB,CAACJ,IAAI,CAAC,CAACQ,OAAO,EAAEC,OAAO,CAAC,CAAC;IAC3C,CAAC,CAAC;IAAA,KACG;MACHJ,YAAY,CAACL,IAAI,CAAC,CAACQ,OAAO,EAAEC,OAAO,CAAC,CAAC;IACvC;EACF,CAAC,CAAC;EAEF,OAAO;IACLC,KAAK,EAAEN,gBAAgB;IACvBC;EACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}