{"ast":null,"code":"import { observeImpassable, checkForOtherMonster, playerInRange, getRandomDirection } from './move-monster';\nimport attackPlayer from './attack-player';\nimport { SPRITE_SIZE } from '../../../config/constants';\n\n// recursive function for moving the monster to the next available tile\n// will try to go towards the player if possible\nexport function move(direction, position, currentMap, id, count) {\n  let preference = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  return (dispatch, getState) => {\n    count++;\n    // dont allow for infinite loops when monster can't move\n    if (count >= 5) return;\n    let nextPos = [0, 0];\n    switch (direction) {\n      case 'up':\n        nextPos = [position[0], position[1] - SPRITE_SIZE];\n        // see if the monster can move to the next location\n        if (dispatch(observeImpassable(nextPos))) {\n          // if we found a monster\n          if (dispatch(checkForOtherMonster(id, nextPos, currentMap))) {\n            // move in a circle, but the opposite direction\n            return dispatch(move(preference ? preference : 'left', position, currentMap, id, count));\n          } else {\n            // otherwise just move to the next spot\n            position[1] -= SPRITE_SIZE;\n          }\n          break;\n        } else {\n          // otherwise move them to another spot\n          return dispatch(move(preference ? preference : 'right', position, currentMap, id, count));\n        }\n      case 'down':\n        nextPos = [position[0], position[1] + SPRITE_SIZE];\n        // see if the monster can move to the next location\n        if (dispatch(observeImpassable(nextPos))) {\n          // if we found a monster\n          if (dispatch(checkForOtherMonster(id, nextPos, currentMap))) {\n            // move in a circle, but the opposite direction\n            return dispatch(move(preference ? preference : 'right', position, currentMap, id, count));\n          } else {\n            // otherwise just move to the next spot\n            position[1] += SPRITE_SIZE;\n          }\n          break;\n        } else {\n          // otherwise move them to another spot\n          return dispatch(move(preference ? preference : 'left', position, currentMap, id, count));\n        }\n      case 'left':\n        nextPos = [position[0] - SPRITE_SIZE, position[1]];\n        // see if the monster can move to the next location\n        if (dispatch(observeImpassable(nextPos))) {\n          // if we found a monster\n          if (dispatch(checkForOtherMonster(id, nextPos, currentMap))) {\n            // move in a circle, but the opposite direction\n            return dispatch(move(preference ? preference : 'down', position, currentMap, id, count));\n          } else {\n            // otherwise just move to the next spot\n            position[0] -= SPRITE_SIZE;\n          }\n          break;\n        } else {\n          // otherwise move them to another spot\n          return dispatch(move(preference ? preference : 'up', position, currentMap, id, count));\n        }\n      case 'right':\n        nextPos = [position[0] + SPRITE_SIZE, position[1]];\n        // see if the monster can move to the next location\n        if (dispatch(observeImpassable(nextPos))) {\n          // if we found a monster\n          if (dispatch(checkForOtherMonster(id, nextPos, currentMap))) {\n            // move in a circle, but the opposite direction\n            return dispatch(move(preference ? preference : 'up', position, currentMap, id, count));\n          } else {\n            // otherwise just move to the next spot\n            position[0] += SPRITE_SIZE;\n          }\n          break;\n        } else {\n          // otherwise move them to another spot\n          return dispatch(move(preference ? preference : 'down', position, currentMap, id, count));\n        }\n      default:\n    }\n\n    // recalculate if the monster is in sight\n    const {\n      sightBox\n    } = getState().map;\n    let inSight = false;\n    // look through each current sight box tile\n    sightBox.forEach(tile => {\n      // if the monster is in sight\n      const newMonsterPos = position.map(value => value / SPRITE_SIZE);\n      if (JSON.stringify(tile) === JSON.stringify(newMonsterPos)) {\n        inSight = true;\n      }\n    });\n    // if the monster is now in sight\n    if (inSight) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n    } else {\n      // if the monster is now out of sight\n      dispatch({\n        type: 'HIDE_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n    }\n    const monster = getState().monsters.components[currentMap][id];\n    // move the monster\n    dispatch({\n      type: 'MOVE_MONSTER',\n      payload: {\n        map: currentMap,\n        id,\n        position,\n        direction: direction === 'up' || direction === 'down' ? monster.direction : direction === 'left' ? 'WEST' : 'EAST'\n      }\n    });\n  };\n}\nexport default function moveNormally(sightBox, currentMap, monster) {\n  return (dispatch, getState) => {\n    const {\n      id,\n      position\n    } = monster;\n    const monsterPosition = position.map(pos => pos / SPRITE_SIZE);\n    let monsterVisible = false;\n    // look through each current sight box tile\n    sightBox.forEach(tile => {\n      // if the monster is in sight\n      if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n        monsterVisible = true;\n      }\n    });\n    if (monsterVisible) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n      const {\n        player\n      } = getState();\n      // check if player is in range\n      if (playerInRange(player.position, monsterPosition)) {\n        dispatch(attackPlayer(monster));\n      } else {\n        // no player in range, time to move!\n        // get the monsters actual position in pixels\n        const position = monsterPosition.map(value => value * SPRITE_SIZE);\n        // get distance from player on both axis\n        const xDiff = position[0] - player.position[0];\n        const yDiff = position[1] - player.position[1];\n        const greaterY = Math.abs(yDiff) > Math.abs(xDiff);\n        // see if y axis is greater distance from player\n        if (greaterY) {\n          // if the monster is mostly below the player on the y axis\n          if (yDiff > 0) {\n            // move the monster 'up' relatively\n            dispatch(move('up', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n          // if the monster is mostly above the player on the y axis\n          else if (yDiff < 0) {\n            // move the monster 'down' relatively\n            dispatch(move('down', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n        } // x axis is greater distance from player\n        else {\n          // if the monster is mostly to the right of the player\n          if (xDiff > 0) {\n            // move the monster 'left' relatively\n            dispatch(move('left', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n          // if the monster is mostly to the left of the player\n          else if (xDiff < 0) {\n            // move the monster 'right' relatively\n            dispatch(move('right', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n        }\n      }\n    } else {\n      // monster is too far away from the player\n      dispatch({\n        type: 'HIDE_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n      // give a 25% chance to move the monster when hidden\n      if (Math.round(Math.random() * (4 - 1) + 1) !== 4) {\n        const randomDirection = getRandomDirection();\n        // move the monster in a random direction\n        dispatch(move(randomDirection, position, currentMap, id, 0));\n      }\n    }\n  };\n}","map":{"version":3,"names":["observeImpassable","checkForOtherMonster","playerInRange","getRandomDirection","attackPlayer","SPRITE_SIZE","move","direction","position","currentMap","id","count","preference","arguments","length","undefined","dispatch","getState","nextPos","sightBox","map","inSight","forEach","tile","newMonsterPos","value","JSON","stringify","type","payload","monster","monsters","components","moveNormally","monsterPosition","pos","monsterVisible","player","xDiff","yDiff","greaterY","Math","abs","round","random","randomDirection"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/monsters/actions/normal-ai.jsx"],"sourcesContent":["import {\n  observeImpassable,\n  checkForOtherMonster,\n  playerInRange,\n  getRandomDirection,\n} from './move-monster';\nimport attackPlayer from './attack-player';\nimport { SPRITE_SIZE } from '../../../config/constants';\n\n// recursive function for moving the monster to the next available tile\n// will try to go towards the player if possible\nexport function move(direction, position, currentMap, id, count, preference = false) {\n  return (dispatch, getState) => {\n    count++;\n    // dont allow for infinite loops when monster can't move\n    if (count >= 5) return;\n\n    let nextPos = [0, 0];\n\n    switch (direction) {\n      case 'up':\n        nextPos = [position[0], position[1] - SPRITE_SIZE];\n        // see if the monster can move to the next location\n        if (dispatch(observeImpassable(nextPos))) {\n          // if we found a monster\n          if (dispatch(checkForOtherMonster(id, nextPos, currentMap))) {\n            // move in a circle, but the opposite direction\n            return dispatch(\n              move(preference ? preference : 'left', position, currentMap, id, count)\n            );\n          } else {\n            // otherwise just move to the next spot\n            position[1] -= SPRITE_SIZE;\n          }\n          break;\n        } else {\n          // otherwise move them to another spot\n          return dispatch(move(preference ? preference : 'right', position, currentMap, id, count));\n        }\n      case 'down':\n        nextPos = [position[0], position[1] + SPRITE_SIZE];\n        // see if the monster can move to the next location\n        if (dispatch(observeImpassable(nextPos))) {\n          // if we found a monster\n          if (dispatch(checkForOtherMonster(id, nextPos, currentMap))) {\n            // move in a circle, but the opposite direction\n            return dispatch(\n              move(preference ? preference : 'right', position, currentMap, id, count)\n            );\n          } else {\n            // otherwise just move to the next spot\n            position[1] += SPRITE_SIZE;\n          }\n          break;\n        } else {\n          // otherwise move them to another spot\n          return dispatch(move(preference ? preference : 'left', position, currentMap, id, count));\n        }\n      case 'left':\n        nextPos = [position[0] - SPRITE_SIZE, position[1]];\n        // see if the monster can move to the next location\n        if (dispatch(observeImpassable(nextPos))) {\n          // if we found a monster\n          if (dispatch(checkForOtherMonster(id, nextPos, currentMap))) {\n            // move in a circle, but the opposite direction\n            return dispatch(\n              move(preference ? preference : 'down', position, currentMap, id, count)\n            );\n          } else {\n            // otherwise just move to the next spot\n            position[0] -= SPRITE_SIZE;\n          }\n          break;\n        } else {\n          // otherwise move them to another spot\n          return dispatch(move(preference ? preference : 'up', position, currentMap, id, count));\n        }\n      case 'right':\n        nextPos = [position[0] + SPRITE_SIZE, position[1]];\n        // see if the monster can move to the next location\n        if (dispatch(observeImpassable(nextPos))) {\n          // if we found a monster\n          if (dispatch(checkForOtherMonster(id, nextPos, currentMap))) {\n            // move in a circle, but the opposite direction\n            return dispatch(move(preference ? preference : 'up', position, currentMap, id, count));\n          } else {\n            // otherwise just move to the next spot\n            position[0] += SPRITE_SIZE;\n          }\n          break;\n        } else {\n          // otherwise move them to another spot\n          return dispatch(move(preference ? preference : 'down', position, currentMap, id, count));\n        }\n      default:\n    }\n\n    // recalculate if the monster is in sight\n    const { sightBox } = getState().map;\n    let inSight = false;\n    // look through each current sight box tile\n    sightBox.forEach((tile) => {\n      // if the monster is in sight\n      const newMonsterPos = position.map((value) => value / SPRITE_SIZE);\n      if (JSON.stringify(tile) === JSON.stringify(newMonsterPos)) {\n        inSight = true;\n      }\n    });\n    // if the monster is now in sight\n    if (inSight) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: { id, map: currentMap },\n      });\n    } else {\n      // if the monster is now out of sight\n      dispatch({\n        type: 'HIDE_MONSTER',\n        payload: { id, map: currentMap },\n      });\n    }\n    const monster = getState().monsters.components[currentMap][id];\n    // move the monster\n    dispatch({\n      type: 'MOVE_MONSTER',\n      payload: {\n        map: currentMap,\n        id,\n        position,\n        direction:\n          direction === 'up' || direction === 'down'\n            ? monster.direction\n            : direction === 'left'\n            ? 'WEST'\n            : 'EAST',\n      },\n    });\n  };\n}\n\nexport default function moveNormally(sightBox, currentMap, monster) {\n  return (dispatch, getState) => {\n    const { id, position } = monster;\n\n    const monsterPosition = position.map((pos) => pos / SPRITE_SIZE);\n\n    let monsterVisible = false;\n    // look through each current sight box tile\n    sightBox.forEach((tile) => {\n      // if the monster is in sight\n      if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n        monsterVisible = true;\n      }\n    });\n\n    if (monsterVisible) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: { id, map: currentMap },\n      });\n\n      const { player } = getState();\n      // check if player is in range\n      if (playerInRange(player.position, monsterPosition)) {\n        dispatch(attackPlayer(monster));\n      } else {\n        // no player in range, time to move!\n        // get the monsters actual position in pixels\n        const position = monsterPosition.map((value) => value * SPRITE_SIZE);\n        // get distance from player on both axis\n        const xDiff = position[0] - player.position[0];\n        const yDiff = position[1] - player.position[1];\n        const greaterY = Math.abs(yDiff) > Math.abs(xDiff);\n        // see if y axis is greater distance from player\n        if (greaterY) {\n          // if the monster is mostly below the player on the y axis\n          if (yDiff > 0) {\n            // move the monster 'up' relatively\n            dispatch(move('up', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n          // if the monster is mostly above the player on the y axis\n          else if (yDiff < 0) {\n            // move the monster 'down' relatively\n            dispatch(move('down', position, currentMap, id, 0, xDiff >= 0 ? 'left' : 'right'));\n          }\n        } // x axis is greater distance from player\n        else {\n          // if the monster is mostly to the right of the player\n          if (xDiff > 0) {\n            // move the monster 'left' relatively\n            dispatch(move('left', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n          // if the monster is mostly to the left of the player\n          else if (xDiff < 0) {\n            // move the monster 'right' relatively\n            dispatch(move('right', position, currentMap, id, 0, yDiff >= 0 ? 'up' : 'down'));\n          }\n        }\n      }\n    } else {\n      // monster is too far away from the player\n      dispatch({\n        type: 'HIDE_MONSTER',\n        payload: { id, map: currentMap },\n      });\n      // give a 25% chance to move the monster when hidden\n      if (Math.round(Math.random() * (4 - 1) + 1) !== 4) {\n        const randomDirection = getRandomDirection();\n        // move the monster in a random direction\n        dispatch(move(randomDirection, position, currentMap, id, 0));\n      }\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}