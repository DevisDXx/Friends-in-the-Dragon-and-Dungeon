{"ast":null,"code":"import generateMonsterType from './generate-monster-type';\nimport arrContainArr from '../../../utils/arr-contain-arr';\nimport getSurroundingTiles from '../../../utils/get-surrounding-tiles';\nimport { MAP_DIMENSIONS } from '../../../config/constants';\n\n/**\n * Generate all of the monsters in the map\n *\n * @param {*} floorNumber The floor number\n * @param {*} map The map we're generating the monsters in\n * @param {*} playerPosition The position of the player\n * @param {*} playerLevel The level of the player\n */\nexport default function generateMonsters(floorNumber, map, playerPosition, playerLevel) {\n  let availableTiles = [];\n  // we need to get the tiles from the surrounding tiles func,\n  // then reverse the coordinates because they come back in normal notation (y, x)\n  // but for the random map gen, we need them in (x, y)\n  const vision = getSurroundingTiles(playerPosition).tiles.map(tile => tile.reverse());\n  for (let i = 0; i < MAP_DIMENSIONS[1]; i++) {\n    for (let j = 0; j < MAP_DIMENSIONS[0]; j++) {\n      // some maps have their meta attached, some dont, so we need to read the value either way\n      const mapValue = typeof map[i][j] === 'object' ? map[i][j].value : map[i][j];\n      // get a list of floor tiles\n      if (mapValue === 0) {\n        availableTiles.push([i, j]);\n      }\n    }\n  }\n  availableTiles = availableTiles.filter(value => {\n    // remove the available tiles that are vision tiles\n    return !arrContainArr(vision, value);\n  });\n\n  // generate number of monsters for the map based on floor number and player level\n  const numberMonsters = Math.ceil(floorNumber / playerLevel) * Math.round(Math.random() * (4 - 2) + 2);\n  const monsterTiles = [];\n  // get an array of tiles to position the random monsters\n  for (let x = 0; x < numberMonsters; x++) {\n    if (availableTiles.length > 0) {\n      const randomIndex = Math.floor(Math.random() * availableTiles.length);\n      monsterTiles.push(availableTiles[randomIndex]);\n      availableTiles.splice(randomIndex, 1);\n    }\n  }\n\n  // generate the monster type and create an array of monster objects\n  return monsterTiles.map(position => {\n    // reverse the position from the generated map,\n    // as it is in [y, x], and now we need to change to [x, y] (normal notation)\n    position = position.reverse();\n    const type = generateMonsterType(playerLevel);\n    return {\n      position,\n      type\n    };\n  });\n}","map":{"version":3,"names":["generateMonsterType","arrContainArr","getSurroundingTiles","MAP_DIMENSIONS","generateMonsters","floorNumber","map","playerPosition","playerLevel","availableTiles","vision","tiles","tile","reverse","i","j","mapValue","value","push","filter","numberMonsters","Math","ceil","round","random","monsterTiles","x","length","randomIndex","floor","splice","position","type"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/map/random-map-gen/generate-monsters.jsx"],"sourcesContent":["import generateMonsterType from './generate-monster-type';\nimport arrContainArr from '../../../utils/arr-contain-arr';\nimport getSurroundingTiles from '../../../utils/get-surrounding-tiles';\nimport { MAP_DIMENSIONS } from '../../../config/constants';\n\n/**\n * Generate all of the monsters in the map\n *\n * @param {*} floorNumber The floor number\n * @param {*} map The map we're generating the monsters in\n * @param {*} playerPosition The position of the player\n * @param {*} playerLevel The level of the player\n */\nexport default function generateMonsters(floorNumber, map, playerPosition, playerLevel) {\n  let availableTiles = [];\n  // we need to get the tiles from the surrounding tiles func,\n  // then reverse the coordinates because they come back in normal notation (y, x)\n  // but for the random map gen, we need them in (x, y)\n  const vision = getSurroundingTiles(playerPosition).tiles.map((tile) => tile.reverse());\n\n  for (let i = 0; i < MAP_DIMENSIONS[1]; i++) {\n    for (let j = 0; j < MAP_DIMENSIONS[0]; j++) {\n      // some maps have their meta attached, some dont, so we need to read the value either way\n      const mapValue = typeof map[i][j] === 'object' ? map[i][j].value : map[i][j];\n      // get a list of floor tiles\n      if (mapValue === 0) {\n        availableTiles.push([i, j]);\n      }\n    }\n  }\n\n  availableTiles = availableTiles.filter((value) => {\n    // remove the available tiles that are vision tiles\n    return !arrContainArr(vision, value);\n  });\n\n  // generate number of monsters for the map based on floor number and player level\n  const numberMonsters =\n    Math.ceil(floorNumber / playerLevel) * Math.round(Math.random() * (4 - 2) + 2);\n  const monsterTiles = [];\n  // get an array of tiles to position the random monsters\n  for (let x = 0; x < numberMonsters; x++) {\n    if (availableTiles.length > 0) {\n      const randomIndex = Math.floor(Math.random() * availableTiles.length);\n      monsterTiles.push(availableTiles[randomIndex]);\n      availableTiles.splice(randomIndex, 1);\n    }\n  }\n\n  // generate the monster type and create an array of monster objects\n  return monsterTiles.map((position) => {\n    // reverse the position from the generated map,\n    // as it is in [y, x], and now we need to change to [x, y] (normal notation)\n    position = position.reverse();\n\n    const type = generateMonsterType(playerLevel);\n\n    return { position, type };\n  });\n}\n"],"mappings":"AAAA,OAAOA,mBAAmB,MAAM,yBAAyB;AACzD,OAAOC,aAAa,MAAM,gCAAgC;AAC1D,OAAOC,mBAAmB,MAAM,sCAAsC;AACtE,SAASC,cAAc,QAAQ,2BAA2B;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,gBAAgBA,CAACC,WAAW,EAAEC,GAAG,EAAEC,cAAc,EAAEC,WAAW,EAAE;EACtF,IAAIC,cAAc,GAAG,EAAE;EACvB;EACA;EACA;EACA,MAAMC,MAAM,GAAGR,mBAAmB,CAACK,cAAc,CAAC,CAACI,KAAK,CAACL,GAAG,CAAEM,IAAI,IAAKA,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC;EAEtF,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,cAAc,CAAC,CAAC,CAAC,EAAEW,CAAC,EAAE,EAAE;IAC1C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,cAAc,CAAC,CAAC,CAAC,EAAEY,CAAC,EAAE,EAAE;MAC1C;MACA,MAAMC,QAAQ,GAAG,OAAOV,GAAG,CAACQ,CAAC,CAAC,CAACC,CAAC,CAAC,KAAK,QAAQ,GAAGT,GAAG,CAACQ,CAAC,CAAC,CAACC,CAAC,CAAC,CAACE,KAAK,GAAGX,GAAG,CAACQ,CAAC,CAAC,CAACC,CAAC,CAAC;MAC5E;MACA,IAAIC,QAAQ,KAAK,CAAC,EAAE;QAClBP,cAAc,CAACS,IAAI,CAAC,CAACJ,CAAC,EAAEC,CAAC,CAAC,CAAC;MAC7B;IACF;EACF;EAEAN,cAAc,GAAGA,cAAc,CAACU,MAAM,CAAEF,KAAK,IAAK;IAChD;IACA,OAAO,CAAChB,aAAa,CAACS,MAAM,EAAEO,KAAK,CAAC;EACtC,CAAC,CAAC;;EAEF;EACA,MAAMG,cAAc,GAClBC,IAAI,CAACC,IAAI,CAACjB,WAAW,GAAGG,WAAW,CAAC,GAAGa,IAAI,CAACE,KAAK,CAACF,IAAI,CAACG,MAAM,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;EAChF,MAAMC,YAAY,GAAG,EAAE;EACvB;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,cAAc,EAAEM,CAAC,EAAE,EAAE;IACvC,IAAIjB,cAAc,CAACkB,MAAM,GAAG,CAAC,EAAE;MAC7B,MAAMC,WAAW,GAAGP,IAAI,CAACQ,KAAK,CAACR,IAAI,CAACG,MAAM,CAAC,CAAC,GAAGf,cAAc,CAACkB,MAAM,CAAC;MACrEF,YAAY,CAACP,IAAI,CAACT,cAAc,CAACmB,WAAW,CAAC,CAAC;MAC9CnB,cAAc,CAACqB,MAAM,CAACF,WAAW,EAAE,CAAC,CAAC;IACvC;EACF;;EAEA;EACA,OAAOH,YAAY,CAACnB,GAAG,CAAEyB,QAAQ,IAAK;IACpC;IACA;IACAA,QAAQ,GAAGA,QAAQ,CAAClB,OAAO,CAAC,CAAC;IAE7B,MAAMmB,IAAI,GAAGhC,mBAAmB,CAACQ,WAAW,CAAC;IAE7C,OAAO;MAAEuB,QAAQ;MAAEC;IAAK,CAAC;EAC3B,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}