{"ast":null,"code":"import exploreTiles from './explore-tiles';\nimport exploreChest from './explore-chest';\nimport walkStairs from './walk-stairs';\nimport getNextTile from '../../../utils/get-next-tile';\nimport { SPRITE_SIZE, MAP_WIDTH, MAP_HEIGHT, PASSIVE_MANA_RESTORE_TURNS, OUT_OF_COMBAT_RANGE } from '../../../config/constants';\nimport { calculateDamage } from '../../../utils/dice';\nexport function applyEffects() {\n  return (dispatch, getState) => {\n    const {\n      player,\n      stats\n    } = getState();\n    Object.keys(player.effects).forEach(effect => {\n      const props = player.effects[effect];\n      if (props.turns > 0) {\n        const damage = Math.floor(calculateDamage(props.damage) / 2);\n        if (damage > 0) {\n          dispatch({\n            type: 'DAMAGE_TO_PLAYER',\n            payload: {\n              damage,\n              effect: props.from\n            }\n          });\n\n          // check if player died\n          if (stats.hp - damage <= 0) {\n            // play death sound\n            dispatch({\n              type: 'PLAYER_DIED',\n              payload: {\n                from: props.from\n              }\n            });\n            // if it did, game over\n            dispatch({\n              type: 'PAUSE',\n              payload: {\n                gameOver: true,\n                pause: true\n              }\n            });\n          }\n        }\n      }\n    });\n  };\n}\nexport default function movePlayer(direction) {\n  return (dispatch, getState) => {\n    const oldPos = getState().player.position;\n    const newPos = getNewPosition(oldPos, direction);\n    const facing = getState().player.direction;\n    const nextTile = observeImpassable(newPos);\n    if (observeBoundaries(newPos) && nextTile < 5 && !dispatch(checkForMonster(newPos, direction)) && (facing === direction || !dispatch(monstersWithinRange(newPos, OUT_OF_COMBAT_RANGE)))) {\n      // explore new tiles\n      dispatch(exploreTiles(newPos));\n      // move the player\n      dispatch({\n        type: 'MOVE_PLAYER',\n        payload: {\n          position: newPos,\n          direction\n        }\n      });\n\n      // if we do anything but use stairs, count a turn\n      if (handleInteractWithTile(nextTile, newPos)) {\n        dispatch({\n          type: 'TAKE_TURN',\n          payload: null\n        });\n        dispatch(applyEffects());\n        if (getState().player.turnsOutOfCombat % PASSIVE_MANA_RESTORE_TURNS === 0 && !dispatch(monstersWithinRange(newPos, OUT_OF_COMBAT_RANGE))) {\n          dispatch({\n            type: 'RESTORE_MANA',\n            payload: {\n              kind: 'passive',\n              amount: Math.ceil(getState().stats.maxMana / 10)\n            }\n          });\n        }\n      }\n    } // dont move the player\n    else {\n      const {\n        playerMoved,\n        position\n      } = getState().player;\n      // turn the player but do not play the\n      // walk animation triggered by a change in playerMoved\n      dispatch({\n        type: 'MOVE_PLAYER',\n        payload: {\n          direction,\n          playerMoved,\n          position\n        }\n      });\n    }\n    function handleInteractWithTile(nextTile, newPos) {\n      // the player wants to use the stairs\n      if (nextTile === 2 || nextTile === 3) {\n        dispatch({\n          type: 'MAP_TRANSITION',\n          payload: null\n        });\n        dispatch(walkStairs(nextTile, newPos));\n        return false;\n      }\n      // player wants to open chest\n      if (nextTile === 4) {\n        const y = newPos[1] / SPRITE_SIZE;\n        const x = newPos[0] / SPRITE_SIZE;\n        // open the chest\n        dispatch(exploreChest(x, y));\n      }\n      return true;\n    }\n    function observeImpassable(newPos) {\n      const nextTile = getNextTile(getState().world, newPos);\n\n      // the player wants to use the shop\n      if (nextTile === 9) {\n        // show the shop dialog\n        dispatch({\n          type: 'PAUSE',\n          payload: {\n            pause: true,\n            shop: true\n          }\n        });\n      }\n\n      // the player has accessed a shrine\n      if (nextTile === 10) {\n        // check if they have won the game\n        dispatch({\n          type: 'PAUSE',\n          payload: {\n            pause: true,\n            gameWin: true\n          }\n        });\n      }\n      return nextTile;\n    }\n  };\n}\nconst monstersWithinRange = (position, within) => {\n  return dispatch => {\n    for (let i = -within * SPRITE_SIZE; i < within * SPRITE_SIZE; i += SPRITE_SIZE) {\n      for (let j = -within * SPRITE_SIZE; j < within * SPRITE_SIZE; j += SPRITE_SIZE) {\n        const pos = [position[0] + i, position[1] + j];\n        if (dispatch(checkForMonster(pos))) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n};\n\n// returns `false` or the monster's id\nexport function checkForMonster(newPos) {\n  return (_, getState) => {\n    let isMonster = false;\n    const {\n      currentMap\n    } = getState().world;\n    const monsters = getState().monsters.components;\n    // check for monsters\n    Object.keys(monsters[currentMap]).forEach(monsterId => {\n      const currMonster = monsters[currentMap][monsterId];\n      // if the new position contains a monster\n      if (JSON.stringify(currMonster.position) === JSON.stringify(newPos)) {\n        isMonster = currMonster.id;\n      }\n    });\n    return isMonster;\n  };\n}\nexport function getNewPosition(oldPos, direction) {\n  switch (direction) {\n    case 'WEST':\n      return [oldPos[0] - SPRITE_SIZE, oldPos[1]];\n    case 'EAST':\n      return [oldPos[0] + SPRITE_SIZE, oldPos[1]];\n    case 'NORTH':\n      return [oldPos[0], oldPos[1] - SPRITE_SIZE];\n    case 'SOUTH':\n      return [oldPos[0], oldPos[1] + SPRITE_SIZE];\n    default:\n  }\n}\nexport function observeBoundaries(newPos) {\n  return newPos[0] >= 0 && newPos[0] <= MAP_WIDTH - SPRITE_SIZE && newPos[1] >= 0 && newPos[1] <= MAP_HEIGHT - SPRITE_SIZE;\n}","map":{"version":3,"names":["exploreTiles","exploreChest","walkStairs","getNextTile","SPRITE_SIZE","MAP_WIDTH","MAP_HEIGHT","PASSIVE_MANA_RESTORE_TURNS","OUT_OF_COMBAT_RANGE","calculateDamage","applyEffects","dispatch","getState","player","stats","Object","keys","effects","forEach","effect","props","turns","damage","Math","floor","type","payload","from","hp","gameOver","pause","movePlayer","direction","oldPos","position","newPos","getNewPosition","facing","nextTile","observeImpassable","observeBoundaries","checkForMonster","monstersWithinRange","handleInteractWithTile","turnsOutOfCombat","kind","amount","ceil","maxMana","playerMoved","y","x","world","shop","gameWin","within","i","j","pos","_","isMonster","currentMap","monsters","components","monsterId","currMonster","JSON","stringify","id"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/player/actions/move-player.jsx"],"sourcesContent":["import exploreTiles from './explore-tiles';\nimport exploreChest from './explore-chest';\nimport walkStairs from './walk-stairs';\nimport getNextTile from '../../../utils/get-next-tile';\nimport {\n  SPRITE_SIZE,\n  MAP_WIDTH,\n  MAP_HEIGHT,\n  PASSIVE_MANA_RESTORE_TURNS,\n  OUT_OF_COMBAT_RANGE,\n} from '../../../config/constants';\nimport { calculateDamage } from '../../../utils/dice';\n\nexport function applyEffects() {\n  return (dispatch, getState) => {\n    const { player, stats } = getState();\n\n    Object.keys(player.effects).forEach((effect) => {\n      const props = player.effects[effect];\n      if (props.turns > 0) {\n        const damage = Math.floor(calculateDamage(props.damage) / 2);\n        if (damage > 0) {\n          dispatch({\n            type: 'DAMAGE_TO_PLAYER',\n            payload: { damage, effect: props.from },\n          });\n\n          // check if player died\n          if (stats.hp - damage <= 0) {\n            // play death sound\n            dispatch({\n              type: 'PLAYER_DIED',\n              payload: { from: props.from },\n            });\n            // if it did, game over\n            dispatch({\n              type: 'PAUSE',\n              payload: {\n                gameOver: true,\n                pause: true,\n              },\n            });\n          }\n        }\n      }\n    });\n  };\n}\n\nexport default function movePlayer(direction) {\n  return (dispatch, getState) => {\n    const oldPos = getState().player.position;\n    const newPos = getNewPosition(oldPos, direction);\n    const facing = getState().player.direction;\n\n    const nextTile = observeImpassable(newPos);\n\n    if (\n      observeBoundaries(newPos) &&\n      nextTile < 5 &&\n      !dispatch(checkForMonster(newPos, direction)) &&\n      (facing === direction || !dispatch(monstersWithinRange(newPos, OUT_OF_COMBAT_RANGE)))\n    ) {\n      // explore new tiles\n      dispatch(exploreTiles(newPos));\n      // move the player\n      dispatch({\n        type: 'MOVE_PLAYER',\n        payload: {\n          position: newPos,\n          direction,\n        },\n      });\n\n      // if we do anything but use stairs, count a turn\n      if (handleInteractWithTile(nextTile, newPos)) {\n        dispatch({\n          type: 'TAKE_TURN',\n          payload: null,\n        });\n\n        dispatch(applyEffects());\n\n        if (\n          getState().player.turnsOutOfCombat % PASSIVE_MANA_RESTORE_TURNS === 0 &&\n          !dispatch(monstersWithinRange(newPos, OUT_OF_COMBAT_RANGE))\n        ) {\n          dispatch({\n            type: 'RESTORE_MANA',\n            payload: {\n              kind: 'passive',\n              amount: Math.ceil(getState().stats.maxMana / 10),\n            },\n          });\n        }\n      }\n    } // dont move the player\n    else {\n      const { playerMoved, position } = getState().player;\n      // turn the player but do not play the\n      // walk animation triggered by a change in playerMoved\n      dispatch({\n        type: 'MOVE_PLAYER',\n        payload: { direction, playerMoved, position },\n      });\n    }\n\n    function handleInteractWithTile(nextTile, newPos) {\n      // the player wants to use the stairs\n      if (nextTile === 2 || nextTile === 3) {\n        dispatch({\n          type: 'MAP_TRANSITION',\n          payload: null,\n        });\n        dispatch(walkStairs(nextTile, newPos));\n        return false;\n      }\n      // player wants to open chest\n      if (nextTile === 4) {\n        const y = newPos[1] / SPRITE_SIZE;\n        const x = newPos[0] / SPRITE_SIZE;\n        // open the chest\n        dispatch(exploreChest(x, y));\n      }\n      return true;\n    }\n\n    function observeImpassable(newPos) {\n      const nextTile = getNextTile(getState().world, newPos);\n\n      // the player wants to use the shop\n      if (nextTile === 9) {\n        // show the shop dialog\n        dispatch({\n          type: 'PAUSE',\n          payload: {\n            pause: true,\n            shop: true,\n          },\n        });\n      }\n\n      // the player has accessed a shrine\n      if (nextTile === 10) {\n        // check if they have won the game\n        dispatch({\n          type: 'PAUSE',\n          payload: {\n            pause: true,\n            gameWin: true,\n          },\n        });\n      }\n\n      return nextTile;\n    }\n  };\n}\n\nconst monstersWithinRange = (position, within) => {\n  return (dispatch) => {\n    for (let i = -within * SPRITE_SIZE; i < within * SPRITE_SIZE; i += SPRITE_SIZE) {\n      for (let j = -within * SPRITE_SIZE; j < within * SPRITE_SIZE; j += SPRITE_SIZE) {\n        const pos = [position[0] + i, position[1] + j];\n        if (dispatch(checkForMonster(pos))) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n};\n\n// returns `false` or the monster's id\nexport function checkForMonster(newPos) {\n  return (_, getState) => {\n    let isMonster = false;\n    const { currentMap } = getState().world;\n    const monsters = getState().monsters.components;\n    // check for monsters\n    Object.keys(monsters[currentMap]).forEach((monsterId) => {\n      const currMonster = monsters[currentMap][monsterId];\n      // if the new position contains a monster\n      if (JSON.stringify(currMonster.position) === JSON.stringify(newPos)) {\n        isMonster = currMonster.id;\n      }\n    });\n\n    return isMonster;\n  };\n}\n\nexport function getNewPosition(oldPos, direction) {\n  switch (direction) {\n    case 'WEST':\n      return [oldPos[0] - SPRITE_SIZE, oldPos[1]];\n    case 'EAST':\n      return [oldPos[0] + SPRITE_SIZE, oldPos[1]];\n    case 'NORTH':\n      return [oldPos[0], oldPos[1] - SPRITE_SIZE];\n    case 'SOUTH':\n      return [oldPos[0], oldPos[1] + SPRITE_SIZE];\n    default:\n  }\n}\n\nexport function observeBoundaries(newPos) {\n  return (\n    newPos[0] >= 0 &&\n    newPos[0] <= MAP_WIDTH - SPRITE_SIZE &&\n    newPos[1] >= 0 &&\n    newPos[1] <= MAP_HEIGHT - SPRITE_SIZE\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}