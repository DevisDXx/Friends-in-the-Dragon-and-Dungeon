{"ast":null,"code":"import { checkForMonster, getNewPosition, observeBoundaries, applyEffects } from './move-player';\nimport { calculateDamage, d20 } from '../../../utils/dice';\nimport calculateModifier from '../../../utils/calculate-modifier';\nimport getNextTile from '../../../utils/get-next-tile';\nimport { SPRITE_SIZE, FISTS } from '../../../config/constants';\nexport const findTarget = (position, direction, range) => {\n  return (dispatch, getState) => {\n    let targetPosition = null;\n    switch (direction) {\n      case 'NORTH':\n        for (let y = position[1]; y > position[1] - range; y -= SPRITE_SIZE) {\n          const pos = getNewPosition([position[0], y], direction);\n          targetPosition = pos;\n          if (!observeImpassable(pos, getState().world) || dispatch(checkForMonster(pos))) {\n            break;\n          }\n        }\n        break;\n      case 'SOUTH':\n        for (let y = position[1]; y < position[1] + range; y += SPRITE_SIZE) {\n          const pos = getNewPosition([position[0], y], direction);\n          targetPosition = pos;\n          if (!observeImpassable(pos, getState().world) || dispatch(checkForMonster(pos))) {\n            break;\n          }\n        }\n        break;\n      case 'EAST':\n        for (let x = position[0]; x < position[0] + range; x += SPRITE_SIZE) {\n          const pos = getNewPosition([x, position[1]], direction);\n          targetPosition = pos;\n          if (!observeImpassable(pos, getState().world) || dispatch(checkForMonster(pos))) {\n            break;\n          }\n        }\n        break;\n      case 'WEST':\n        for (let x = position[0]; x > position[0] - range; x -= SPRITE_SIZE) {\n          const pos = getNewPosition([x, position[1]], direction);\n          targetPosition = pos;\n          if (!observeImpassable(pos, getState().world) || dispatch(checkForMonster(pos))) {\n            break;\n          }\n        }\n        break;\n      default:\n    }\n    return targetPosition;\n  };\n};\nexport default function attackMonster() {\n  return (dispatch, getState) => {\n    // get player direction and the location of position to attack\n    const {\n      position,\n      direction\n    } = getState().player;\n    let newPos = getNewPosition(position, direction);\n\n    // if the attacked tile is in bounds\n    if (observeBoundaries(newPos) && observeImpassable(newPos, getState().world)) {\n      const {\n        stats,\n        world,\n        monsters\n      } = getState();\n      const {\n        currentMap\n      } = world;\n      const {\n        components\n      } = monsters;\n      const weapon = stats.equippedItems.weapon || FISTS;\n      const targetPosition = dispatch(findTarget(position, direction, weapon.range * SPRITE_SIZE));\n      const monsterId = dispatch(checkForMonster(targetPosition));\n      if (monsterId) {\n        // If we're targetting a monster\n        const currMonster = components[currentMap][monsterId];\n        const monsterPos = currMonster.position;\n        const ability = weapon.kind === 'melee' ? 'strength' : weapon.kind === 'ranged' ? 'dexterity' : 'intelligence';\n        const modifier = calculateModifier(stats.abilities[ability]);\n        const roll = d20();\n        const attackValue = roll + modifier;\n        if (weapon.projectile) {\n          dispatch({\n            type: 'USE_PROJECTILE',\n            payload: {\n              position: targetPosition,\n              projectile: weapon.projectile\n            }\n          });\n        }\n        if (roll === 20) {\n          dispatch({\n            type: 'CRITICAL_HIT',\n            payload: {\n              notation: 'd20 + ' + modifier,\n              roll: roll,\n              ability\n            }\n          });\n        } else {\n          dispatch({\n            type: 'ABILITY_CHECK',\n            payload: {\n              notation: 'd20 + ' + modifier,\n              roll: attackValue,\n              ability,\n              check: currMonster.defence,\n              entity: currMonster.type,\n              against: 'defence'\n            }\n          });\n        }\n        const damage = roll === 20 ? calculateDamage(weapon.damage, true) : attackValue >= currMonster.defence ? calculateDamage(weapon.damage, false) : 0;\n        if (damage > 0) {\n          // Only show the attack animation if they hit the monster\n          dispatch({\n            type: 'PLAYER_ATTACK',\n            payload: null\n          });\n        }\n\n        // deal damage to monster\n        dispatch({\n          type: 'DAMAGE_TO_MONSTER',\n          payload: {\n            damage,\n            id: currMonster.id,\n            map: currentMap,\n            entity: currMonster.type,\n            from: 'player'\n          }\n        });\n\n        // check if monster died\n        if (currMonster.hp - damage <= 0) {\n          // and get some exp\n          dispatch({\n            type: 'GET_EXP',\n            payload: currMonster.exp\n          });\n          if (stats.exp + currMonster.exp >= stats.expToLevel) {\n            dispatch({\n              type: 'PAUSE',\n              payload: {\n                pause: true,\n                levelUp: true\n              }\n            });\n          }\n          // play death sound\n          dispatch({\n            type: 'MONSTER_DIED',\n            payload: currMonster.type\n          });\n          // replace monster will blood spill\n          // need to pass relative tile index\n          dispatch({\n            type: 'ADD_BLOOD_SPILL',\n            payload: {\n              x: monsterPos[0] / SPRITE_SIZE,\n              y: monsterPos[1] / SPRITE_SIZE\n            }\n          });\n        }\n\n        // take a turn if the player attacked something\n        dispatch({\n          type: 'TAKE_TURN',\n          payload: null\n        });\n        dispatch(applyEffects());\n      } else {\n        // Hit a wall or something else\n        if (weapon.kind === 'ranged') {\n          dispatch({\n            type: 'USE_PROJECTILE',\n            payload: {\n              position: targetPosition,\n              projectile: weapon.projectile\n            }\n          });\n        }\n        dispatch({\n          type: 'PLAYER_ATTACK',\n          payload: null\n        });\n      }\n    }\n  };\n}\nexport function observeImpassable(newPos, world) {\n  const nextTile = getNextTile(world, newPos);\n  return nextTile < 5;\n}","map":{"version":3,"names":["checkForMonster","getNewPosition","observeBoundaries","applyEffects","calculateDamage","d20","calculateModifier","getNextTile","SPRITE_SIZE","FISTS","findTarget","position","direction","range","dispatch","getState","targetPosition","y","pos","observeImpassable","world","x","attackMonster","player","newPos","stats","monsters","currentMap","components","weapon","equippedItems","monsterId","currMonster","monsterPos","ability","kind","modifier","abilities","roll","attackValue","projectile","type","payload","notation","check","defence","entity","against","damage","id","map","from","hp","exp","expToLevel","pause","levelUp","nextTile"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/player/actions/attack-monster.jsx"],"sourcesContent":["import {\n    checkForMonster,\n    getNewPosition,\n    observeBoundaries,\n    applyEffects,\n} from './move-player';\nimport { calculateDamage, d20 } from '../../../utils/dice';\nimport calculateModifier from '../../../utils/calculate-modifier';\nimport getNextTile from '../../../utils/get-next-tile';\nimport { SPRITE_SIZE, FISTS } from '../../../config/constants';\n\nexport const findTarget = (position, direction, range) => {\n    return (dispatch, getState) => {\n        let targetPosition = null;\n        switch (direction) {\n            case 'NORTH':\n                for (\n                    let y = position[1];\n                    y > position[1] - range;\n                    y -= SPRITE_SIZE\n                ) {\n                    const pos = getNewPosition([position[0], y], direction);\n                    targetPosition = pos;\n                    if (\n                        !observeImpassable(pos, getState().world) ||\n                        dispatch(checkForMonster(pos))\n                    ) {\n                        break;\n                    }\n                }\n                break;\n            case 'SOUTH':\n                for (\n                    let y = position[1];\n                    y < position[1] + range;\n                    y += SPRITE_SIZE\n                ) {\n                    const pos = getNewPosition([position[0], y], direction);\n                    targetPosition = pos;\n                    if (\n                        !observeImpassable(pos, getState().world) ||\n                        dispatch(checkForMonster(pos))\n                    ) {\n                        break;\n                    }\n                }\n                break;\n            case 'EAST':\n                for (\n                    let x = position[0];\n                    x < position[0] + range;\n                    x += SPRITE_SIZE\n                ) {\n                    const pos = getNewPosition([x, position[1]], direction);\n                    targetPosition = pos;\n                    if (\n                        !observeImpassable(pos, getState().world) ||\n                        dispatch(checkForMonster(pos))\n                    ) {\n                        break;\n                    }\n                }\n                break;\n            case 'WEST':\n                for (\n                    let x = position[0];\n                    x > position[0] - range;\n                    x -= SPRITE_SIZE\n                ) {\n                    const pos = getNewPosition([x, position[1]], direction);\n                    targetPosition = pos;\n                    if (\n                        !observeImpassable(pos, getState().world) ||\n                        dispatch(checkForMonster(pos))\n                    ) {\n                        break;\n                    }\n                }\n                break;\n            default:\n        }\n\n        return targetPosition;\n    };\n};\n\nexport default function attackMonster() {\n    return (dispatch, getState) => {\n        // get player direction and the location of position to attack\n        const { position, direction } = getState().player;\n        let newPos = getNewPosition(position, direction);\n\n        // if the attacked tile is in bounds\n        if (\n            observeBoundaries(newPos) &&\n            observeImpassable(newPos, getState().world)\n        ) {\n            const { stats, world, monsters } = getState();\n            const { currentMap } = world;\n            const { components } = monsters;\n\n            const weapon = stats.equippedItems.weapon || FISTS;\n\n            const targetPosition = dispatch(\n                findTarget(position, direction, weapon.range * SPRITE_SIZE)\n            );\n\n            const monsterId = dispatch(checkForMonster(targetPosition));\n            if (monsterId) {\n                // If we're targetting a monster\n                const currMonster = components[currentMap][monsterId];\n                const monsterPos = currMonster.position;\n\n                const ability =\n                    weapon.kind === 'melee'\n                        ? 'strength'\n                        : weapon.kind === 'ranged'\n                        ? 'dexterity'\n                        : 'intelligence';\n\n                const modifier = calculateModifier(stats.abilities[ability]);\n                const roll = d20();\n                const attackValue = roll + modifier;\n\n                if (weapon.projectile) {\n                    dispatch({\n                        type: 'USE_PROJECTILE',\n                        payload: {\n                            position: targetPosition,\n                            projectile: weapon.projectile,\n                        },\n                    });\n                }\n\n                if (roll === 20) {\n                    dispatch({\n                        type: 'CRITICAL_HIT',\n                        payload: {\n                            notation: 'd20 + ' + modifier,\n                            roll: roll,\n                            ability,\n                        },\n                    });\n                } else {\n                    dispatch({\n                        type: 'ABILITY_CHECK',\n                        payload: {\n                            notation: 'd20 + ' + modifier,\n                            roll: attackValue,\n                            ability,\n                            check: currMonster.defence,\n                            entity: currMonster.type,\n                            against: 'defence',\n                        },\n                    });\n                }\n\n                const damage =\n                    roll === 20\n                        ? calculateDamage(weapon.damage, true)\n                        : attackValue >= currMonster.defence\n                        ? calculateDamage(weapon.damage, false)\n                        : 0;\n\n                if (damage > 0) {\n                    // Only show the attack animation if they hit the monster\n                    dispatch({\n                        type: 'PLAYER_ATTACK',\n                        payload: null,\n                    });\n                }\n\n                // deal damage to monster\n                dispatch({\n                    type: 'DAMAGE_TO_MONSTER',\n                    payload: {\n                        damage,\n                        id: currMonster.id,\n                        map: currentMap,\n                        entity: currMonster.type,\n                        from: 'player',\n                    },\n                });\n\n                // check if monster died\n                if (currMonster.hp - damage <= 0) {\n                    // and get some exp\n                    dispatch({\n                        type: 'GET_EXP',\n                        payload: currMonster.exp,\n                    });\n                    if (stats.exp + currMonster.exp >= stats.expToLevel) {\n                        dispatch({\n                            type: 'PAUSE',\n                            payload: {\n                                pause: true,\n                                levelUp: true,\n                            },\n                        });\n                    }\n                    // play death sound\n                    dispatch({\n                        type: 'MONSTER_DIED',\n                        payload: currMonster.type,\n                    });\n                    // replace monster will blood spill\n                    // need to pass relative tile index\n                    dispatch({\n                        type: 'ADD_BLOOD_SPILL',\n                        payload: {\n                            x: monsterPos[0] / SPRITE_SIZE,\n                            y: monsterPos[1] / SPRITE_SIZE,\n                        },\n                    });\n                }\n\n                // take a turn if the player attacked something\n                dispatch({\n                    type: 'TAKE_TURN',\n                    payload: null,\n                });\n\n                dispatch(applyEffects());\n            } else {\n                // Hit a wall or something else\n                if (weapon.kind === 'ranged') {\n                    dispatch({\n                        type: 'USE_PROJECTILE',\n                        payload: {\n                            position: targetPosition,\n                            projectile: weapon.projectile,\n                        },\n                    });\n                }\n                dispatch({\n                    type: 'PLAYER_ATTACK',\n                    payload: null,\n                });\n            }\n        }\n    };\n}\n\nexport function observeImpassable(newPos, world) {\n    const nextTile = getNextTile(world, newPos);\n\n    return nextTile < 5;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}