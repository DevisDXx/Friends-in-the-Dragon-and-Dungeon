{"ast":null,"code":"import _objectSpread from \"C:/Users/devis/Downloads/react-rpg.com-master/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _cloneDeep from 'lodash.clonedeep';\nimport calculateModifier from '../../utils/calculate-modifier';\nimport calculateMaxManaPool from '../../utils/calculate-max-mana-pool';\nimport calculateMaxHpPool from '../../utils/calculate-max-hp-pool';\nimport calculateDefenceBonus from '../../utils/calculate-defence-bonus';\nconst initialState = {\n  abilities: {\n    constitution: 0,\n    dexterity: 0,\n    strength: 0,\n    wisdom: 0,\n    intelligence: 0,\n    charisma: 0,\n    points: 0\n  },\n  character: {\n    characterName: '',\n    characterRace: '',\n    characterClass: ''\n  },\n  hp: 0,\n  abilityModifierHp: 0,\n  maxHp: 0,\n  mana: 0,\n  abilityModifierMana: 0,\n  maxMana: 0,\n  defence: 0,\n  level: 1,\n  exp: 0,\n  expToLevel: 20,\n  gold: 0,\n  equippedItems: {},\n  levelUp: {\n    level: 0,\n    hp: 0,\n    mana: 0\n  }\n};\nconst statsReducer = function () {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let {\n    type,\n    payload\n  } = arguments.length > 1 ? arguments[1] : undefined;\n  let newState;\n  switch (type) {\n    case 'CREATE_CHARACTER':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        character: {\n          characterName: payload.characterName,\n          characterRace: payload.characterRace,\n          characterClass: payload.characterClass\n        }\n      });\n    case 'GET_GOLD':\n      // add gold to current gold\n      return _objectSpread(_objectSpread({}, state), {}, {\n        gold: state.gold + payload\n      });\n    case 'LOSE_GOLD':\n      // add gold to current gold\n      return _objectSpread(_objectSpread({}, state), {}, {\n        gold: state.gold - payload\n      });\n    case 'SET_ABILITY_SCORES':\n      // calculate new mana\n      const newAbilityModifierMana = calculateMaxManaPool(state.level, calculateModifier(payload.abilities.intelligence));\n      const manaDifference = newAbilityModifierMana - state.abilityModifierMana;\n      state.mana += manaDifference;\n      state.maxMana += manaDifference;\n      state.abilityModifierMana = newAbilityModifierMana;\n\n      // calculate new hp\n      const newAbilityModifierHp = calculateMaxHpPool(state.level, calculateModifier(payload.abilities.constitution));\n      const hpDifference = newAbilityModifierHp - state.abilityModifierHp;\n      state.hp += hpDifference;\n      state.maxHp += hpDifference;\n      state.abilityModifierHp = newAbilityModifierHp;\n      const previousDex = calculateModifier(state.abilities.dexterity);\n      const currentDex = calculateModifier(payload.abilities.dexterity);\n      const prevDefenceBonus = calculateDefenceBonus(previousDex);\n      const currDefenceBonus = calculateDefenceBonus(currentDex);\n      state.defence = state.defence - prevDefenceBonus + currDefenceBonus;\n      return _objectSpread(_objectSpread({}, state), {}, {\n        abilities: payload.abilities\n      });\n    case 'UNEQUIP_ITEM':\n      newState = _cloneDeep(state);\n\n      // iterate over each effect\n      Object.keys(payload.effect).forEach(effectName => {\n        switch (effectName) {\n          case 'defence':\n            newState.defence -= payload.effect[effectName];\n            break;\n          case 'hp':\n            newState.hp -= payload.effect[effectName];\n            if (newState.hp < 1) newState.hp = 1;\n            newState.maxHp -= payload.effect[effectName];\n            break;\n          case 'mana':\n            newState.mana -= payload.effect[effectName];\n            if (newState.mana < 1) newState.mana = 1;\n            newState.maxMana -= payload.effect[effectName];\n            break;\n          default:\n        }\n      });\n\n      // check the type\n      switch (payload.type) {\n        case 'weapon':\n          delete newState.equippedItems.weapon;\n          break;\n        case 'armor::body':\n          delete newState.equippedItems.armor.body;\n          break;\n        case 'armor::helmet':\n          delete newState.equippedItems.armor.helmet;\n          break;\n        case 'armor::pants':\n          delete newState.equippedItems.armor.pants;\n          break;\n        case 'armor::boots':\n          delete newState.equippedItems.armor.boots;\n          break;\n        case 'armor::gloves':\n          delete newState.equippedItems.armor.gloves;\n          break;\n        case 'ring':\n          delete newState.equippedItems.ring;\n          break;\n        default:\n      }\n      return newState;\n    case 'EQUIP_ITEM':\n      newState = _cloneDeep(state);\n      const item = payload;\n      // see what type of item it is\n      switch (item.type) {\n        case 'weapon':\n          if (newState.equippedItems.weapon && newState.equippedItems.weapon.effect) {\n            removeEffects(newState.equippedItems.weapon, newState);\n          }\n          newState.equippedItems.weapon = item;\n          break;\n        case 'armor::body':\n          if (newState.equippedItems.armor && newState.equippedItems.armor.body && newState.equippedItems.armor.body.effect) {\n            removeEffects(newState.equippedItems.armor.body, newState);\n          }\n          // if there's already armor\n          // safely add new armor peice to object\n          newState.equippedItems.armor = _objectSpread(_objectSpread({}, newState.equippedItems.armor), {}, {\n            body: item\n          });\n          break;\n        case 'armor::helmet':\n          // if there's already armor\n          if (newState.equippedItems.armor && newState.equippedItems.armor.helmet && newState.equippedItems.armor.helmet.effect) {\n            removeEffects(newState.equippedItems.armor.helmet, newState);\n          }\n          // safely add new armor peice to object\n          newState.equippedItems.armor = _objectSpread(_objectSpread({}, newState.equippedItems.armor), {}, {\n            helmet: item\n          });\n          break;\n        case 'armor::pants':\n          // if there's already armor\n          if (newState.equippedItems.armor && newState.equippedItems.armor.pants && newState.equippedItems.armor.pants.effect) {\n            removeEffects(newState.equippedItems.armor.pants, newState);\n          }\n          // safely add new armor peice to object\n          newState.equippedItems.armor = _objectSpread(_objectSpread({}, newState.equippedItems.armor), {}, {\n            pants: item\n          });\n          break;\n        case 'armor::gloves':\n          // if there's already armor\n          if (newState.equippedItems.armor && newState.equippedItems.armor.gloves && newState.equippedItems.armor.gloves.effect) {\n            removeEffects(newState.equippedItems.armor.gloves, newState);\n          }\n          // safely add new armor peice to object\n          newState.equippedItems.armor = _objectSpread(_objectSpread({}, newState.equippedItems.armor), {}, {\n            gloves: item\n          });\n          break;\n        case 'armor::boots':\n          // if there's already armor\n          if (newState.equippedItems.armor && newState.equippedItems.armor.boots && newState.equippedItems.armor.boots.effect) {\n            removeEffects(newState.equippedItems.armor.boots, newState);\n          }\n          // safely add new armor peice to object\n          newState.equippedItems.armor = _objectSpread(_objectSpread({}, newState.equippedItems.armor), {}, {\n            boots: item\n          });\n          break;\n        case 'ring':\n          const equippedRing = newState.equippedItems.ring;\n          // if there's already a ring\n          if (equippedRing) {\n            // subtract it's benefits\n            Object.keys(equippedRing.effect).forEach(effectName => {\n              switch (effectName) {\n                case 'defence':\n                  newState.defence -= equippedRing.effect[effectName];\n                  break;\n                case 'hp':\n                  newState.hp -= equippedRing.effect[effectName];\n                  if (newState.hp < 1) newState.hp = 1;\n                  newState.maxHp -= equippedRing.effect[effectName];\n                  break;\n                default:\n              }\n            });\n          }\n          newState.equippedItems.ring = item;\n          break;\n        default:\n      }\n\n      // iterate over each new effect\n      Object.keys(item.effect).forEach(effectName => {\n        switch (effectName) {\n          case 'defence':\n            newState.defence += item.effect[effectName];\n            break;\n          case 'hp':\n            newState.hp += item.effect[effectName];\n            newState.maxHp += item.effect[effectName];\n            break;\n          case 'mana':\n            newState.mana += payload.effect[effectName];\n            newState.maxMana += payload.effect[effectName];\n            break;\n          default:\n        }\n      });\n      return newState;\n    case 'HEAL_HP':\n      // heal the hp\n      let _hp = state.hp + payload;\n      // dont go above max hp\n      if (_hp > state.maxHp) _hp = state.maxHp;\n      return _objectSpread(_objectSpread({}, state), {}, {\n        hp: _hp\n      });\n    case 'RESTORE_MANA':\n      // regenerate the mana\n      let _mana = state.mana + payload.amount;\n      // don't go above max mana\n      if (_mana > state.maxMana) _mana = state.maxMana;\n      return _objectSpread(_objectSpread({}, state), {}, {\n        mana: _mana\n      });\n    case 'CAST_SPELL':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        mana: state.mana - payload.projectile.manaCost\n      });\n    case 'DAMAGE_TO_PLAYER':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        hp: state.hp - payload.damage\n      });\n    case 'GET_EXP':\n      newState = _cloneDeep(state);\n      const newTotalExp = state.exp + payload;\n      const {\n        expToLevel\n      } = state;\n      // if they are leveling up\n      if (newTotalExp >= expToLevel) {\n        // increment level\n        newState.level += 1;\n\n        // calculate leftover exp if it isn't exactly enough\n        if (!(newState.exp === expToLevel)) {\n          const leftoverExp = newTotalExp % expToLevel;\n          newState.exp = leftoverExp;\n        }\n\n        // set next exp goal to be 1.5 times as much if player is 5 or less\n        if (newState.level < 6) {\n          newState.expToLevel = Math.floor(state.expToLevel * 1.5);\n        } // otherwise set it to be 1.25 times as much\n        else if (newState.level < 20) {\n          newState.expToLevel = Math.floor(state.expToLevel * 1.25);\n        } else {} // let the exp goal remain static if they are lv 20+\n\n        // calculate new hp\n        const newAbilityModifierHp = calculateMaxHpPool(newState.level, calculateModifier(state.abilities.constitution));\n        newState.levelUp.hp = newAbilityModifierHp - state.abilityModifierHp;\n        newState.hp += newState.levelUp.hp;\n        newState.maxHp += newState.levelUp.hp;\n        newState.abilityModifierHp = newAbilityModifierHp;\n\n        // calculate new mana\n        const newAbilityModifierMana = calculateMaxManaPool(newState.level, calculateModifier(state.abilities.intelligence));\n        newState.levelUp.mana = newAbilityModifierMana - state.abilityModifierMana;\n        newState.mana += newState.levelUp.mana;\n        newState.maxMana += newState.levelUp.mana;\n        newState.abilityModifierMana = newAbilityModifierMana;\n        newState.levelUp.level = newState.level;\n      } else {\n        // they aren't leveling up\n        newState.exp += payload;\n      }\n      return newState;\n    case 'RESET':\n      return initialState;\n    case 'LOAD_DATA':\n      return _objectSpread(_objectSpread({}, initialState), payload.stats);\n    default:\n      return state;\n  }\n};\nconst removeEffects = (item, newState) => {\n  Object.keys(item.effect).forEach(effectName => {\n    switch (effectName) {\n      case 'defence':\n        newState.defence -= item.effect[effectName];\n        break;\n      case 'hp':\n        newState.hp -= item.effect[effectName];\n        if (newState.hp < 1) newState.hp = 1;\n        newState.maxHp -= item.effect[effectName];\n        break;\n      case 'mana':\n        newState.mana -= item.effect[effectName];\n        if (newState.mana < 1) newState.mana = 1;\n        newState.maxMana -= item.effect[effectName];\n        break;\n      default:\n    }\n  });\n};\nexport default statsReducer;","map":{"version":3,"names":["_cloneDeep","calculateModifier","calculateMaxManaPool","calculateMaxHpPool","calculateDefenceBonus","initialState","abilities","constitution","dexterity","strength","wisdom","intelligence","charisma","points","character","characterName","characterRace","characterClass","hp","abilityModifierHp","maxHp","mana","abilityModifierMana","maxMana","defence","level","exp","expToLevel","gold","equippedItems","levelUp","statsReducer","state","arguments","length","undefined","type","payload","newState","_objectSpread","newAbilityModifierMana","manaDifference","newAbilityModifierHp","hpDifference","previousDex","currentDex","prevDefenceBonus","currDefenceBonus","Object","keys","effect","forEach","effectName","weapon","armor","body","helmet","pants","boots","gloves","ring","item","removeEffects","equippedRing","_hp","_mana","amount","projectile","manaCost","damage","newTotalExp","leftoverExp","Math","floor","stats"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/stats/reducer.jsx"],"sourcesContent":["import _cloneDeep from 'lodash.clonedeep';\nimport calculateModifier from '../../utils/calculate-modifier';\nimport calculateMaxManaPool from '../../utils/calculate-max-mana-pool';\nimport calculateMaxHpPool from '../../utils/calculate-max-hp-pool';\nimport calculateDefenceBonus from '../../utils/calculate-defence-bonus';\n\nconst initialState = {\n    abilities: {\n        constitution: 0,\n        dexterity: 0,\n        strength: 0,\n        wisdom: 0,\n        intelligence: 0,\n        charisma: 0,\n        points: 0,\n    },\n    character: {\n        characterName: '',\n        characterRace: '',\n        characterClass: '',\n    },\n    hp: 0,\n    abilityModifierHp: 0,\n    maxHp: 0,\n    mana: 0,\n    abilityModifierMana: 0,\n    maxMana: 0,\n    defence: 0,\n    level: 1,\n    exp: 0,\n    expToLevel: 20,\n    gold: 0,\n    equippedItems: {},\n    levelUp: { level: 0, hp: 0, mana: 0 },\n};\n\nconst statsReducer = (state = initialState, { type, payload }) => {\n    let newState;\n\n    switch (type) {\n        case 'CREATE_CHARACTER':\n            return {\n                ...state,\n                character: {\n                    characterName: payload.characterName,\n                    characterRace: payload.characterRace,\n                    characterClass: payload.characterClass,\n                },\n            };\n\n        case 'GET_GOLD':\n            // add gold to current gold\n            return { ...state, gold: state.gold + payload };\n\n        case 'LOSE_GOLD':\n            // add gold to current gold\n            return { ...state, gold: state.gold - payload };\n\n        case 'SET_ABILITY_SCORES':\n            // calculate new mana\n            const newAbilityModifierMana = calculateMaxManaPool(\n                state.level,\n                calculateModifier(payload.abilities.intelligence)\n            );\n            const manaDifference =\n                newAbilityModifierMana - state.abilityModifierMana;\n\n            state.mana += manaDifference;\n            state.maxMana += manaDifference;\n            state.abilityModifierMana = newAbilityModifierMana;\n\n            // calculate new hp\n            const newAbilityModifierHp = calculateMaxHpPool(\n                state.level,\n                calculateModifier(payload.abilities.constitution)\n            );\n            const hpDifference = newAbilityModifierHp - state.abilityModifierHp;\n\n            state.hp += hpDifference;\n            state.maxHp += hpDifference;\n            state.abilityModifierHp = newAbilityModifierHp;\n\n            const previousDex = calculateModifier(state.abilities.dexterity);\n            const currentDex = calculateModifier(payload.abilities.dexterity);\n\n            const prevDefenceBonus = calculateDefenceBonus(previousDex);\n            const currDefenceBonus = calculateDefenceBonus(currentDex);\n\n            state.defence = state.defence - prevDefenceBonus + currDefenceBonus;\n\n            return { ...state, abilities: payload.abilities };\n\n        case 'UNEQUIP_ITEM':\n            newState = _cloneDeep(state);\n\n            // iterate over each effect\n            Object.keys(payload.effect).forEach(effectName => {\n                switch (effectName) {\n                    case 'defence':\n                        newState.defence -= payload.effect[effectName];\n                        break;\n\n                    case 'hp':\n                        newState.hp -= payload.effect[effectName];\n                        if (newState.hp < 1) newState.hp = 1;\n                        newState.maxHp -= payload.effect[effectName];\n                        break;\n\n                    case 'mana':\n                        newState.mana -= payload.effect[effectName];\n                        if (newState.mana < 1) newState.mana = 1;\n                        newState.maxMana -= payload.effect[effectName];\n                        break;\n\n                    default:\n                }\n            });\n\n            // check the type\n            switch (payload.type) {\n                case 'weapon':\n                    delete newState.equippedItems.weapon;\n                    break;\n\n                case 'armor::body':\n                    delete newState.equippedItems.armor.body;\n                    break;\n\n                case 'armor::helmet':\n                    delete newState.equippedItems.armor.helmet;\n                    break;\n\n                case 'armor::pants':\n                    delete newState.equippedItems.armor.pants;\n                    break;\n\n                case 'armor::boots':\n                    delete newState.equippedItems.armor.boots;\n                    break;\n\n                case 'armor::gloves':\n                    delete newState.equippedItems.armor.gloves;\n                    break;\n\n                case 'ring':\n                    delete newState.equippedItems.ring;\n\n                    break;\n\n                default:\n            }\n\n            return newState;\n\n        case 'EQUIP_ITEM':\n            newState = _cloneDeep(state);\n            const item = payload;\n            // see what type of item it is\n            switch (item.type) {\n                case 'weapon':\n                    if (\n                        newState.equippedItems.weapon &&\n                        newState.equippedItems.weapon.effect\n                    ) {\n                        removeEffects(newState.equippedItems.weapon, newState);\n                    }\n                    newState.equippedItems.weapon = item;\n                    break;\n\n                case 'armor::body':\n                    if (\n                        newState.equippedItems.armor &&\n                        newState.equippedItems.armor.body &&\n                        newState.equippedItems.armor.body.effect\n                    ) {\n                        removeEffects(\n                            newState.equippedItems.armor.body,\n                            newState\n                        );\n                    }\n                    // if there's already armor\n                    // safely add new armor peice to object\n                    newState.equippedItems.armor = {\n                        ...newState.equippedItems.armor,\n                        body: item,\n                    };\n                    break;\n\n                case 'armor::helmet':\n                    // if there's already armor\n                    if (\n                        newState.equippedItems.armor &&\n                        newState.equippedItems.armor.helmet &&\n                        newState.equippedItems.armor.helmet.effect\n                    ) {\n                        removeEffects(\n                            newState.equippedItems.armor.helmet,\n                            newState\n                        );\n                    }\n                    // safely add new armor peice to object\n                    newState.equippedItems.armor = {\n                        ...newState.equippedItems.armor,\n                        helmet: item,\n                    };\n                    break;\n\n                case 'armor::pants':\n                    // if there's already armor\n                    if (\n                        newState.equippedItems.armor &&\n                        newState.equippedItems.armor.pants &&\n                        newState.equippedItems.armor.pants.effect\n                    ) {\n                        removeEffects(\n                            newState.equippedItems.armor.pants,\n                            newState\n                        );\n                    }\n                    // safely add new armor peice to object\n                    newState.equippedItems.armor = {\n                        ...newState.equippedItems.armor,\n                        pants: item,\n                    };\n                    break;\n\n                case 'armor::gloves':\n                    // if there's already armor\n                    if (\n                        newState.equippedItems.armor &&\n                        newState.equippedItems.armor.gloves &&\n                        newState.equippedItems.armor.gloves.effect\n                    ) {\n                        removeEffects(\n                            newState.equippedItems.armor.gloves,\n                            newState\n                        );\n                    }\n                    // safely add new armor peice to object\n                    newState.equippedItems.armor = {\n                        ...newState.equippedItems.armor,\n                        gloves: item,\n                    };\n                    break;\n\n                case 'armor::boots':\n                    // if there's already armor\n                    if (\n                        newState.equippedItems.armor &&\n                        newState.equippedItems.armor.boots &&\n                        newState.equippedItems.armor.boots.effect\n                    ) {\n                        removeEffects(\n                            newState.equippedItems.armor.boots,\n                            newState\n                        );\n                    }\n                    // safely add new armor peice to object\n                    newState.equippedItems.armor = {\n                        ...newState.equippedItems.armor,\n                        boots: item,\n                    };\n                    break;\n\n                case 'ring':\n                    const equippedRing = newState.equippedItems.ring;\n                    // if there's already a ring\n                    if (equippedRing) {\n                        // subtract it's benefits\n                        Object.keys(equippedRing.effect).forEach(effectName => {\n                            switch (effectName) {\n                                case 'defence':\n                                    newState.defence -=\n                                        equippedRing.effect[effectName];\n                                    break;\n\n                                case 'hp':\n                                    newState.hp -=\n                                        equippedRing.effect[effectName];\n                                    if (newState.hp < 1) newState.hp = 1;\n                                    newState.maxHp -=\n                                        equippedRing.effect[effectName];\n                                    break;\n\n                                default:\n                            }\n                        });\n                    }\n\n                    newState.equippedItems.ring = item;\n                    break;\n\n                default:\n            }\n\n            // iterate over each new effect\n            Object.keys(item.effect).forEach(effectName => {\n                switch (effectName) {\n                    case 'defence':\n                        newState.defence += item.effect[effectName];\n                        break;\n\n                    case 'hp':\n                        newState.hp += item.effect[effectName];\n                        newState.maxHp += item.effect[effectName];\n                        break;\n\n                    case 'mana':\n                        newState.mana += payload.effect[effectName];\n                        newState.maxMana += payload.effect[effectName];\n                        break;\n\n                    default:\n                }\n            });\n            return newState;\n\n        case 'HEAL_HP':\n            // heal the hp\n            let _hp = state.hp + payload;\n            // dont go above max hp\n            if (_hp > state.maxHp) _hp = state.maxHp;\n\n            return { ...state, hp: _hp };\n\n        case 'RESTORE_MANA':\n            // regenerate the mana\n            let _mana = state.mana + payload.amount;\n            // don't go above max mana\n            if (_mana > state.maxMana) _mana = state.maxMana;\n\n            return { ...state, mana: _mana };\n\n        case 'CAST_SPELL':\n            return { ...state, mana: state.mana - payload.projectile.manaCost };\n\n        case 'DAMAGE_TO_PLAYER':\n            return { ...state, hp: state.hp - payload.damage };\n\n        case 'GET_EXP':\n            newState = _cloneDeep(state);\n\n            const newTotalExp = state.exp + payload;\n            const { expToLevel } = state;\n            // if they are leveling up\n            if (newTotalExp >= expToLevel) {\n                // increment level\n                newState.level += 1;\n\n                // calculate leftover exp if it isn't exactly enough\n                if (!(newState.exp === expToLevel)) {\n                    const leftoverExp = newTotalExp % expToLevel;\n                    newState.exp = leftoverExp;\n                }\n\n                // set next exp goal to be 1.5 times as much if player is 5 or less\n                if (newState.level < 6) {\n                    newState.expToLevel = Math.floor(state.expToLevel * 1.5);\n                } // otherwise set it to be 1.25 times as much\n                else if (newState.level < 20) {\n                    newState.expToLevel = Math.floor(state.expToLevel * 1.25);\n                } else {\n                } // let the exp goal remain static if they are lv 20+\n\n                // calculate new hp\n                const newAbilityModifierHp = calculateMaxHpPool(\n                    newState.level,\n                    calculateModifier(state.abilities.constitution)\n                );\n                newState.levelUp.hp =\n                    newAbilityModifierHp - state.abilityModifierHp;\n                newState.hp += newState.levelUp.hp;\n                newState.maxHp += newState.levelUp.hp;\n                newState.abilityModifierHp = newAbilityModifierHp;\n\n                // calculate new mana\n                const newAbilityModifierMana = calculateMaxManaPool(\n                    newState.level,\n                    calculateModifier(state.abilities.intelligence)\n                );\n                newState.levelUp.mana =\n                    newAbilityModifierMana - state.abilityModifierMana;\n                newState.mana += newState.levelUp.mana;\n                newState.maxMana += newState.levelUp.mana;\n                newState.abilityModifierMana = newAbilityModifierMana;\n\n                newState.levelUp.level = newState.level;\n            } else {\n                // they aren't leveling up\n                newState.exp += payload;\n            }\n\n            return newState;\n\n        case 'RESET':\n            return initialState;\n\n        case 'LOAD_DATA':\n            return { ...initialState, ...payload.stats };\n\n        default:\n            return state;\n    }\n};\n\nconst removeEffects = (item, newState) => {\n    Object.keys(item.effect).forEach(effectName => {\n        switch (effectName) {\n            case 'defence':\n                newState.defence -= item.effect[effectName];\n                break;\n\n            case 'hp':\n                newState.hp -= item.effect[effectName];\n                if (newState.hp < 1) newState.hp = 1;\n                newState.maxHp -= item.effect[effectName];\n                break;\n\n            case 'mana':\n                newState.mana -= item.effect[effectName];\n                if (newState.mana < 1) newState.mana = 1;\n                newState.maxMana -= item.effect[effectName];\n                break;\n\n            default:\n        }\n    });\n};\n\nexport default statsReducer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}