{"ast":null,"code":"import { observeImpassable, checkForOtherMonster } from './move-monster';\nimport attackMonster from './attack-monster';\nimport { SPRITE_SIZE } from '../../../config/constants';\n\n/**\n * An AI for monsters that have been scared by the player\n *\n * @param {*} sightBox The players FOV\n * @param {*} currentMap The map the player is in\n * @param {*} monster The monster we're moving\n */\nfunction moveScared(sightBox, currentMap, monster) {\n  return (dispatch, getState) => {\n    const playerPosition = getState().player.position;\n    const {\n      id,\n      position,\n      direction\n    } = monster;\n    const possibleDirections = [];\n    if (playerPosition[1] !== position[1] - SPRITE_SIZE && dispatch(observeImpassable([position[0], position[1] - SPRITE_SIZE]))) {\n      possibleDirections.push([position[0], position[1] - SPRITE_SIZE]);\n    }\n    if (playerPosition[1] !== position[1] + SPRITE_SIZE && dispatch(observeImpassable([position[0], position[1] + SPRITE_SIZE]))) {\n      possibleDirections.push([position[0], position[1] + SPRITE_SIZE]);\n    }\n    if (playerPosition[0] !== position[0] - SPRITE_SIZE && dispatch(observeImpassable([position[0] - SPRITE_SIZE, position[1]]))) {\n      possibleDirections.push([position[0] - SPRITE_SIZE, position[1]]);\n    }\n    if (playerPosition[0] !== position[0] + SPRITE_SIZE && dispatch(observeImpassable([position[0] + SPRITE_SIZE, position[1]]))) {\n      possibleDirections.push([position[0] + SPRITE_SIZE, position[1]]);\n    }\n    if (possibleDirections.length > 0) {\n      const newPosition = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];\n\n      // From testing, this doesn't really happen... But, if the monster is scared,\n      // it may randomly attack other monsters if they're in thise ones way\n      const monsterID = dispatch(checkForOtherMonster(id, newPosition, currentMap));\n      if (monsterID) {\n        // recalculate if the monster is in sight\n        let inSight = false;\n        // look through each current sight box tile\n        sightBox.forEach(tile => {\n          // if the monster is in sight\n          const newMonsterPos = position.map(value => value / SPRITE_SIZE);\n          if (JSON.stringify(tile) === JSON.stringify(newMonsterPos)) {\n            inSight = true;\n          }\n        });\n\n        // if the monster is now in sight\n        if (inSight) {\n          dispatch({\n            type: 'REVEAL_MONSTER',\n            payload: {\n              id,\n              map: currentMap\n            }\n          });\n        } else {\n          // if the monster is now out of sight\n          dispatch({\n            type: 'HIDE_MONSTER',\n            payload: {\n              id,\n              map: currentMap\n            }\n          });\n        }\n        dispatch(attackMonster(monster, monsterID, currentMap));\n      } else {\n        let inSight = false;\n        // look through each current sight box tile\n        sightBox.forEach(tile => {\n          // if the monster is in sight\n          const newMonsterPos = newPosition.map(value => value / SPRITE_SIZE);\n          if (JSON.stringify(tile) === JSON.stringify(newMonsterPos)) {\n            inSight = true;\n          }\n        });\n        // if the monster is now in sight\n        if (inSight) {\n          dispatch({\n            type: 'REVEAL_MONSTER',\n            payload: {\n              id,\n              map: currentMap\n            }\n          });\n        } else {\n          // if the monster is now out of sight\n          dispatch({\n            type: 'HIDE_MONSTER',\n            payload: {\n              id,\n              map: currentMap\n            }\n          });\n        }\n        // move the monster\n        dispatch({\n          type: 'MOVE_MONSTER',\n          payload: {\n            map: currentMap,\n            id,\n            position: newPosition,\n            direction: newPosition[0] < position[0] ? 'WEST' : newPosition[0] > position[0] ? 'EAST' : direction\n          }\n        });\n      }\n    }\n  };\n}\nexport default function scared(sightBox, currentMap, monster) {\n  return dispatch => {\n    const {\n      id,\n      position\n    } = monster;\n    const monsterPosition = position.map(pos => pos / SPRITE_SIZE);\n    let monsterVisible = false;\n    // look through each current sight box tile\n    sightBox.forEach(tile => {\n      // if the monster is in sight\n      if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n        monsterVisible = true;\n      }\n    });\n    if (monsterVisible) {\n      dispatch({\n        type: 'REVEAL_MONSTER',\n        payload: {\n          id,\n          map: currentMap\n        }\n      });\n    }\n    dispatch(moveScared(sightBox, currentMap, monster));\n    if (monster.aiTurns === 0) {\n      dispatch({\n        type: 'CHANGE_AI',\n        payload: {\n          map: currentMap,\n          ai: monster.originalAI,\n          id: monster.id,\n          from: 'scared',\n          turns: 0,\n          entity: monster.type,\n          original: monster.originalAI\n        }\n      });\n    }\n  };\n}","map":{"version":3,"names":["observeImpassable","checkForOtherMonster","attackMonster","SPRITE_SIZE","moveScared","sightBox","currentMap","monster","dispatch","getState","playerPosition","player","position","id","direction","possibleDirections","push","length","newPosition","Math","floor","random","monsterID","inSight","forEach","tile","newMonsterPos","map","value","JSON","stringify","type","payload","scared","monsterPosition","pos","monsterVisible","aiTurns","ai","originalAI","from","turns","entity","original"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/monsters/actions/scared-ai.jsx"],"sourcesContent":["import { observeImpassable, checkForOtherMonster } from './move-monster';\nimport attackMonster from './attack-monster';\nimport { SPRITE_SIZE } from '../../../config/constants';\n\n/**\n * An AI for monsters that have been scared by the player\n *\n * @param {*} sightBox The players FOV\n * @param {*} currentMap The map the player is in\n * @param {*} monster The monster we're moving\n */\nfunction moveScared(sightBox, currentMap, monster) {\n    return (dispatch, getState) => {\n        const playerPosition = getState().player.position;\n        const { id, position, direction } = monster;\n\n        const possibleDirections = [];\n        if (\n            playerPosition[1] !== position[1] - SPRITE_SIZE &&\n            dispatch(\n                observeImpassable([position[0], position[1] - SPRITE_SIZE])\n            )\n        ) {\n            possibleDirections.push([position[0], position[1] - SPRITE_SIZE]);\n        }\n\n        if (\n            playerPosition[1] !== position[1] + SPRITE_SIZE &&\n            dispatch(\n                observeImpassable([position[0], position[1] + SPRITE_SIZE])\n            )\n        ) {\n            possibleDirections.push([position[0], position[1] + SPRITE_SIZE]);\n        }\n\n        if (\n            playerPosition[0] !== position[0] - SPRITE_SIZE &&\n            dispatch(\n                observeImpassable([position[0] - SPRITE_SIZE, position[1]])\n            )\n        ) {\n            possibleDirections.push([position[0] - SPRITE_SIZE, position[1]]);\n        }\n\n        if (\n            playerPosition[0] !== position[0] + SPRITE_SIZE &&\n            dispatch(\n                observeImpassable([position[0] + SPRITE_SIZE, position[1]])\n            )\n        ) {\n            possibleDirections.push([position[0] + SPRITE_SIZE, position[1]]);\n        }\n\n        if (possibleDirections.length > 0) {\n            const newPosition =\n                possibleDirections[\n                    Math.floor(Math.random() * possibleDirections.length)\n                ];\n\n            // From testing, this doesn't really happen... But, if the monster is scared,\n            // it may randomly attack other monsters if they're in thise ones way\n            const monsterID = dispatch(\n                checkForOtherMonster(id, newPosition, currentMap)\n            );\n\n            if (monsterID) {\n                // recalculate if the monster is in sight\n                let inSight = false;\n                // look through each current sight box tile\n                sightBox.forEach(tile => {\n                    // if the monster is in sight\n                    const newMonsterPos = position.map(\n                        value => value / SPRITE_SIZE\n                    );\n                    if (\n                        JSON.stringify(tile) === JSON.stringify(newMonsterPos)\n                    ) {\n                        inSight = true;\n                    }\n                });\n\n                // if the monster is now in sight\n                if (inSight) {\n                    dispatch({\n                        type: 'REVEAL_MONSTER',\n                        payload: { id, map: currentMap },\n                    });\n                } else {\n                    // if the monster is now out of sight\n                    dispatch({\n                        type: 'HIDE_MONSTER',\n                        payload: { id, map: currentMap },\n                    });\n                }\n\n                dispatch(attackMonster(monster, monsterID, currentMap));\n            } else {\n                let inSight = false;\n                // look through each current sight box tile\n                sightBox.forEach(tile => {\n                    // if the monster is in sight\n                    const newMonsterPos = newPosition.map(\n                        value => value / SPRITE_SIZE\n                    );\n                    if (\n                        JSON.stringify(tile) === JSON.stringify(newMonsterPos)\n                    ) {\n                        inSight = true;\n                    }\n                });\n                // if the monster is now in sight\n                if (inSight) {\n                    dispatch({\n                        type: 'REVEAL_MONSTER',\n                        payload: { id, map: currentMap },\n                    });\n                } else {\n                    // if the monster is now out of sight\n                    dispatch({\n                        type: 'HIDE_MONSTER',\n                        payload: { id, map: currentMap },\n                    });\n                }\n                // move the monster\n                dispatch({\n                    type: 'MOVE_MONSTER',\n                    payload: {\n                        map: currentMap,\n                        id,\n                        position: newPosition,\n                        direction:\n                            newPosition[0] < position[0]\n                                ? 'WEST'\n                                : newPosition[0] > position[0]\n                                ? 'EAST'\n                                : direction,\n                    },\n                });\n            }\n        }\n    };\n}\n\nexport default function scared(sightBox, currentMap, monster) {\n    return dispatch => {\n        const { id, position } = monster;\n\n        const monsterPosition = position.map(pos => pos / SPRITE_SIZE);\n\n        let monsterVisible = false;\n        // look through each current sight box tile\n        sightBox.forEach(tile => {\n            // if the monster is in sight\n            if (JSON.stringify(tile) === JSON.stringify(monsterPosition)) {\n                monsterVisible = true;\n            }\n        });\n\n        if (monsterVisible) {\n            dispatch({\n                type: 'REVEAL_MONSTER',\n                payload: { id, map: currentMap },\n            });\n        }\n\n        dispatch(moveScared(sightBox, currentMap, monster));\n\n        if (monster.aiTurns === 0) {\n            dispatch({\n                type: 'CHANGE_AI',\n                payload: {\n                    map: currentMap,\n                    ai: monster.originalAI,\n                    id: monster.id,\n                    from: 'scared',\n                    turns: 0,\n                    entity: monster.type,\n                    original: monster.originalAI,\n                },\n            });\n        }\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}