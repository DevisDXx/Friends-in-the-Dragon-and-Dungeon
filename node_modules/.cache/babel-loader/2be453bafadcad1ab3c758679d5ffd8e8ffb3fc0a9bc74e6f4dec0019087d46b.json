{"ast":null,"code":"import _debounce from 'lodash.debounce';\nimport generateMap from '../../map/random-map-gen/generate-map';\nimport endlessMapMessage from '../../map/random-map-gen/endless-map-message';\nimport uuidv4 from '../../../utils/uuid-v4';\nimport { SPRITE_SIZE, MAP_TRANSITION_DELAY } from '../../../config/constants';\nexport default function walkStairs(nextTile, playerPos) {\n  return _debounce((dispatch, getState) => {\n    const {\n      gameMode,\n      randomMaps,\n      floorNum,\n      currentMap,\n      storyMaps\n    } = getState().world;\n    playerPos = playerPos.map(value => value / SPRITE_SIZE);\n    let direction;\n    // player wants to go down\n    if (nextTile === 2) direction = 'down';\n    // player wants to go up\n    if (nextTile === 3) direction = 'up';\n    if (gameMode === 'endless') {\n      if (direction === 'up') {\n        // conditionally show a message based on floorNum\n        dispatch(endlessMapMessage(floorNum));\n        // if we have reached a new floor\n        if (floorNum === randomMaps.length) {\n          // generate a random map, save it, and set it as the current map\n          const randomMap = generateMap(playerPos, floorNum + 1);\n          const mapId = uuidv4();\n          dispatch({\n            type: 'ADD_RANDOM_MAP',\n            payload: {\n              tiles: randomMap,\n              id: mapId\n            }\n          });\n          dispatch({\n            type: 'SET_ENDLESS_MAP',\n            payload: {\n              map: mapId,\n              floorNum: floorNum + 1\n            }\n          });\n        } else {\n          // figure out the next map and set it as the current\n          dispatch({\n            type: 'SET_ENDLESS_MAP',\n            payload: {\n              // pass the floorNum because with array indexing this will get the next map\n              map: randomMaps[floorNum].id,\n              floorNum: floorNum + 1\n            }\n          });\n        }\n      } else if (direction === 'down' && floorNum > 1) {\n        // figure out the previous map and set it as the current\n        dispatch({\n          type: 'SET_ENDLESS_MAP',\n          payload: {\n            // offset by 2 because we want the previous map and account for array indexing\n            map: randomMaps[floorNum - 2].id,\n            floorNum: floorNum - 1\n          }\n        });\n      }\n    } else {\n      // change the story mode map\n      dispatch({\n        type: 'SET_STORY_MAP',\n        payload: {\n          direction,\n          currentMap,\n          storyMaps\n        }\n      });\n    }\n  }, MAP_TRANSITION_DELAY);\n}","map":{"version":3,"names":["_debounce","generateMap","endlessMapMessage","uuidv4","SPRITE_SIZE","MAP_TRANSITION_DELAY","walkStairs","nextTile","playerPos","dispatch","getState","gameMode","randomMaps","floorNum","currentMap","storyMaps","world","map","value","direction","length","randomMap","mapId","type","payload","tiles","id"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/player/actions/walk-stairs.jsx"],"sourcesContent":["import _debounce from 'lodash.debounce';\n\nimport generateMap from '../../map/random-map-gen/generate-map';\nimport endlessMapMessage from '../../map/random-map-gen/endless-map-message';\nimport uuidv4 from '../../../utils/uuid-v4';\nimport { SPRITE_SIZE, MAP_TRANSITION_DELAY } from '../../../config/constants';\n\nexport default function walkStairs(nextTile, playerPos) {\n    return _debounce((dispatch, getState) => {\n        const {\n            gameMode,\n            randomMaps,\n            floorNum,\n            currentMap,\n            storyMaps,\n        } = getState().world;\n\n        playerPos = playerPos.map(value => value / SPRITE_SIZE);\n\n        let direction;\n        // player wants to go down\n        if (nextTile === 2) direction = 'down';\n        // player wants to go up\n        if (nextTile === 3) direction = 'up';\n\n        if (gameMode === 'endless') {\n            if (direction === 'up') {\n                // conditionally show a message based on floorNum\n                dispatch(endlessMapMessage(floorNum));\n                // if we have reached a new floor\n                if (floorNum === randomMaps.length) {\n                    // generate a random map, save it, and set it as the current map\n                    const randomMap = generateMap(playerPos, floorNum + 1);\n                    const mapId = uuidv4();\n\n                    dispatch({\n                        type: 'ADD_RANDOM_MAP',\n                        payload: {\n                            tiles: randomMap,\n                            id: mapId,\n                        },\n                    });\n                    dispatch({\n                        type: 'SET_ENDLESS_MAP',\n                        payload: {\n                            map: mapId,\n                            floorNum: floorNum + 1,\n                        },\n                    });\n                } else {\n                    // figure out the next map and set it as the current\n                    dispatch({\n                        type: 'SET_ENDLESS_MAP',\n                        payload: {\n                            // pass the floorNum because with array indexing this will get the next map\n                            map: randomMaps[floorNum].id,\n                            floorNum: floorNum + 1,\n                        },\n                    });\n                }\n            } else if (direction === 'down' && floorNum > 1) {\n                // figure out the previous map and set it as the current\n                dispatch({\n                    type: 'SET_ENDLESS_MAP',\n                    payload: {\n                        // offset by 2 because we want the previous map and account for array indexing\n                        map: randomMaps[floorNum - 2].id,\n                        floorNum: floorNum - 1,\n                    },\n                });\n            }\n        } else {\n            // change the story mode map\n            dispatch({\n                type: 'SET_STORY_MAP',\n                payload: { direction, currentMap, storyMaps },\n            });\n        }\n    }, MAP_TRANSITION_DELAY);\n}\n"],"mappings":"AAAA,OAAOA,SAAS,MAAM,iBAAiB;AAEvC,OAAOC,WAAW,MAAM,uCAAuC;AAC/D,OAAOC,iBAAiB,MAAM,8CAA8C;AAC5E,OAAOC,MAAM,MAAM,wBAAwB;AAC3C,SAASC,WAAW,EAAEC,oBAAoB,QAAQ,2BAA2B;AAE7E,eAAe,SAASC,UAAUA,CAACC,QAAQ,EAAEC,SAAS,EAAE;EACpD,OAAOR,SAAS,CAAC,CAACS,QAAQ,EAAEC,QAAQ,KAAK;IACrC,MAAM;MACFC,QAAQ;MACRC,UAAU;MACVC,QAAQ;MACRC,UAAU;MACVC;IACJ,CAAC,GAAGL,QAAQ,CAAC,CAAC,CAACM,KAAK;IAEpBR,SAAS,GAAGA,SAAS,CAACS,GAAG,CAACC,KAAK,IAAIA,KAAK,GAAGd,WAAW,CAAC;IAEvD,IAAIe,SAAS;IACb;IACA,IAAIZ,QAAQ,KAAK,CAAC,EAAEY,SAAS,GAAG,MAAM;IACtC;IACA,IAAIZ,QAAQ,KAAK,CAAC,EAAEY,SAAS,GAAG,IAAI;IAEpC,IAAIR,QAAQ,KAAK,SAAS,EAAE;MACxB,IAAIQ,SAAS,KAAK,IAAI,EAAE;QACpB;QACAV,QAAQ,CAACP,iBAAiB,CAACW,QAAQ,CAAC,CAAC;QACrC;QACA,IAAIA,QAAQ,KAAKD,UAAU,CAACQ,MAAM,EAAE;UAChC;UACA,MAAMC,SAAS,GAAGpB,WAAW,CAACO,SAAS,EAAEK,QAAQ,GAAG,CAAC,CAAC;UACtD,MAAMS,KAAK,GAAGnB,MAAM,CAAC,CAAC;UAEtBM,QAAQ,CAAC;YACLc,IAAI,EAAE,gBAAgB;YACtBC,OAAO,EAAE;cACLC,KAAK,EAAEJ,SAAS;cAChBK,EAAE,EAAEJ;YACR;UACJ,CAAC,CAAC;UACFb,QAAQ,CAAC;YACLc,IAAI,EAAE,iBAAiB;YACvBC,OAAO,EAAE;cACLP,GAAG,EAAEK,KAAK;cACVT,QAAQ,EAAEA,QAAQ,GAAG;YACzB;UACJ,CAAC,CAAC;QACN,CAAC,MAAM;UACH;UACAJ,QAAQ,CAAC;YACLc,IAAI,EAAE,iBAAiB;YACvBC,OAAO,EAAE;cACL;cACAP,GAAG,EAAEL,UAAU,CAACC,QAAQ,CAAC,CAACa,EAAE;cAC5Bb,QAAQ,EAAEA,QAAQ,GAAG;YACzB;UACJ,CAAC,CAAC;QACN;MACJ,CAAC,MAAM,IAAIM,SAAS,KAAK,MAAM,IAAIN,QAAQ,GAAG,CAAC,EAAE;QAC7C;QACAJ,QAAQ,CAAC;UACLc,IAAI,EAAE,iBAAiB;UACvBC,OAAO,EAAE;YACL;YACAP,GAAG,EAAEL,UAAU,CAACC,QAAQ,GAAG,CAAC,CAAC,CAACa,EAAE;YAChCb,QAAQ,EAAEA,QAAQ,GAAG;UACzB;QACJ,CAAC,CAAC;MACN;IACJ,CAAC,MAAM;MACH;MACAJ,QAAQ,CAAC;QACLc,IAAI,EAAE,eAAe;QACrBC,OAAO,EAAE;UAAEL,SAAS;UAAEL,UAAU;UAAEC;QAAU;MAChD,CAAC,CAAC;IACN;EACJ,CAAC,EAAEV,oBAAoB,CAAC;AAC5B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}