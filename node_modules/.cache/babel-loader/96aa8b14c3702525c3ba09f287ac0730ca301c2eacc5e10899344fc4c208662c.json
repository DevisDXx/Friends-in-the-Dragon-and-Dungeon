{"ast":null,"code":"import generateObjects from './generate-objects';\nimport { MAP_DIMENSIONS, MAX_TUNNELS, MAX_LENGTH } from '../../../config/constants';\n\n/**\n * Generate a map for a specific floor, and having a certain start point\n *\n * @param {*} startPos The starting point for the map (where the player spawns)\n * @param {*} floorNum The floor number\n */\nexport default function generateMap(startPos, floorNum) {\n  // change the walls of the dungeon as the floors get higher\n  let wallType = 5;\n  if (floorNum >= 30) wallType = 6;\n  if (floorNum >= 60) wallType = 7;\n  if (floorNum >= 90) wallType = 8;\n  const map = createMapOfWalls(wallType),\n    // create a map of walls to carve rooms and hallways from\n    directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // array to get a random direction from (left,right,up,down)\n  let maxTunnels = MAX_TUNNELS,\n    // store the max tunnels in a local variable that can be decremented\n    currentRow = startPos ? startPos[1] : Math.floor(Math.random() * MAP_DIMENSIONS[1]),\n    // our current row - start at a random spot\n    currentColumn = startPos ? startPos[0] : Math.floor(Math.random() * MAP_DIMENSIONS[0]),\n    // our current column - start at a random spot\n    lastDirection = [],\n    // save the last direction we went\n    randomDirection; // next turn/direction - holds a value from directions\n\n  // lets create some tunnels - while maxTunnels, MAP_DIMENSIONS, and MAX_LENGTH is greater than 0.\n  while (maxTunnels && MAP_DIMENSIONS && MAX_LENGTH) {\n    // lets get a random direction - until it is a perpendicular to our lastDirection\n    // if the last direction = left or right,\n    // then our new direction has to be up or down,\n    // and vice versa\n    do {\n      randomDirection = directions[Math.floor(Math.random() * directions.length)];\n    } while (randomDirection[0] === -lastDirection[0] && randomDirection[1] === -lastDirection[1] || randomDirection[0] === lastDirection[0] && randomDirection[1] === lastDirection[1]);\n    const randomLength = Math.ceil(Math.random() * MAX_LENGTH); // length the next tunnel will be (max of maxLength)\n    let tunnelLength = 0; // current length of tunnel being created\n\n    // lets loop until our tunnel is long enough or until we hit an edge\n    while (tunnelLength < randomLength) {\n      //break the loop if it is going out of the map\n      if (currentRow === 0 && randomDirection[0] === -1 || currentColumn === 0 && randomDirection[1] === -1 || currentRow === MAP_DIMENSIONS[1] - 1 && randomDirection[0] === 1 || currentColumn === MAP_DIMENSIONS[0] - 1 && randomDirection[1] === 1) {\n        break;\n      } else {\n        map[currentRow][currentColumn] = 0; //set the value of the index in map to 0 (a tunnel, making it one longer)\n        currentRow += randomDirection[0]; //add the value from randomDirection to row and col (-1, 0, or 1) to update our location\n        currentColumn += randomDirection[1];\n        tunnelLength++; //the tunnel is now one longer, so lets increment that variable\n      }\n    }\n    if (tunnelLength) {\n      // update our variables unless our last loop broke before we made any part of a tunnel\n      lastDirection = randomDirection; //set lastDirection, so we can remember what way we went\n      maxTunnels--; // we created a whole tunnel so lets decrement how many we have left to create\n    }\n  }\n\n  // all our tunnels have been created and now we run placeObjects(),\n  // which will complete our map, so lets return it to our render()\n  return generateObjects(map, floorNum, startPos, wallType);\n}\n\n// generate a map filled with wall tiles\nfunction createMapOfWalls(wallType) {\n  const array = [];\n  for (let i = 0; i < MAP_DIMENSIONS[1]; i++) {\n    array.push([]);\n    for (let j = 0; j < MAP_DIMENSIONS[0]; j++) {\n      array[i].push(wallType);\n    }\n  }\n  return array;\n}","map":{"version":3,"names":["generateObjects","MAP_DIMENSIONS","MAX_TUNNELS","MAX_LENGTH","generateMap","startPos","floorNum","wallType","map","createMapOfWalls","directions","maxTunnels","currentRow","Math","floor","random","currentColumn","lastDirection","randomDirection","length","randomLength","ceil","tunnelLength","array","i","push","j"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/map/random-map-gen/generate-map.jsx"],"sourcesContent":["import generateObjects from './generate-objects';\nimport { MAP_DIMENSIONS, MAX_TUNNELS, MAX_LENGTH } from '../../../config/constants';\n\n/**\n * Generate a map for a specific floor, and having a certain start point\n *\n * @param {*} startPos The starting point for the map (where the player spawns)\n * @param {*} floorNum The floor number\n */\nexport default function generateMap(startPos, floorNum) {\n  // change the walls of the dungeon as the floors get higher\n  let wallType = 5;\n  if (floorNum >= 30) wallType = 6;\n  if (floorNum >= 60) wallType = 7;\n  if (floorNum >= 90) wallType = 8;\n\n  const map = createMapOfWalls(wallType), // create a map of walls to carve rooms and hallways from\n    directions = [\n      [-1, 0],\n      [1, 0],\n      [0, -1],\n      [0, 1],\n    ]; // array to get a random direction from (left,right,up,down)\n  let maxTunnels = MAX_TUNNELS, // store the max tunnels in a local variable that can be decremented\n    currentRow = startPos ? startPos[1] : Math.floor(Math.random() * MAP_DIMENSIONS[1]), // our current row - start at a random spot\n    currentColumn = startPos ? startPos[0] : Math.floor(Math.random() * MAP_DIMENSIONS[0]), // our current column - start at a random spot\n    lastDirection = [], // save the last direction we went\n    randomDirection; // next turn/direction - holds a value from directions\n\n  // lets create some tunnels - while maxTunnels, MAP_DIMENSIONS, and MAX_LENGTH is greater than 0.\n  while (maxTunnels && MAP_DIMENSIONS && MAX_LENGTH) {\n    // lets get a random direction - until it is a perpendicular to our lastDirection\n    // if the last direction = left or right,\n    // then our new direction has to be up or down,\n    // and vice versa\n    do {\n      randomDirection = directions[Math.floor(Math.random() * directions.length)];\n    } while (\n      (randomDirection[0] === -lastDirection[0] && randomDirection[1] === -lastDirection[1]) ||\n      (randomDirection[0] === lastDirection[0] && randomDirection[1] === lastDirection[1])\n    );\n\n    const randomLength = Math.ceil(Math.random() * MAX_LENGTH); // length the next tunnel will be (max of maxLength)\n    let tunnelLength = 0; // current length of tunnel being created\n\n    // lets loop until our tunnel is long enough or until we hit an edge\n    while (tunnelLength < randomLength) {\n      //break the loop if it is going out of the map\n      if (\n        (currentRow === 0 && randomDirection[0] === -1) ||\n        (currentColumn === 0 && randomDirection[1] === -1) ||\n        (currentRow === MAP_DIMENSIONS[1] - 1 && randomDirection[0] === 1) ||\n        (currentColumn === MAP_DIMENSIONS[0] - 1 && randomDirection[1] === 1)\n      ) {\n        break;\n      } else {\n        map[currentRow][currentColumn] = 0; //set the value of the index in map to 0 (a tunnel, making it one longer)\n        currentRow += randomDirection[0]; //add the value from randomDirection to row and col (-1, 0, or 1) to update our location\n        currentColumn += randomDirection[1];\n        tunnelLength++; //the tunnel is now one longer, so lets increment that variable\n      }\n    }\n\n    if (tunnelLength) {\n      // update our variables unless our last loop broke before we made any part of a tunnel\n      lastDirection = randomDirection; //set lastDirection, so we can remember what way we went\n      maxTunnels--; // we created a whole tunnel so lets decrement how many we have left to create\n    }\n  }\n\n  // all our tunnels have been created and now we run placeObjects(),\n  // which will complete our map, so lets return it to our render()\n  return generateObjects(map, floorNum, startPos, wallType);\n}\n\n// generate a map filled with wall tiles\nfunction createMapOfWalls(wallType) {\n  const array = [];\n  for (let i = 0; i < MAP_DIMENSIONS[1]; i++) {\n    array.push([]);\n    for (let j = 0; j < MAP_DIMENSIONS[0]; j++) {\n      array[i].push(wallType);\n    }\n  }\n  return array;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}