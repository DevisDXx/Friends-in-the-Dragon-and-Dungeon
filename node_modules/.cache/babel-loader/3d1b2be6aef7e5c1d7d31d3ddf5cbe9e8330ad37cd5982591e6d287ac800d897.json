{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\devis\\\\Downloads\\\\react-rpg.com-master\\\\src\\\\features\\\\player\\\\index.jsx\";\nimport React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport ReactTimeout from 'react-timeout';\nimport Sound from 'react-sound';\nimport MonsterAttack from '../monsters/assets/monster-attack.wav';\nimport MonsterDeath from '../monsters/assets/monster-death.wav';\nimport MonsterSlash from '../monsters/assets/monster-slash.png';\nimport PlayerDeath from './assets/player-death.mp3';\nimport SwordSlash from './assets/sword-slash.png';\nimport PlayerStep from './assets/player-step.wav';\nimport SwordSwish from './assets/player-sword-swish.wav';\nimport Animation from '../../components/animation';\nimport PlayerHair from './assets/player-hair.png';\nimport PlayerEyes from './assets/player-eyes.png';\nimport PlayerSkin from './assets/player-skin.png';\nimport PlayerArmour from './assets/player-armour.png';\nimport PlayerClothes from './assets/player-clothes.png';\nimport PlayerOutline from './assets/player-outline.png';\nimport { ANIMATION_SPEED, SPRITE_SIZE, FISTS, HUE_OFFSETS } from '../../config/constants';\nimport './styles.scss';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nclass Player extends Component {\n  constructor(props) {\n    super(props);\n    this.canvasRef = /*#__PURE__*/React.createRef();\n    this.directionMap = {\n      SOUTH: 0,\n      // facing down, line 1 of spritesheet\n      NORTH: 1,\n      // facinf up, line 2 of spritesheet\n      WEST: 2,\n      // facing left, line 3 of spritesheet\n      EAST: 3 // facing right, line 4 of spritesheet\n    };\n    this.state = {\n      attackAnimationPlay: 'paused',\n      attackAnimationLoc: [0, 0],\n      animationWalkSound: null,\n      animationAttackSound: null,\n      monsterAttackAnimationPlay: 'paused',\n      monsterAnimationAttackSound: null,\n      monsterProjectileAnimation: null,\n      monsterDeath: null,\n      playerDeath: null,\n      leftSideStride: true,\n      stamp: 0\n    };\n  }\n  avatar(action) {\n    let dir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (this.canvasRef && this.canvasRef.current) {\n      const ctx = this.canvasRef.current.getContext('2d');\n      const spriteLine = dir * SPRITE_SIZE;\n      let currentFrame = this.state.leftSideStride ? 0 : 5;\n      let currentTick = 0;\n      const ticksPerFrame = 5;\n      const {\n        hairColour,\n        skinColour,\n        armourColour,\n        clothesColour\n      } = this.props.dialog.appearance;\n      const colours = [['hair', `hue-rotate(${hairColour + HUE_OFFSETS.hairColour}deg)`], ['skin', `hue-rotate(${skinColour + HUE_OFFSETS.skinColour}deg)`], ['armour', `hue-rotate(${armourColour + HUE_OFFSETS.armourColour}deg)`], ['clothes', `hue-rotate(${clothesColour + HUE_OFFSETS.clothesColour}deg)`], ['outline', 'none'], ['eyes', 'none']];\n      const draw = frame => {\n        // don't allow invalid frames\n        if (frame > 7 || frame < 0) frame = 0;\n        ctx.clearRect(0, 0, SPRITE_SIZE, SPRITE_SIZE);\n        colours.forEach(colour => {\n          ctx.filter = colour[1];\n          ctx.drawImage(this.sprite[colour[0]], frame * SPRITE_SIZE, spriteLine, SPRITE_SIZE, SPRITE_SIZE, 0, 0, SPRITE_SIZE, SPRITE_SIZE);\n        });\n      };\n      const update = () => {\n        currentTick += 1;\n        if (currentTick > ticksPerFrame) {\n          currentTick = 0;\n          currentFrame += 1;\n        }\n      };\n      const main = () => {\n        draw(currentFrame);\n        update();\n        const id = window.requestAnimationFrame(main);\n        if (this.state.leftSideStride && currentFrame > 4) {\n          window.cancelAnimationFrame(id);\n        }\n        if (!this.state.leftSideStride && currentFrame > 8) {\n          window.cancelAnimationFrame(id);\n        }\n      };\n      if (action === 'draw') {\n        draw(0);\n      }\n      if (action === 'animate') {\n        main();\n      }\n    }\n  }\n  componentDidMount() {\n    this.sprite = {\n      hair: new Image(),\n      eyes: new Image(),\n      skin: new Image(),\n      armour: new Image(),\n      clothes: new Image(),\n      outline: new Image()\n    };\n    this.sprite.hair.src = PlayerHair;\n    this.sprite.eyes.src = PlayerEyes;\n    this.sprite.skin.src = PlayerSkin;\n    this.sprite.armour.src = PlayerArmour;\n    this.sprite.clothes.src = PlayerClothes;\n    this.sprite.outline.src = PlayerOutline;\n    this.sprite.onload = () => {\n      this.avatar('draw', this.directionMap[this.props.player.direction]);\n    };\n  }\n\n  // this is used to tell when to animate the player\n  componentDidUpdate(prevProps, prevState) {\n    this.avatar('draw', this.directionMap[this.props.player.direction]);\n\n    // detemine when the player has moved\n    if (prevProps.player.playerMoved !== this.props.player.playerMoved && this.state.stamp + ANIMATION_SPEED < Date.now()) {\n      let animationWalkSound = null;\n      if (this.props.gameMenu.sound) {\n        animationWalkSound = /*#__PURE__*/_jsxDEV(Sound, {\n          url: PlayerStep,\n          playStatus: 'PLAYING',\n          autoLoad: true,\n          volume: 100\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 160,\n          columnNumber: 11\n        }, this);\n      }\n      this.setState({\n        stamp: Date.now(),\n        animationWalkSound,\n        leftSideStride: !this.state.leftSideStride\n      }, () => {\n        this.avatar('animate', this.directionMap[this.props.player.direction]);\n      });\n    }\n    // see if player died\n    else if (prevProps.player.playerDied !== this.props.player.playerDied) {\n      let playerDeath = null;\n      if (this.props.gameMenu.sound) {\n        playerDeath = /*#__PURE__*/_jsxDEV(Sound, {\n          url: PlayerDeath,\n          playStatus: 'PLAYING',\n          autoLoad: true,\n          volume: 100\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 179,\n          columnNumber: 11\n        }, this);\n      }\n      // player the player death sound after\n      this.props.setTimeout(() => this.setState({\n        playerDeath\n      }), ANIMATION_SPEED);\n      // pause the infinite animation after 1 iteration\n      this.props.setTimeout(() => this.setState({\n        playerDeath: null\n      }), ANIMATION_SPEED + ANIMATION_SPEED * 4);\n    }\n    // see if a monster died\n    else if (prevProps.player.monsterDied !== this.props.player.monsterDied) {\n      let monsterDeath = null;\n      if (this.props.gameMenu.sound) {\n        monsterDeath = /*#__PURE__*/_jsxDEV(Sound, {\n          url: MonsterDeath,\n          playStatus: 'PLAYING',\n          autoLoad: true,\n          volume: 100\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 195,\n          columnNumber: 11\n        }, this);\n      }\n      // play the monster death sound after delay\n      this.props.setTimeout(() => this.setState({\n        monsterDeath\n      }), ANIMATION_SPEED);\n      // pause the infinite animation after 1 iteration and the delay\n      this.props.setTimeout(() => this.setState({\n        monsterDeath: null\n      }), ANIMATION_SPEED + ANIMATION_SPEED * 3.5);\n    }\n    // see if a monster attacked the player\n    else if (prevProps.player.monsterAttacked !== this.props.player.monsterAttacked || prevProps.player.monsterUseProjectile !== this.props.player.monsterUseProjectile) {\n      let monsterAnimationAttackSound = null;\n      let monsterProjectileAnimation = null;\n      if (this.props.gameMenu.sound) {\n        monsterAnimationAttackSound = /*#__PURE__*/_jsxDEV(Sound, {\n          url: MonsterAttack,\n          playStatus: 'PLAYING',\n          autoLoad: true,\n          volume: 100\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 215,\n          columnNumber: 11\n        }, this);\n      }\n      if (prevProps.player.monsterUseProjectile !== this.props.player.monsterUseProjectile) {\n        // A monster used a projectile, so we need to show that\n        monsterProjectileAnimation = /*#__PURE__*/_jsxDEV(Animation, {\n          projectile: this.props.player.monsterProjectile,\n          startPosition: [this.props.player.monsterProjectileTargetPosition[0] - this.props.player.position[0], this.props.player.monsterProjectileTargetPosition[1] - this.props.player.position[1]],\n          endPosition: this.props.player.monsterProjectile.target.includes('self') ? this.props.player.monsterProjectileTargetPosition // If they're tartgetting themselves, then use their position\n          : [0, 0] // Otherwise it's targetting the player\n          ,\n          direction: this.props.player.monsterProjectileDirection\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 222,\n          columnNumber: 11\n        }, this);\n      }\n\n      // animate the player\n      this.setState({\n        monsterAttackAnimationPlay: 'running',\n        monsterAnimationAttackSound,\n        monsterProjectileAnimation\n      });\n      // pause the infinite animation after 1 iteration plus delay time (250ms)\n      this.props.setTimeout(() => this.setState({\n        monsterAttackAnimationPlay: 'paused',\n        monsterAnimationAttackSound: null,\n        monsterProjectileAnimation: null\n      }), ANIMATION_SPEED + 250);\n    }\n    // see if the player attacked\n    else if (prevProps.player.spellCast !== this.props.player.spellCast) {\n      let attackAnimationLoc = [0, 0];\n      // calculate which way the sword should slash\n      switch (this.props.player.direction) {\n        case 'SOUTH':\n          attackAnimationLoc = [0, SPRITE_SIZE];\n          break;\n        case 'EAST':\n          attackAnimationLoc = [SPRITE_SIZE, 0];\n          break;\n        case 'WEST':\n          attackAnimationLoc = [-SPRITE_SIZE, 0];\n          break;\n        case 'NORTH':\n          attackAnimationLoc = [0, -SPRITE_SIZE];\n          break;\n        default:\n      }\n      let animationAttackSound = null;\n      if (this.props.gameMenu.sound) {\n        animationAttackSound = /*#__PURE__*/_jsxDEV(Sound, {\n          url: SwordSwish,\n          playStatus: 'PLAYING',\n          autoLoad: true,\n          volume: 100\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 277,\n          columnNumber: 11\n        }, this);\n      }\n      // animate the sword slash\n      this.setState({\n        attackAnimationPlay: 'spell',\n        attackAnimationLoc,\n        animationAttackSound\n      });\n      // pause the infinite animation after 1 iteration\n      this.props.setTimeout(() => this.setState({\n        attackAnimationPlay: 'paused',\n        animationAttackSound: null\n      }), ANIMATION_SPEED);\n    } else if (prevProps.player.playerAttacked !== this.props.player.playerAttacked) {\n      let attackAnimationLoc = [0, 0];\n      // calculate which way the sword should slash\n      switch (this.props.player.direction) {\n        case 'SOUTH':\n          attackAnimationLoc = [0, SPRITE_SIZE];\n          break;\n        case 'EAST':\n          attackAnimationLoc = [SPRITE_SIZE, 0];\n          break;\n        case 'WEST':\n          attackAnimationLoc = [-SPRITE_SIZE, 0];\n          break;\n        case 'NORTH':\n          attackAnimationLoc = [0, -SPRITE_SIZE];\n          break;\n        default:\n      }\n      let animationAttackSound = null;\n      if (this.props.gameMenu.sound) {\n        animationAttackSound = /*#__PURE__*/_jsxDEV(Sound, {\n          url: SwordSwish,\n          playStatus: 'PLAYING',\n          autoLoad: true,\n          volume: 100\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 316,\n          columnNumber: 11\n        }, this);\n      }\n      const weapon = this.props.stats.equippedItems.weapon || FISTS;\n\n      // animate the sword slash\n      this.setState({\n        attackAnimationPlay: weapon.kind || 'running',\n        attackAnimationLoc,\n        animationAttackSound\n      });\n      // pause the infinite animation after 1 iteration\n      this.props.setTimeout(() => this.setState({\n        attackAnimationPlay: 'paused',\n        animationAttackSound: null\n      }), ANIMATION_SPEED);\n    }\n  }\n  render() {\n    const {\n      attackAnimationPlay,\n      attackAnimationLoc,\n      animationWalkSound,\n      animationAttackSound,\n      monsterAnimationAttackSound,\n      monsterAttackAnimationPlay,\n      monsterProjectileAnimation,\n      monsterDeath,\n      playerDeath\n    } = this.state;\n    const {\n      player,\n      dialog,\n      stats\n    } = this.props;\n    const {\n      gameStart\n    } = dialog;\n    // game start menu open, hide the player\n    if (gameStart) return null;\n\n    // Determine what the projectile the player used was\n    const projectile = attackAnimationPlay === 'spell' ? player.spell : attackAnimationPlay === 'ranged' ? stats.equippedItems.weapon.projectile : null;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"player__animation\",\n      style: {\n        top: player.position[1],\n        left: player.position[0]\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: this.canvasRef,\n        width: 40,\n        height: 40\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 374,\n        columnNumber: 9\n      }, this), animationWalkSound, animationAttackSound, monsterAnimationAttackSound, monsterDeath, playerDeath, monsterProjectileAnimation, monsterAttackAnimationPlay === 'running' && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"monster__slash\",\n        style: {\n          backgroundImage: `url('${MonsterSlash}')`\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 384,\n        columnNumber: 11\n      }, this), attackAnimationPlay !== 'paused' && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"sword__slash\",\n        style: {\n          top: attackAnimationLoc[1],\n          left: attackAnimationLoc[0],\n          backgroundImage: `url('${SwordSlash}')`\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 388,\n        columnNumber: 11\n      }, this), projectile && /*#__PURE__*/_jsxDEV(Animation, {\n        projectile: projectile,\n        startPosition: attackAnimationLoc,\n        endPosition: [player.targetPosition[0] - player.position[0], player.targetPosition[1] - player.position[1]],\n        direction: player.direction\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 399,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 367,\n      columnNumber: 7\n    }, this);\n  }\n}\nconst mapStateToProps = _ref => {\n  let {\n    gameMenu,\n    player,\n    dialog,\n    stats\n  } = _ref;\n  return {\n    gameMenu,\n    player,\n    dialog,\n    stats\n  };\n};\nexport default connect(mapStateToProps)(ReactTimeout(Player));","map":{"version":3,"names":["React","Component","connect","ReactTimeout","Sound","MonsterAttack","MonsterDeath","MonsterSlash","PlayerDeath","SwordSlash","PlayerStep","SwordSwish","Animation","PlayerHair","PlayerEyes","PlayerSkin","PlayerArmour","PlayerClothes","PlayerOutline","ANIMATION_SPEED","SPRITE_SIZE","FISTS","HUE_OFFSETS","jsxDEV","_jsxDEV","Player","constructor","props","canvasRef","createRef","directionMap","SOUTH","NORTH","WEST","EAST","state","attackAnimationPlay","attackAnimationLoc","animationWalkSound","animationAttackSound","monsterAttackAnimationPlay","monsterAnimationAttackSound","monsterProjectileAnimation","monsterDeath","playerDeath","leftSideStride","stamp","avatar","action","dir","arguments","length","undefined","current","ctx","getContext","spriteLine","currentFrame","currentTick","ticksPerFrame","hairColour","skinColour","armourColour","clothesColour","dialog","appearance","colours","draw","frame","clearRect","forEach","colour","filter","drawImage","sprite","update","main","id","window","requestAnimationFrame","cancelAnimationFrame","componentDidMount","hair","Image","eyes","skin","armour","clothes","outline","src","onload","player","direction","componentDidUpdate","prevProps","prevState","playerMoved","Date","now","gameMenu","sound","url","playStatus","autoLoad","volume","fileName","_jsxFileName","lineNumber","columnNumber","setState","playerDied","setTimeout","monsterDied","monsterAttacked","monsterUseProjectile","projectile","monsterProjectile","startPosition","monsterProjectileTargetPosition","position","endPosition","target","includes","monsterProjectileDirection","spellCast","playerAttacked","weapon","stats","equippedItems","kind","render","gameStart","spell","className","style","top","left","children","ref","width","height","backgroundImage","targetPosition","mapStateToProps","_ref"],"sources":["C:/Users/devis/Downloads/react-rpg.com-master/src/features/player/index.jsx"],"sourcesContent":["import React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport ReactTimeout from 'react-timeout';\nimport Sound from 'react-sound';\n\nimport MonsterAttack from '../monsters/assets/monster-attack.wav';\nimport MonsterDeath from '../monsters/assets/monster-death.wav';\nimport MonsterSlash from '../monsters/assets/monster-slash.png';\nimport PlayerDeath from './assets/player-death.mp3';\nimport SwordSlash from './assets/sword-slash.png';\nimport PlayerStep from './assets/player-step.wav';\nimport SwordSwish from './assets/player-sword-swish.wav';\nimport Animation from '../../components/animation';\n\nimport PlayerHair from './assets/player-hair.png';\nimport PlayerEyes from './assets/player-eyes.png';\nimport PlayerSkin from './assets/player-skin.png';\nimport PlayerArmour from './assets/player-armour.png';\nimport PlayerClothes from './assets/player-clothes.png';\nimport PlayerOutline from './assets/player-outline.png';\n\nimport { ANIMATION_SPEED, SPRITE_SIZE, FISTS, HUE_OFFSETS } from '../../config/constants';\n\nimport './styles.scss';\n\nclass Player extends Component {\n  constructor(props) {\n    super(props);\n\n    this.canvasRef = React.createRef();\n    this.directionMap = {\n      SOUTH: 0, // facing down, line 1 of spritesheet\n      NORTH: 1, // facinf up, line 2 of spritesheet\n      WEST: 2, // facing left, line 3 of spritesheet\n      EAST: 3, // facing right, line 4 of spritesheet\n    };\n\n    this.state = {\n      attackAnimationPlay: 'paused',\n      attackAnimationLoc: [0, 0],\n      animationWalkSound: null,\n      animationAttackSound: null,\n      monsterAttackAnimationPlay: 'paused',\n      monsterAnimationAttackSound: null,\n      monsterProjectileAnimation: null,\n      monsterDeath: null,\n      playerDeath: null,\n      leftSideStride: true,\n      stamp: 0,\n    };\n  }\n\n  avatar(action, dir = 0) {\n    if (this.canvasRef && this.canvasRef.current) {\n      const ctx = this.canvasRef.current.getContext('2d');\n      const spriteLine = dir * SPRITE_SIZE;\n\n      let currentFrame = this.state.leftSideStride ? 0 : 5;\n      let currentTick = 0;\n      const ticksPerFrame = 5;\n\n      const { hairColour, skinColour, armourColour, clothesColour } = this.props.dialog.appearance;\n\n      const colours = [\n        ['hair', `hue-rotate(${hairColour + HUE_OFFSETS.hairColour}deg)`],\n        ['skin', `hue-rotate(${skinColour + HUE_OFFSETS.skinColour}deg)`],\n        ['armour', `hue-rotate(${armourColour + HUE_OFFSETS.armourColour}deg)`],\n        ['clothes', `hue-rotate(${clothesColour + HUE_OFFSETS.clothesColour}deg)`],\n        ['outline', 'none'],\n        ['eyes', 'none'],\n      ];\n\n      const draw = (frame) => {\n        // don't allow invalid frames\n        if (frame > 7 || frame < 0) frame = 0;\n\n        ctx.clearRect(0, 0, SPRITE_SIZE, SPRITE_SIZE);\n\n        colours.forEach((colour) => {\n          ctx.filter = colour[1];\n          ctx.drawImage(\n            this.sprite[colour[0]],\n            frame * SPRITE_SIZE,\n            spriteLine,\n            SPRITE_SIZE,\n            SPRITE_SIZE,\n            0,\n            0,\n            SPRITE_SIZE,\n            SPRITE_SIZE\n          );\n        });\n      };\n\n      const update = () => {\n        currentTick += 1;\n\n        if (currentTick > ticksPerFrame) {\n          currentTick = 0;\n          currentFrame += 1;\n        }\n      };\n\n      const main = () => {\n        draw(currentFrame);\n        update();\n        const id = window.requestAnimationFrame(main);\n        if (this.state.leftSideStride && currentFrame > 4) {\n          window.cancelAnimationFrame(id);\n        }\n        if (!this.state.leftSideStride && currentFrame > 8) {\n          window.cancelAnimationFrame(id);\n        }\n      };\n\n      if (action === 'draw') {\n        draw(0);\n      }\n\n      if (action === 'animate') {\n        main();\n      }\n    }\n  }\n\n  componentDidMount() {\n    this.sprite = {\n      hair: new Image(),\n      eyes: new Image(),\n      skin: new Image(),\n      armour: new Image(),\n      clothes: new Image(),\n      outline: new Image(),\n    };\n\n    this.sprite.hair.src = PlayerHair;\n    this.sprite.eyes.src = PlayerEyes;\n    this.sprite.skin.src = PlayerSkin;\n    this.sprite.armour.src = PlayerArmour;\n    this.sprite.clothes.src = PlayerClothes;\n    this.sprite.outline.src = PlayerOutline;\n\n    this.sprite.onload = () => {\n      this.avatar('draw', this.directionMap[this.props.player.direction]);\n    };\n  }\n\n  // this is used to tell when to animate the player\n  componentDidUpdate(prevProps, prevState) {\n    this.avatar('draw', this.directionMap[this.props.player.direction]);\n\n    // detemine when the player has moved\n    if (\n      prevProps.player.playerMoved !== this.props.player.playerMoved &&\n      this.state.stamp + ANIMATION_SPEED < Date.now()\n    ) {\n      let animationWalkSound = null;\n      if (this.props.gameMenu.sound) {\n        animationWalkSound = (\n          <Sound url={PlayerStep} playStatus={'PLAYING'} autoLoad={true} volume={100} />\n        );\n      }\n      this.setState(\n        {\n          stamp: Date.now(),\n          animationWalkSound,\n          leftSideStride: !this.state.leftSideStride,\n        },\n        () => {\n          this.avatar('animate', this.directionMap[this.props.player.direction]);\n        }\n      );\n    }\n    // see if player died\n    else if (prevProps.player.playerDied !== this.props.player.playerDied) {\n      let playerDeath = null;\n      if (this.props.gameMenu.sound) {\n        playerDeath = (\n          <Sound url={PlayerDeath} playStatus={'PLAYING'} autoLoad={true} volume={100} />\n        );\n      }\n      // player the player death sound after\n      this.props.setTimeout(() => this.setState({ playerDeath }), ANIMATION_SPEED);\n      // pause the infinite animation after 1 iteration\n      this.props.setTimeout(\n        () => this.setState({ playerDeath: null }),\n        ANIMATION_SPEED + ANIMATION_SPEED * 4\n      );\n    }\n    // see if a monster died\n    else if (prevProps.player.monsterDied !== this.props.player.monsterDied) {\n      let monsterDeath = null;\n      if (this.props.gameMenu.sound) {\n        monsterDeath = (\n          <Sound url={MonsterDeath} playStatus={'PLAYING'} autoLoad={true} volume={100} />\n        );\n      }\n      // play the monster death sound after delay\n      this.props.setTimeout(() => this.setState({ monsterDeath }), ANIMATION_SPEED);\n      // pause the infinite animation after 1 iteration and the delay\n      this.props.setTimeout(\n        () => this.setState({ monsterDeath: null }),\n        ANIMATION_SPEED + ANIMATION_SPEED * 3.5\n      );\n    }\n    // see if a monster attacked the player\n    else if (\n      prevProps.player.monsterAttacked !== this.props.player.monsterAttacked ||\n      prevProps.player.monsterUseProjectile !== this.props.player.monsterUseProjectile\n    ) {\n      let monsterAnimationAttackSound = null;\n      let monsterProjectileAnimation = null;\n      if (this.props.gameMenu.sound) {\n        monsterAnimationAttackSound = (\n          <Sound url={MonsterAttack} playStatus={'PLAYING'} autoLoad={true} volume={100} />\n        );\n      }\n\n      if (prevProps.player.monsterUseProjectile !== this.props.player.monsterUseProjectile) {\n        // A monster used a projectile, so we need to show that\n        monsterProjectileAnimation = (\n          <Animation\n            projectile={this.props.player.monsterProjectile}\n            startPosition={[\n              this.props.player.monsterProjectileTargetPosition[0] - this.props.player.position[0],\n              this.props.player.monsterProjectileTargetPosition[1] - this.props.player.position[1],\n            ]}\n            endPosition={\n              this.props.player.monsterProjectile.target.includes('self')\n                ? this.props.player.monsterProjectileTargetPosition // If they're tartgetting themselves, then use their position\n                : [0, 0] // Otherwise it's targetting the player\n            }\n            direction={this.props.player.monsterProjectileDirection}\n          />\n        );\n      }\n\n      // animate the player\n      this.setState({\n        monsterAttackAnimationPlay: 'running',\n        monsterAnimationAttackSound,\n        monsterProjectileAnimation,\n      });\n      // pause the infinite animation after 1 iteration plus delay time (250ms)\n      this.props.setTimeout(\n        () =>\n          this.setState({\n            monsterAttackAnimationPlay: 'paused',\n            monsterAnimationAttackSound: null,\n            monsterProjectileAnimation: null,\n          }),\n        ANIMATION_SPEED + 250\n      );\n    }\n    // see if the player attacked\n    else if (prevProps.player.spellCast !== this.props.player.spellCast) {\n      let attackAnimationLoc = [0, 0];\n      // calculate which way the sword should slash\n      switch (this.props.player.direction) {\n        case 'SOUTH':\n          attackAnimationLoc = [0, SPRITE_SIZE];\n          break;\n        case 'EAST':\n          attackAnimationLoc = [SPRITE_SIZE, 0];\n          break;\n        case 'WEST':\n          attackAnimationLoc = [-SPRITE_SIZE, 0];\n          break;\n        case 'NORTH':\n          attackAnimationLoc = [0, -SPRITE_SIZE];\n          break;\n        default:\n      }\n      let animationAttackSound = null;\n      if (this.props.gameMenu.sound) {\n        animationAttackSound = (\n          <Sound url={SwordSwish} playStatus={'PLAYING'} autoLoad={true} volume={100} />\n        );\n      }\n      // animate the sword slash\n      this.setState({\n        attackAnimationPlay: 'spell',\n        attackAnimationLoc,\n        animationAttackSound,\n      });\n      // pause the infinite animation after 1 iteration\n      this.props.setTimeout(\n        () =>\n          this.setState({\n            attackAnimationPlay: 'paused',\n            animationAttackSound: null,\n          }),\n        ANIMATION_SPEED\n      );\n    } else if (prevProps.player.playerAttacked !== this.props.player.playerAttacked) {\n      let attackAnimationLoc = [0, 0];\n      // calculate which way the sword should slash\n      switch (this.props.player.direction) {\n        case 'SOUTH':\n          attackAnimationLoc = [0, SPRITE_SIZE];\n          break;\n        case 'EAST':\n          attackAnimationLoc = [SPRITE_SIZE, 0];\n          break;\n        case 'WEST':\n          attackAnimationLoc = [-SPRITE_SIZE, 0];\n          break;\n        case 'NORTH':\n          attackAnimationLoc = [0, -SPRITE_SIZE];\n          break;\n        default:\n      }\n      let animationAttackSound = null;\n      if (this.props.gameMenu.sound) {\n        animationAttackSound = (\n          <Sound url={SwordSwish} playStatus={'PLAYING'} autoLoad={true} volume={100} />\n        );\n      }\n\n      const weapon = this.props.stats.equippedItems.weapon || FISTS;\n\n      // animate the sword slash\n      this.setState({\n        attackAnimationPlay: weapon.kind || 'running',\n        attackAnimationLoc,\n        animationAttackSound,\n      });\n      // pause the infinite animation after 1 iteration\n      this.props.setTimeout(\n        () =>\n          this.setState({\n            attackAnimationPlay: 'paused',\n            animationAttackSound: null,\n          }),\n        ANIMATION_SPEED\n      );\n    }\n  }\n\n  render() {\n    const {\n      attackAnimationPlay,\n      attackAnimationLoc,\n      animationWalkSound,\n      animationAttackSound,\n      monsterAnimationAttackSound,\n      monsterAttackAnimationPlay,\n      monsterProjectileAnimation,\n      monsterDeath,\n      playerDeath,\n    } = this.state;\n    const { player, dialog, stats } = this.props;\n\n    const { gameStart } = dialog;\n    // game start menu open, hide the player\n    if (gameStart) return null;\n\n    // Determine what the projectile the player used was\n    const projectile =\n      attackAnimationPlay === 'spell'\n        ? player.spell\n        : attackAnimationPlay === 'ranged'\n        ? stats.equippedItems.weapon.projectile\n        : null;\n\n    return (\n      <div\n        className=\"player__animation\"\n        style={{\n          top: player.position[1],\n          left: player.position[0],\n        }}\n      >\n        <canvas ref={this.canvasRef} width={40} height={40} />\n\n        {animationWalkSound}\n        {animationAttackSound}\n        {monsterAnimationAttackSound}\n        {monsterDeath}\n        {playerDeath}\n        {monsterProjectileAnimation}\n\n        {monsterAttackAnimationPlay === 'running' && (\n          <div className=\"monster__slash\" style={{ backgroundImage: `url('${MonsterSlash}')` }} />\n        )}\n\n        {attackAnimationPlay !== 'paused' && (\n          <div\n            className=\"sword__slash\"\n            style={{\n              top: attackAnimationLoc[1],\n              left: attackAnimationLoc[0],\n              backgroundImage: `url('${SwordSlash}')`,\n            }}\n          />\n        )}\n\n        {projectile && (\n          <Animation\n            projectile={projectile}\n            startPosition={attackAnimationLoc}\n            endPosition={[\n              player.targetPosition[0] - player.position[0],\n              player.targetPosition[1] - player.position[1],\n            ]}\n            direction={player.direction}\n          />\n        )}\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = ({ gameMenu, player, dialog, stats }) => ({\n  gameMenu,\n  player,\n  dialog,\n  stats,\n});\n\nexport default connect(mapStateToProps)(ReactTimeout(Player));\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}